<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CodeFormer AI 开源视频、图片修复软件安装及设置</title>
    <url>/2023/02/20/AI%E8%A7%86%E9%A2%91%E4%B8%8E%E5%9B%BE%E7%89%87%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<p>项目地址：<a href="https://github.com/sczhou/CodeFormer">CodeFormer项目</a></p>
<p>通过CodeFormer项目可以实现人像的面部修复（需要裁剪和对齐面部）、整体图像增强与视频增强，实现效果如下：</p>
<span id="more"></span> 

<img src="color_enhancement_result1.png" style="zoom:50%;" />

<h2 id="依赖关系安装"><a href="#依赖关系安装" class="headerlink" title="依赖关系安装"></a>依赖关系安装</h2><p>CodeFormer项目是以Python为编码的基础的开源项目，如果电脑没有安装Conda，那么先下载安装<a href="https://www.anaconda.com/products/distribution">官网链接</a>，anaconda环境可以帮助用户管理不同版本的Python和其他第三方库，以及提供一个独立的工作空间，以便在不影响其他环境的情况下进行开发与测试。</p>
<p>需要如下依赖关系：</p>
<ul>
<li>Pytorch &gt;&#x3D; 1.7.1</li>
<li>CUDA &gt;&#x3D; 10.1</li>
<li>Other required packages in <code>requirements.txt</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取项目源码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/sczhou/CodeFormer</span><br><span class="line"><span class="built_in">cd</span> CodeFormer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建独立的工作空间</span></span><br><span class="line">conda create -n condeformer python=3.8 -y</span><br><span class="line">conda activate codeformer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装python依赖</span></span><br><span class="line">pip3 install -r requirements.txt</span><br><span class="line">python basicsr/setup.py develop</span><br><span class="line">conda install -c conda-forge dlib （面部识别需要依赖）</span><br></pre></td></tr></table></figure>



<h2 id="下载与安装训练模型"><a href="#下载与安装训练模型" class="headerlink" title="下载与安装训练模型"></a>下载与安装训练模型</h2><ol>
<li><p>从<a href="https://drive.google.com/drive/folders/1b_3qwrzY_kTQh0-SnBoGBgOrJ_PLZSKm?usp=sharing">Google Drive</a>或<a href="https://entuedu-my.sharepoint.com/:f:/g/personal/s200094_e_ntu_edu_sg/EvDxR7FcAbZMp_MA9ouq7aQB8XTppMb3-T0uGZ_2anI2mg?e=DXsJFo">OneDrive</a>下载facelib和dlib训练模型到<code>weight/facelib</code>文件夹。运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python scripts/download_pretrained_models.py facelib</span><br><span class="line">python scripts/download_pretrained_models.py dlib (面部识别需要dlib依赖)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从<a href="https://drive.google.com/drive/folders/1CNNByjHDFt0b95q54yMVp6Ifo5iuU6QS?usp=sharing">Google Drive</a>或<a href="https://drive.google.com/drive/folders/1CNNByjHDFt0b95q54yMVp6Ifo5iuU6QS?usp=sharing">OneDrive</a>下载codeFormer预训练模型到<code>weights/CodeFormer</code>文件夹。运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python scripts/download_pretrained_models.py CodeFormer</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="使用训练模型"><a href="#使用训练模型" class="headerlink" title="使用训练模型"></a>使用训练模型</h2><h3 id="准备测试数据"><a href="#准备测试数据" class="headerlink" title="准备测试数据"></a>准备测试数据</h3><p>您可以将测试图像放在<code> input/TestWhole</code> 文件夹中。如果您想测试剪裁和对齐的面孔，您可以将它们放在 <code>input/cropping _ faces</code> 文件夹中。</p>
<p><code>--has_aligned</code>参数用于面部修复，如果用于整个图像那么会损害边界上的头发纹理或面部变形</p>
<h3 id="面部修复（裁剪和对齐面部）"><a href="#面部修复（裁剪和对齐面部）" class="headerlink" title="面部修复（裁剪和对齐面部）"></a>面部修复（裁剪和对齐面部）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 裁剪和对齐的脸</span></span><br><span class="line">python inference_codeformer.py -w 0.5 --has_aligned --input_path [input folder]</span><br></pre></td></tr></table></figure>

<h3 id="全图像增强"><a href="#全图像增强" class="headerlink" title="全图像增强"></a>全图像增强</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加&#x27;--bg_upsampler realesrgan&#x27;参数，用于使用Real-ESRGAN增强背景区域</span></span><br><span class="line"><span class="comment"># 增加&#x27;--face_upsample&#x27;参数，用于进一步修复面部</span></span><br><span class="line">python inference_codeformer.py -w 0.7 --input_path [image folder]|[image path]</span><br></pre></td></tr></table></figure>

<h3 id="视频增强"><a href="#视频增强" class="headerlink" title="视频增强"></a>视频增强</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要先安装ffmpeg</span></span><br><span class="line">conda install -c conda-forge ffmpeg</span><br><span class="line"><span class="comment"># 视频文件需以&#x27;.mp4&#x27;、&#x27;.mov&#x27;或&#x27;.avi&#x27;结尾</span></span><br><span class="line">python inference_codeformer.py --bg_upsampler realesrgan --face_upsample -w 1.0 --input_path [video path]</span><br></pre></td></tr></table></figure>

<p>保真度权重 w 在[0,1]中。一般来说，较小的 w 倾向于产生较高质量的结果，而较大的 w 产生较高保真度的结果。</p>
<p>结果将保存在<code>results</code>文件夹中。</p>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>AppleHDA声卡修补</title>
    <url>/2018/12/05/AppleHDA%E5%A3%B0%E5%8D%A1%E4%BF%AE%E8%A1%A5/</url>
    <content><![CDATA[<h1 id="1-计算编解码器命令和路径"><a href="#1-计算编解码器命令和路径" class="headerlink" title="1 计算编解码器命令和路径"></a>1 计算编解码器命令和路径</h1><h2 id="1-1-获取解码器"><a href="#1-1-获取解码器" class="headerlink" title="1.1 获取解码器"></a>1.1 获取解码器</h2><p>首先，我们需要从linux获取音频编码器的转储。因此，进入USB&#x2F;CD（或）完全安装的任何Linux发行版。并在终端中输入以下命令以在桌面上以文本格式获取转储。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/asound/card0/codec<span class="comment">#0 &gt; ~/Desktop/codec_dump.txt</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">cat</span> /proc/asound/card0/codec<span class="comment">#1 &gt; ~/Desktop/codec_dump.txt</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">cat</span> /proc/asound/card0/codec<span class="comment">#2 &gt; ~/Desktop/codec_dump.txt </span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="1-2-分析编解码器转储并提取相关信息"><a href="#1-2-分析编解码器转储并提取相关信息" class="headerlink" title="1.2 分析编解码器转储并提取相关信息"></a>1.2 分析编解码器转储并提取相关信息</h2><p>我们需要从编码器转储以下细节：</p>
<ol>
<li>Codec</li>
<li>Address</li>
<li>Vendor ID（Convert this hex value into decimal value）</li>
<li>Pin Complex Nodes with Control Name</li>
<li>Audio Mixer&#x2F;Selector Nodes</li>
<li>Audio Output Nodes</li>
<li>Audio Input Nodes</li>
</ol>
<h1 id="2-修补XML（平台和布局）文件"><a href="#2-修补XML（平台和布局）文件" class="headerlink" title="2 修补XML（平台和布局）文件"></a>2 修补XML（平台和布局）文件</h1><h2 id="2-1-从Pin复杂节点中提取值’Pin-Default’、’EAPD’、’Node-ID’"><a href="#2-1-从Pin复杂节点中提取值’Pin-Default’、’EAPD’、’Node-ID’" class="headerlink" title="2.1 从Pin复杂节点中提取值’Pin Default’、’EAPD’、’Node ID’"></a>2.1 从Pin复杂节点中提取值’Pin Default’、’EAPD’、’Node ID’</h2><p>我们已经从第1部分的编解码器转储中分析并获得了相关的详细信息。现在，我们尝试从上面提取的控制名称的Pin Complex节点获取Pin Default、EAPD和Node ID的值<br>举例：ACL269<br>Pin Complex Nodes with Control Name</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Node 14 : Pin Default 0x99130110, EAPD: 0x02</span><br><span class="line">Node 18 : Pin Default 0x04a11820</span><br><span class="line">Node 19 : Pin Default 0x99a3092f</span><br><span class="line">Node 21 : Pin Default 0x0421101f</span><br></pre></td></tr></table></figure>

<h2 id="2-2-PIN默认值必须从右向左读取。我们将从其中取两个数字，然后从左到右写下来，如下面解释的ALC269"><a href="#2-2-PIN默认值必须从右向左读取。我们将从其中取两个数字，然后从左到右写下来，如下面解释的ALC269" class="headerlink" title="2.2 PIN默认值必须从右向左读取。我们将从其中取两个数字，然后从左到右写下来，如下面解释的ALC269"></a>2.2 PIN默认值必须从右向左读取。我们将从其中取两个数字，然后从左到右写下来，如下面解释的ALC269</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Node 14:</span><br><span class="line">Pin Default value: 0x99130110</span><br><span class="line">Extracted verb data: <span class="string">&quot;10 01 13 99&quot;</span></span><br><span class="line"></span><br><span class="line">Node 18:</span><br><span class="line">Pin Default value: 0x04a11820</span><br><span class="line">Extracted verb data: <span class="string">&quot;20 18 a1 04&quot;</span></span><br><span class="line"></span><br><span class="line">Node 19:</span><br><span class="line">Pin Default value: 0x99a3092f</span><br><span class="line">Extracted verb data: <span class="string">&quot;2f 09 a3 99&quot;</span></span><br><span class="line"></span><br><span class="line">Node 21:</span><br><span class="line">Pin Default value: 0x0421101f</span><br><span class="line">Extracted verb data: <span class="string">&quot;1f 10 21 04&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们需要根据第二篇文章中解释的动词信息来纠正上面的verb数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">at Node 14: 10 01 13 99 [ Correction 99-&gt;90(Note 1)]</span><br><span class="line">at Node 18: 20 18 a1 04 [ Correction 18-&gt;10(Note 2)]</span><br><span class="line">at Node 19: 2f 09 a3 99 [ Correction 2f-&gt;20(Note 3) 09-&gt;01(Note 2) 99-&gt;90(Note 1)]</span><br><span class="line">at Node 21: 1f 10 21 04 [ Correction 1f-&gt;10(Note 3)]</span><br><span class="line">at Node 14 EAPD : 02 (Note 5) </span><br><span class="line"></span><br><span class="line">Corrected Verb Data:</span><br><span class="line">Code:</span><br><span class="line">at Node 14: 10 01 13 90</span><br><span class="line">at Node 18: 20 10 a1 04</span><br><span class="line">at Node 19: 20 01 a3 90</span><br><span class="line">at Node 21: 10 10 21 04</span><br><span class="line">at Node 14 EAPD : 02</span><br></pre></td></tr></table></figure>

<p>默认关联修正后的Verb数据：注释4</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">at Node 14: 10 01 13 90</span><br><span class="line">at Node 18: 20 10 a1 04</span><br><span class="line">at Node 19: 30 01 a3 90</span><br><span class="line">at Node 21: 40 10 21 04</span><br><span class="line">at Node 14 EAPD : 02</span><br></pre></td></tr></table></figure>

<p>MIC修正后的最终Verb数据：注释6和注释7</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Node 14: 10 01 13 90</span><br><span class="line">Node 18: 20 10 81 04</span><br><span class="line">Node 19: 30 01 a0 90</span><br><span class="line">Node 21: 40 10 21 04</span><br><span class="line">Node 14 EAPD : 02</span><br></pre></td></tr></table></figure>

<h1 id="3-AppleHDA编译补丁"><a href="#3-AppleHDA编译补丁" class="headerlink" title="3 AppleHDA编译补丁"></a>3 AppleHDA编译补丁</h1><h1 id="4-HDMI-Audio-补丁（）"><a href="#4-HDMI-Audio-补丁（）" class="headerlink" title="4 HDMI Audio 补丁（）"></a>4 HDMI Audio 补丁（）</h1>]]></content>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3样式表手册</title>
    <url>/2021/12/13/CSS3/</url>
    <content><![CDATA[<h1 id="CSS样式单的功能及历史背景"><a href="#CSS样式单的功能及历史背景" class="headerlink" title="CSS样式单的功能及历史背景"></a>CSS样式单的功能及历史背景</h1><p>HTML5规范推荐把页面外观交给CSS去控制，而HTML标签则负责标签、语议部分。HTML5删除了传统的专门控制页面外观的标签，而把页面外观的控制交给了CSS负责。</p>
<span id="more"></span>

<h2 id="CSS的主要功能"><a href="#CSS的主要功能" class="headerlink" title="CSS的主要功能"></a>CSS的主要功能</h2><ul>
<li>对页面的字体、颜色控制更加细腻，让页面内容更富表现力，CSS的表现效果远远超出传统HTML页面的color、bgcolor等属性的表现力。</li>
<li>通过CSS控制整站风格，CSS样式单可以同时控制整个站点所有页面的风格，如果整个站点所有的页面效果都需要改变，则可以直接通过CSS样式单控制，避免逐个修改每个页面文件。</li>
</ul>
<h2 id="CSS的发展历史"><a href="#CSS的发展历史" class="headerlink" title="CSS的发展历史"></a>CSS的发展历史</h2><ul>
<li>CSS 1.0：1996年12月，CSS1.0作为第一个正式规范面世，其中已经加入了字体、颜色等相关属性。</li>
<li>CSS 2.0：1998年5月，CSS2.0规范正式推出。这个版本的CSS也是最广为人知的一个版本。</li>
<li>CSS 2.1：2004年2月，CSS2.1对原来的CSS2.0进行了一些小范围的修改，删除了一些浏览器不成熟的属性。CSS2.1可认为是CSS2.0的修订版。</li>
<li>CSS 3.0：2010年，CSS3规范推出，这个版本的CSS完善了前面CSS存在的一些不足，例如，颜色模块增加了色彩校正、透明度等功能；字体模块则增加了文字效果、服务器字体支持等；还增加了变形和动画模块等。</li>
</ul>
<h1 id="使用外部CSS样式单的两种方式"><a href="#使用外部CSS样式单的两种方式" class="headerlink" title="使用外部CSS样式单的两种方式"></a>使用外部CSS样式单的两种方式</h1><h2 id="引入外部样式文件"><a href="#引入外部样式文件" class="headerlink" title="引入外部样式文件"></a>引入外部样式文件</h2><p>HTML文档中使用<code>&lt;link.../&gt;</code>元素来引用外部样式文件，引入外部样式文件应在<code>&lt;head.../&gt;</code>元素中增加如下<code>&lt;link.../&gt;</code>子元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;CSS样式文件的URL&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="导入外部样式单"><a href="#导入外部样式单" class="headerlink" title="导入外部样式单"></a>导入外部样式单</h2><p>导入外部样式单的功能与链接外部样式单的功能差不多，只是语法上存在差别。导入外部样式单需要在<code>&lt;style.../&gt;</code>元素中使用@import来执行导入。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">	<span class="keyword">@import</span> <span class="string">&quot;outer.css&quot;</span>;</span></span><br><span class="line"><span class="language-css">	<span class="keyword">@import</span> url(<span class="string">&quot;mycss.css&quot;</span>);</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以前的很多浏览器不支持@import导入，因此一些CSS开发人员会把一些浏览器可能不支持的高级CSS属性放在外部样式单中导入，这样保证只有支持@import导入的浏览器才会导入这些高级CSS属性。但实际上，由于某些浏览器（例如：IE浏览器）会在导入外部样式单时导致“屏闪”，因此开发者谨慎使用。</p>
<h1 id="使用内部样式单的方式"><a href="#使用内部样式单的方式" class="headerlink" title="使用内部样式单的方式"></a>使用内部样式单的方式</h1><p>如果想让某些CSS样式仅对某个页面有效，而不会影响整个站点，则应该选择使用内部CSS样式定义。</p>
<p>内部CSS样式需要放在<code>&lt;style.../&gt;</code>元素中定义</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">	&lt;!-- 样式单文件定义--&gt;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">table</span> &#123;</span></span><br><span class="line"><span class="language-css">    backgroud-<span class="attribute">color</span>: <span class="number">#003366</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">td</span> &#123;</span></span><br><span class="line"><span class="language-css">    backgroud-<span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-family</span>: <span class="string">&quot;楷体_GB2312&quot;</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">20pt</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-shadow</span>: -<span class="number">8px</span> <span class="number">6px</span> <span class="number">2px</span> <span class="number">#333</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="使用内联样式单的方式"><a href="#使用内联样式单的方式" class="headerlink" title="使用内联样式单的方式"></a>使用内联样式单的方式</h1><p>内联CSS样式只对单个标签有效，它甚至不会影响整个文件。内联样式定义可以精确控制某个HTML元素的外观表现，并且允许通过JavaScript动态修改XHTML元素的CSS样式，从而改变该元素的外观。</p>
<p>为了使用内联样式，CSS扩展了HTML元素，几乎所有的HTML元素都增加了一个style通过卂性，该属性是一个或多个CSS样式定义，多个CSS样式定义之间以英文逗号隔开。简单地说，使用内联样式定义时，style属性值就是由一个或多个property:value组成的，此处的property:value与前面CSS样式单文件中的完全相同。</p>
<p>定义内联CSS样式的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">style=&quot;property1:value1;property2:value2...&quot;</span><br></pre></td></tr></table></figure>

<h1 id="CSS的元素选择器"><a href="#CSS的元素选择器" class="headerlink" title="CSS的元素选择器"></a>CSS的元素选择器</h1><p>正如前面看到的，除了内联样式之外，定义CSS样式的语法总遵守如下格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Selector &#123;</span><br><span class="line">    property1: values1;</span><br><span class="line">    property1: values2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的语法格式分为两个部分：</p>
<ul>
<li>Selector（选择器）：选择器决定该样式定义对哪些元素起作用。</li>
<li>{property1: value1; property2:value2}（属性定义）：属性定义部分决定这些样式起怎样的作用（字体、颜色、布局）等。</li>
</ul>
<p>因此不难看出掌握CSS需要两部分：选择器的定义方法与CSS属性的定义</p>
<h2 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h2><p>元素选择器是最简单的选择器，其语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E &#123; ... &#125;  /* 其中E代表有效的HTML元素名 */</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>元素选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="comment">/* 定义对div元素起作用的CSS样式 */</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: grey;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">font</span>: italic normal bold <span class="number">14pt</span> normal 楷体_GB2312;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="comment">/* 定义对P元素起作用的CSS样式 */</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#444</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">font</span>: normal small-caps bold <span class="number">20pt</span> normal 宋体;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>div内的文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>p内的文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="CSS3/6-3-1.png" style="zoom:50%;" />

<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>属性选择器一共有如下几种语法格式：</p>
<ul>
<li><code>E &#123;....&#125;</code> ：指定该CSS样式对所有E元素起作用。</li>
<li><code>E[attr] &#123; ... &#125;</code> ：指定该CSS样式对具有attr属性的E元素起作用</li>
<li><code>E[attr=value] &#123; ... &#125;</code> ：指定该CSS样式对所有包含attr属性，且attr属性为value的E元素起作用。</li>
<li><code>E[attr~=value]&#123; ... &#125;</code> ：指定该CSS样式对所有包含attr属性，且attr属性的值为以空格隔开的系列值，其中某个值为value的E元素起作用。</li>
<li><code>E[attr|=value]&#123; ... &#125;</code> ：指定该CSS样式对所有包含attr属性，且attr属性的值为以连字符分隔的系列值，其中第一个值为value的Tag元素起作用。</li>
<li><code>E[attr^=&quot;value&quot;]&#123; ... &#125;</code> ：指定该CSS样式对所有包含attr属性，且attr属性的值以value开头的字符串的E元素起作用。</li>
<li><code>E[attr$=&quot;value&quot;]&#123; ... &#125;</code> ：指定该CSS样式对所有包含attr属性，且attr属性的值以value结尾的字符串的E元素起作用。</li>
<li><code>E[attr*=&quot;value&quot;]&#123; ... &#125;</code> ：指定该CSS样式对所有包含attr属性，且attr属性的值包含value的字符串的E元素起作用。</li>
</ul>
<div class="note primary"><p>上面和个属性选择器并没有得到所有浏览器的广泛支持，只有第一种形式可以在所有浏览器中运行良好，最后3种CSS选择器是CSS 3.0新增的选择器。 </p>
</div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="comment">/*对所有div元素都起作用的CSS样式*/</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#eee</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="comment">/*对有id属性的div元素起作用的CSS样式*/</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span><span class="selector-attr">[id]</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#aaa</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="comment">/*对有id属性值包含xx的div元素起作用的CSS样式*/</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span><span class="selector-attr">[id*=xx]</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#999</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="comment">/*对有id属性值以xx开头的div元素起作用的CSS样式*/</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span><span class="selector-attr">[id^xx]</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#555</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span><span class="selector-attr">[id=xx]</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#111</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>没有任何属性的div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span>&gt;</span>带id属性的div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;zzxx&quot;</span>&gt;</span>id属性值包包含xx子字符串的div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;xxyy&quot;</span>&gt;</span>id属性值以xx开头的div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;xx&quot;</span>&gt;</span>id属性值为xx的div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/Users/tiki/Nextcloud/zhangzr/source/_posts/CSS3/6-3-2.png" alt="6-3-2" style="zoom:50%;" />

<h2 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h2><p>ID选择器指定CSS样式将会对具有指定id属性值的HTML元素起作用。ID选择器的语法格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#idvalue</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>上面语法指定该CSS样式对id为idValue的HTML元素起作用。</p>
<p>各种浏览器对ID选择器都有很好的支持。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>ID选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="comment">/* 对所有div元素都起作用的CSS样式 */</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">padding</span>: <span class="number">3px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="comment">/* 对id为xx的元素起作用的CSS样式 */</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-id">#xx</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">border</span>: <span class="number">2px</span> dotted black;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#888</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>没有任何属性的div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;xx&quot;</span>&gt;</span>id属性值为xx的div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/Users/tiki/Nextcloud/zhangzr/source/_posts/CSS3/6-3-3.png" alt="6-3-3" style="zoom:50%;" />

<p><strong>仅对指定元素起作用的ID选择器</strong></p>
<p>定义仅对指定元素起作用的ID选择器的语法格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">E<span class="selector-id">#idValue</span> &#123;...&#125; <span class="comment">/* 其中E是有效的HTML元素 */</span></span><br></pre></td></tr></table></figure>

<p>该语法指定该CSS样式对ID为idValue的E元素起作用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/*对id为xx的p元素起作用的CSS样式*/</span><br><span class="line">p#xx &#123;</span><br><span class="line">	border:2px dotted black;</span><br><span class="line">  backgroud-color: #888;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/Users/tiki/Nextcloud/zhangzr/source/_posts/CSS3/6-3-4.png" alt="6-3-4" style="zoom:50%;" />

<h2 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h2><p>class选择器指定CSS样式对具有指定class属性的元素起作用。class选择器的语法格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[E]</span><span class="selector-class">.classValue</span> &#123;...&#125; <span class="comment">/*其中E是有效的HTML元素*/</span></span><br></pre></td></tr></table></figure>

<p>指定该CSS定义对class属性值为classValue的E元素起作用。此处的E可以省略，如果省略E，则指定该CSS对所有的class属性为classValue的元素都起作用。</p>
<div class="note primary"><p>为了让HTML页面支持class选择器，W3C组织规定几乎所有的HTML元素都可指定class属性，该属性唯一的作用正是让class选择器起作用 </p>
</div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Class选择器测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="comment">/*对所有class为myclass的元素都起作用的CSS样式*/</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.myclass</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">240px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#dddddd</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="comment">/*对class为myclass的div元素起作用的CSS样式*/</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span><span class="selector-class">.myclass</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">border</span>: <span class="number">2px</span> dotted black;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#888888</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;myclass&quot;</span>&gt;</span>class属性为myclass的div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;myclass&quot;</span>&gt;</span>class属性为myclass的p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/Users/tiki/Nextcloud/zhangzr/source/_posts/CSS3/6-3-5.png" alt="6-3-5" style="zoom:50%;" />

<p>从上图所示，定义了两个CSS样式都可作用于&lt;div…&#x2F;&gt;元素，因此该&lt;div…&#x2F;&gt;元素的显示效果是两个CSS样式“迭加”的效果。从上图可示，既指定标签又指定class值的选择器的优先级更高。</p>
<h2 id="包含选择器"><a href="#包含选择器" class="headerlink" title="包含选择器"></a>包含选择器</h2><p>包含选择器用于指定目标选择器必须处于某个选择器对应的元素内部。其语法格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Selector1 Selector2 &#123;...&#125; <span class="comment">/*其中Selector1、Selector2都是有效的选择器 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>包含选择器测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="comment">/*对所有的div元素起作用的CSS样式*/</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="comment">/*对处于div之内且class属性为a的元素起作用的CSS样式*/</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span> <span class="selector-class">.a</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">250px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">35px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">border</span>: <span class="number">2px</span> dotted black;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#888</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>没有任何属性的div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>处理div之内且class属性为a的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/Users/tiki/Nextcloud/zhangzr/source/_posts/CSS3/6-3-6.png" alt="6-3-6" style="zoom:50%;" />

<h2 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h2><p>子选择器用于指定目标选择器必须是某个选择器对应的元素的子元素。子选择器的语法格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Selector1 &gt; Selector2 &#123;...&#125; <span class="comment">/*其中Selector1、Selector2都是有效的选择器*/</span></span><br></pre></td></tr></table></figure>

<p>包含选择器与子选择器有点相似，它们之间存在如下区别：</p>
<ul>
<li>对于包含选择器，只要目标选择器位于外部选择器对应的元素内部，即使是其“孙子元素”也可；</li>
<li>对于子选择器，要求目标选择器必须作为外部选择器对应的元素的直接子元素才行</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>子选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="comment">/*对所有的div元素起作用的CSS样式*/</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="comment">/*对处于div之内且class属性为a的元素起作用的CSS样式*/</span></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span>&gt;<span class="selector-class">.a</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">35px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">border</span>: <span class="number">2px</span> dotted black;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#888</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>没有任何属性的div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>class属性为a且是div的子节点的元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>class属性为a且处于div内部的元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/Users/tiki/Nextcloud/zhangzr/source/_posts/CSS3/6-3-7.png" alt="6-3-7" style="zoom:50%;" />

<h2 id="CSS3-0新增的兄弟选择器"><a href="#CSS3-0新增的兄弟选择器" class="headerlink" title="CSS3.0新增的兄弟选择器"></a>CSS3.0新增的兄弟选择器</h2><p>兄弟选择器是CSS3.0新增的一个选择器。兄弟选择器的语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Selector1 ~ Selector2 &#123;...&#125; <span class="comment">/*其中Selector1、Selector2都是有效的选择器*/</span></span><br></pre></td></tr></table></figure>

<p>兄弟选择器匹配与Selector1对应的元素后面、能匹配Selector2的兄弟节点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>兄弟选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-id">#android</span> ~ <span class="selector-class">.long</span>&#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#00FF00</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>疯狂Java讲义<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">“long”</span>&gt;</span>轻量级Java EE企业应用实战<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;android&quot;</span>&gt;</span>疯狂andoroid讲义<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;long&quot;</span>&gt;</span>经典Java EE企业应用实践<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;long&quot;</span>&gt;</span>JavaScript权威指南<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>页面id为android的元素后面，class属性为long的所有兄弟节点都增加了绿色背景。</p>
<img src="CSS3/6-3-8.png" alt="6-3-8" style="zoom:50%;" />

<h2 id="选择器组合"><a href="#选择器组合" class="headerlink" title="选择器组合"></a>选择器组合</h2><p>有些时候，我们需要让一份CSS样式对多个选择器起作用，那就可以利用选择器组合来实现。语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Selector1,Selector2,Selector3,... &#123;...&#125;  /*其中Selctor1、Selector2、Selector3都是有效的选择器*/</span><br></pre></td></tr></table></figure>

<p>对于组合选择器页言，{}中定义的CSS样式将会对前面列出的所有选择器匹配的元素起作用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>选择器组合<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">div</span>,<span class="selector-class">.a</span>,<span class="selector-id">#abc</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">35px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">border</span>: <span class="number">2px</span> dotted black;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: <span class="number">#888</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>没有任何属性的div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Class属性为a的元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;abc&quot;</span>&gt;</span>id为abc的元素<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="CSS3/6-3-9.png" alt="6-3-9" style="zoom:50%;" />

<h2 id="伪选择器"><a href="#伪选择器" class="headerlink" title="伪选择器"></a>伪选择器</h2><p>伪元素选择器并不是针对真正的元素使用的选择器，伪元素选择器只能针对CSS中的伪元素起作用。</p>
<p>CSS提供的伪元素选择器有如下几个</p>
<ul>
<li>:first-letter：该选择器对应的CSS样式对指定对象内的第一个字符起作用。</li>
<li>:first-line：该选择器对应的CSS样式对指定对象内的第一行内容起作用。</li>
<li>:before：该选择器与内容相关的属性结合使用，用于在指定对象内部的前端插入内容。</li>
<li>:after：该选择器与内容相关的属性结合使用，用于在指定对象内部的尾端添加内容。</li>
</ul>
<h3 id="first-letter-伪元素选择器"><a href="#first-letter-伪元素选择器" class="headerlink" title=":first-letter: 伪元素选择器"></a><code>:first-letter:</code> 伪元素选择器</h3><p><code>:first-letter</code>选择器仅对块元素起作用。如果想对内联元素使用该属性，必须先设定对象的height、width属性，或者设定position属性为absolute，或者设定display属性为block。通过该选择器配置font-size、float属性可制作道了下沉的效果。</p>
<p>使用伪元素选择器插入内容</p>
<p>配置counter-increment属性添加编号</p>
<p>插入自定义编号</p>
<p>插入多级编号</p>
<p>CSS3新增的结构性伪类选择器</p>
<p>CSS3新增的UI元素状态伪类选择器</p>
<p>CSS3新增的:not和:target伪类选择器</p>
<p>在脚本中修改CSS样式</p>
]]></content>
      <categories>
        <category>文档手册</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>DD-WRT安装与配置</title>
    <url>/2018/09/04/DD-WRT/</url>
    <content><![CDATA[<h1 id="DD-WRT配置"><a href="#DD-WRT配置" class="headerlink" title="DD-WRT配置"></a>DD-WRT配置</h1><span id="more"></span>

<h2 id="nvram命令"><a href="#nvram命令" class="headerlink" title="nvram命令"></a>nvram命令</h2><p>nvram具有多层含义。首先它是非可变性RAM（non-volatile RAM）的缩写，这种RAM是一种持久性内存，可在断电时保留数据。路由器内的闪存就是一种nvram。nvram命令用于管理硬件设置，这些设置保存在闪存的最后一块内。这个内存段通常称为“nvram”。nvram命令有不同版本，比如IBM、Cisco、Oracle和Apple版。DD-WRT内的nvram命令非常简单，因为它只是显示和更改分配给变量的颠倒以及删除变量。无选项情况下运行它可以看到选项和参数：</p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">root@linksys:~# nvram</span><br><span class="line">usage: nvram [get name] [set name=value] [unset name] [show]</span><br></pre></td></tr></table></figure>
<p>nvram show显示了路由器上的所有设置，而且设置还不少。可以使用less将其分隔为一次一页：</p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">root@linksys:~# nvram show | less</span><br></pre></td></tr></table></figure>
<p>或是用grep查找特定的变量，比如：</p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">root@linksys:~# nvram show | grep ssh</span><br></pre></td></tr></table></figure>
<p>例如：如果你无意间禁用了WEB界面，但仍有telnet或SSH，可以以这种方式重新启用它：</p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">root@linksys:~# nvram set hhtp_enable=1</span><br><span class="line">root@linksys:~# nvram commit</span><br><span class="line">root@linksys:~# reboot </span><br></pre></td></tr></table></figure>
<p>如果想清除任何值的变量可参考如下所示：</p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">root@linksys:~# nvram set http_enable=&quot;&quot;</span><br><span class="line">root@linksys:~# nvram commit</span><br></pre></td></tr></table></figure>
<h2 id="JFFS-Journalling-Flash-File-System"><a href="#JFFS-Journalling-Flash-File-System" class="headerlink" title="JFFS(Journalling Flash File System)"></a>JFFS(Journalling Flash File System)</h2><p>通常，DD-WRT映像会占据约26MB分区，即便闪存是128MB或更多，也是如此。可以在未使用的空间创建另一个分区并用其来存储文件。这应该主要是读存储（read-storage）,比如无线热点splash和配置页、WEB页、额外的配置文件以及面向ipkg（针对嵌入式设备的ItsyPackage Management System）的存储空间。不要将它用于像日志文件这样能生成大量写操作的文件，因为闪存只支持数量有限的写操作并最终会出现故障。现代的闪存相当耐用，但它仍具有有限的写操作生命期限。用这个很好的旧df命令可以看到现有的文件系统：<br><img src="/dd-wrt_1.png" alt="Alt text" title="Optional title"></p>
<p>我的路由器具有128MB闪存，那么剩下的那些去哪了呢？它闲置在哪，等着被派上用场。访问Administrator–&gt;Management并检查JFFS2–&gt;Enable和Clean JFFS2–&gt;Enable。单击Apple Setting，继而Reboot Router。当它重启时，应该会看到类似下面的结果：<br><img src="/dd-wrt_2.png" alt="Alt text" title="Optional title"></p>
<p>JFFS2（Journalling Flash File System 版本2）是针对闪存存储媒介设计的。我们先来看看这种闪存属于哪种媒介。它是一种特殊的设备，称为Memory Technology Device，缩写为MTD。它不是一种像硬盘和USB棒那样的块设备，也不是像键盘鼠标那样的字符设备。块设备通常以大小固定（512和1024字节）的分区组织而成。而MTD则具有大小为128KB和更大的擦写块（eraseblock）。块设备可以做两件事：读区和写区。MTD可以做三件事：从擦写块读、写到擦写块和擦除擦写块。</p>
<p>紧凑式闪存、SD 卡、USB 棒究其本质都是 MTD。但它们对于操作系统而言更像是块设备，因为它们具有 Flash Translation Layers (FTL)，用于在闪存硬件之上模拟块设备。这种 FTL 可以位于主计算机上，也可以位于此设备内的硬件控制器的固件上。如果您愿意牺牲一个 USB 棒（为知识的进步所做的一次伟大的牺牲）并撬开它，那么您很有可能会看到一些 NAND 芯片（原始的闪存芯片）和一个微控制器。</p>
<p>了解有关闪存的几件事情将有助于您的 DD-WRT 探险之旅。第一，NAND 擦写块显示的是全或无（整个块必须在新的数据写上之前先被擦除）。第二，Linux 具有一个 MTD 子系统，和一个用来执行基本任务（比如擦除或向设备写映像）的 mtd 命令。可以在 DD-WRT 上运行无选项的 mtd 命令来查看语法和选项。在 DD-WRT 维基上还可以看到一些关于如何使用 mtd 命令的 how-to 文章，现在您该知道它是怎么回事了吧。第三，nvram 位于最后一个擦写块上，而无论擦写块有多大，它都被以编程的方式限制为 32KB。</p>
<h3 id="使用WEB-GUI界面启用JFFS"><a href="#使用WEB-GUI界面启用JFFS" class="headerlink" title="使用WEB GUI界面启用JFFS"></a>使用WEB GUI界面启用JFFS</h3><p>通过路由器网页启用JFFS的步骤非常具体。为了避免重置和重新编程路由器，设置备份是明智之举。通过以下步骤在DD-WRT中启用JFFS</p>
<ol>
<li>路由器的主页中点击“管理”</li>
<li>向下滚动，直到看到JFFS2支持部分</li>
<li>点击“启动JFFS“</li>
<li>点击“保存”</li>
<li>等待几秒钟，然后单击“应用”</li>
<li>再等一下，返回到启用JFFS部分，并启用“Clean JFFS”</li>
<li>不要点击“保存”。单击“应用”，这时路由器将如上面介绍的对空间进行格式化</li>
<li>等到网络的GUI界面回来，然后禁用“clean JFFS”，单击“保存”</li>
<li>重新启动一下路由器</li>
</ol>
<h3 id="命令行方式启动JFFS：CLI"><a href="#命令行方式启动JFFS：CLI" class="headerlink" title="命令行方式启动JFFS：CLI"></a>命令行方式启动JFFS：CLI</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvram set jffs_mounted=1</span><br><span class="line">nvram set enable_jffs2=1</span><br><span class="line">nvram set sys_enable_jff2=1</span><br><span class="line">nvram set clean_jffs=1</span><br><span class="line">nvram set sys_clean_jffs2=1</span><br><span class="line">nvram commit</span><br><span class="line">reboot</span><br><span class="line"># 删除变量请使用如下命令</span><br><span class="line"># nvram unset &lt;variable&gt;</span><br></pre></td></tr></table></figure>

<h3 id="增加JFFS空间的方法"><a href="#增加JFFS空间的方法" class="headerlink" title="增加JFFS空间的方法"></a>增加JFFS空间的方法</h3><h4 id="增加1G闪存卡"><a href="#增加1G闪存卡" class="headerlink" title="增加1G闪存卡"></a>增加1G闪存卡</h4><p>加入到SD&#x2F;MMC模式</p>
<ul>
<li>DD-WRT V2.4或更高版本才支持1G闪存</li>
<li>创建文件夹<code>mkdir /mmc/jffs</code></li>
<li>绑定设备到上面文件夹<code>mount --bind /mmc/jffs /jffs</code></li>
<li>进入GUI界面“管理–&gt;JFFS2启用” 或者使用CLI命令行<code>nvram set sys_enable_jffs2=1</code></li>
<li>创建文件夹得以使用ipkg<code>mkdir /jffs/tmp &amp;&amp; mkdir /jffs/tmp/ipkg</code></li>
</ul>
<h4 id="添加USB存储设备"><a href="#添加USB存储设备" class="headerlink" title="添加USB存储设备"></a>添加USB存储设备</h4><ul>
<li>首先，要启用USB设备的支持，安装USB驱动，并启动jffs<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">mount /dev/scsi/hosts0/bus0/target0/lun0/part1 /mnt</span><br><span class="line">mkdir /mnt/jhffs</span><br><span class="line">mount /mnt/jffs /jffs</span><br></pre></td></tr></table></figure></li>
<li>进入GUI界面“管理–&gt;JFFS2启用” 或者使用CLI命令行<code>nvram set sys_enable_jffs2=1</code></li>
<li>创建文件夹得以使用ipkg<code>mkdir /jffs/tmp &amp;&amp; mkdir /jffs/tmp/ipkg</code></li>
</ul>
<h4 id="测试ipkg"><a href="#测试ipkg" class="headerlink" title="测试ipkg"></a>测试ipkg</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /jffs</span><br><span class="line">mkdir -p /jffs/tmp/ipkg</span><br><span class="line">ipkg update</span><br><span class="line">ipkg list</span><br></pre></td></tr></table></figure>

<div class="note danger"><p>建议运行上述命令后重启路由器</p>
</div>


<h2 id="Entware安装与配置"><a href="#Entware安装与配置" class="headerlink" title="Entware安装与配置"></a>Entware安装与配置</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Entware是什么？它是嵌入式设备的软件存储库，如路由器或网络附加存储，库中大约有2000个以上的可用程序包。它本身是Optware的替代品。在五年的发展中Entware成了主流，在X86、X64、MIPS、MIPSEL、ARMV5和ARMV7平台有有着很好的应用，并且目前有专门的团队进行维护。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>登录到路由器的GUI界面，服务–&gt;USB，确保核心USB支持、USB存储和自动驱动器安装都已经启用。如果一个或多个没有启用，那么请启用它并单击“应用”使之生效。</li>
<li>重新分区格式化USB相关设备，确保USB设备的分区格式为Ext2或者是Ext3或NTFS。如果它是硬盘驱动器，分区时要设置为主分区，不要设置逻辑分区。如果你希望EntWare自动安装到相关分区，那么请在此分区设置标签，标签值为“Optware”<br><img src="/USB_support.jpg" alt="图片(DD-WRT USB设置)" title="USB设置"></li>
</ol>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>在路由器中插入USB设备，可能需要重新启动路由器。检查服务-USB，看看它是否出现，记下当前的挂载点<code>/tmp/mnt/sda_part1</code>，如果正确这里应为<code>/tmp/mnt/opt</code></li>
<li>打开SSH终端到路由器。使用上面的挂载点链入以下命令<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget &#123;link to std install script for your router&#125; (click enter)</span><br><span class="line">sh generic.sh (click enter)</span><br><span class="line"># 我的路由器是EA6500，Broadcom单核，因此我使用如下地址：</span><br><span class="line">cd /opt</span><br><span class="line">wget http://bin.entware.net/mipselsf-k3.4/installer/generic.sh (click enter)</span><br><span class="line">sh generic.sh </span><br></pre></td></tr></table></figure></li>
<li>安装完成，运行更新<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">opkg update (click enter)</span><br><span class="line">opkg upgrade (click enter)</span><br></pre></td></tr></table></figure></li>
<li>最后一步是将以下命令添加到启动脚本（管理–&gt;命令）。睡眠值可以调整，但对于大多数USB硬件&#x2F;路由器来说，10是足够长的。<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">sleep 10</span><br><span class="line">/opt/etc/init.d/rc.unslung start</span><br></pre></td></tr></table></figure>
<div class="note danger"><p>注意：</p>
<ul>
<li>不要向PATH或LD_LIBRARY_PATH变量添加任何内容，它们已经包括了必要的文件夹的位置；</li>
<li>安装完毕可以通过连接<code>http://bin.entware.net/mipselsf-k3.4/Packages.html</code>，查看全部包信息</li>
<li>你可以使用<code>opkg list</code>查看包列表</li>
</ul>
</div></li>
</ol>
<h3 id="DD-WRT固件升及对于Entware的影响"><a href="#DD-WRT固件升及对于Entware的影响" class="headerlink" title="DD-WRT固件升及对于Entware的影响"></a>DD-WRT固件升及对于Entware的影响</h3><p>在升级DD-WRT固件以前，最好删除Entware驱动或者禁用USB的支持。升级DD-WRT不会给Entware安装带来任何问题，只要开发人员不要更改上面提到的PATH或LD_LIBRARY_PATH变量。升级后只需再次启用USB支持即可。然后打开SSH终端并发出以下命令：</p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg upgrade</span><br></pre></td></tr></table></figure>

<h3 id="EntWare-WiKi"><a href="#EntWare-WiKi" class="headerlink" title="EntWare WiKi"></a>EntWare WiKi</h3><p><a href="https://github.com/Entware/Entware/wiki">Entware Wiki : https://github.com/Entware/Entware/wiki</a></p>
<h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><p>在DD-WRT中有三种方法让它们自动运行。</p>
<h3 id="在路由器上加载脚本的WEB界面方法"><a href="#在路由器上加载脚本的WEB界面方法" class="headerlink" title="在路由器上加载脚本的WEB界面方法"></a>在路由器上加载脚本的WEB界面方法</h3><p><br><span style="font-weight: bolder; font-size: 20px">1. 先决条件</span></p>
<ul>
<li>可以访问Web界面</li>
<li>知道启动时运行的命令</li>
<li>在命令行中测试命令以确保正确的操作</li>
</ul>
<p><br><span style="font-weight: bolder; font-size: 20px">2. 操作指南</span></p>
<ul>
<li>使用Web界面，转到管理选项卡</li>
<li>转到命令子选项卡</li>
<li>在命令对话框中键入希望运行每次启动命令（使用enter键将每个命令放在换行符上，如果该命令不是暂时停止运行的命令，则在命令后面加上“&amp;”）</li>
<li>如果希望将命令保存到rc_startup变量，请单击页面底部的“存储启动命令”按钮。保存防火墙将命令保存到RCI防火墙变量中。</li>
</ul>
<p><br><span style="font-weight: bolder; font-size: 20px">3. 工作原理</span><br>这样做是将您的命令串保存到闪存中的RCL启动变量（也称为NVRAM变量）。由于闪存在启动时不会被擦除，所以你的“startup script”将在每次启动时一直存在，并且总是执行。在命令框中单击“运行命令”按钮。</p>
<p><br><span style="font-weight: bolder; font-size: 20px">4. 定制脚本</span></p>
<ul>
<li>如果你的中由器一个保存自定义脚本按钮，你可以将命令保存在<code>/tmp/custom.sh</code></li>
<li>你可以通过在命令框中键入<code>sh /tmp/custom.sh</code>。追在一个“&amp;”符命令会把它放在后台：<code>sh /tmp/custom.sh &amp;</code></li>
</ul>
<h3 id="NVRAM方法"><a href="#NVRAM方法" class="headerlink" title="NVRAM方法"></a>NVRAM方法</h3><p><br><span style="font-weight: bolder; font-size: 20px">1. 先决条件</span></p>
<ul>
<li>用于登陆路由器工具telnet或SSH</li>
<li>了解每一次启动你想要运行的命令</li>
<li>测试运行命令（可选）</li>
</ul>
<p><br><span style="font-weight: bolder; font-size: 20px">2. 操作指南</span></p>
<ol>
<li>使用Telnet&#x2F;SSH登陆路由器</li>
<li>叵要设置启动脚本，请使用以下内容：<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">nvram set rc_startup=&quot;</span><br><span class="line">&lt;command 1&gt;</span><br><span class="line">&lt;command 2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;command n&gt;</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>
提交NVRAM命令后，RCL启动变量保存在闪存中，在重新启动时将保留。<br><code>nvram commit</code></li>
</ol>
<p><br><span style="font-weight: bolder; font-size: 20px">3. 工作原理</span><br>当你发出第一个命令时，你注意到提示符更改为“&gt;”，从这里起，您键入的每一行都被添加到rc_startup变量中。从技术上讲，你仍然在同一个命令行上键入，即使你正在使用多行。当你键入最后一个双引号并点击回车键后，你将看到提示符更改返回，并且已经执行了第一个命令。也就是说，脚本已经添加到变量RCL启动中。<br>此时，你可以通过发出命令检查RCL启动的内容：<br><code>～# nvram get rc_startup</code></p>
<p><br><span style="font-weight: bolder; font-size: 20px">4. 自动化的WEB界面</span><br>为了自动化或测试Web界面，可以使用免费的<code>IMACROS Firefox</code>插件。您可以在Web界面中记录和重放你的活动，你可以下载它：<br><a href="https://addons.mozilla.org/firefox/3863/">https://addons.mozilla.org/firefox/3863/</a></p>
<h3 id="Shell脚本方法"><a href="#Shell脚本方法" class="headerlink" title="Shell脚本方法"></a>Shell脚本方法</h3><p>简单的nvram脚本适合于短脚本，但是如果你想体大量的工作，或者如果你想轻松地管理启动程序，最好的方法就是使用shell脚本。</p>
<p>Shell脚本使编写长脚本变得更加容易，长脚本又可以从互联网上获取可执行文件或脚本，或安装<code>ipkg -d </code>内存安装，从闪存分区复制预制的配置文件等，然后才能最终运行程序，并在每次启动时都这样做。</p>
<p>这意味着你不必在路由器闪存空间（nvram，这是相当有限的）中保存那么多的东西，但是您可以替代地填充更流得的RAM，而不必在每次重新启动时手动重新安装和配置程序。</p>
<p>而且，由于每个程序都有自己的脚本，因此在下一次引导中删除程序就如同删除、移动或重命名启动脚本文件一样简单。</p>
<p><br><span style="font-weight: bolder; font-size: 20px">1. 先决条件</span></p>
<ul>
<li>使用telnet或ssh登陆路由器</li>
<li>了解你在启动时运行的命令</li>
<li>使用SCP、WinSCP或其他方法将文件复制到路由器上。</li>
<li>启用JFFS并正常工作。</li>
<li>编辑脚本</li>
<li>测试你的命令以确呆正确操作</li>
</ul>
<p><br><span style="font-weight: bolder; font-size: 20px">2. 编写Shell脚本</span><br>编写每个程序的shell脚本。脚本以后缀名“*.startup”的文件<br>shell脚本应该看起来像这样：</p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">&lt;command 1&gt;</span><br><span class="line">&lt;command 2&gt;</span><br><span class="line">&lt;command 3&gt;</span><br><span class="line">...</span><br><span class="line">killall &lt;command n program name&gt;</span><br><span class="line">&lt;command n&gt;</span><br></pre></td></tr></table></figure>
<p>由于DD-WRT系统的设计，你的shell脚本可能最终会定期运行，而不仅权是在引导时运行，这意味着，你需要确保每次只运行1次程序<command n>。</p>
<p>killall命令确保<command n>不同时运行不止一次。这假设在执行之后立即退出<command n>之前出现在脚本中的所有命令（例如cp、wget或iptables）</p>
<p>例如下面脚本举例：<code>kismet_server.startup</code></p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Make the /tmp/usr/bin folder and move there</span><br><span class="line">mkdir /tmp/usr</span><br><span class="line">mkdir /tmp/usr/bin</span><br><span class="line">cd /tmp/usr/bin</span><br><span class="line"></span><br><span class="line">#copy the executable file from my home web server</span><br><span class="line">wget http://192.168.1.2/kismet_server</span><br><span class="line"></span><br><span class="line">#kill and previously-running instances of kismet_server</span><br><span class="line">killall -q kismet_server</span><br><span class="line"></span><br><span class="line">#execute kismet_server using /jffs/etc/kismet.conf as the configuration file.</span><br><span class="line">/tmp/usr/bin/kismet_server -n -f /jffs/etc/kismet.conf </span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder; font-size: 20px">3. 保存脚本</span><br>在<code>/jffs/etc/config</code>目录中保存脚本。如果没有你可以创建此目录。<br><br><span style="font-weight: bolder; font-size: 20px">4. 使脚本可执行</span><br><code>~ # chmod 700 /jffs/etc/config/&lt;scriptname&gt;.startup</code></p>
<h3 id="配置脚本的不同目录"><a href="#配置脚本的不同目录" class="headerlink" title="配置脚本的不同目录"></a>配置脚本的不同目录</h3><ul>
<li><code>/etc/config/</code></li>
<li><code>/jffs/etc/config/</code></li>
<li><code>/mmc/etc/config/</code></li>
<li><code>/tmp/etc/config/</code></li>
</ul>
<table>
<thead>
<tr>
<th>后缀名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>.startup</code></td>
<td>将在系统启动、正常启动时间和防火墙配置之前执行</td>
</tr>
<tr>
<td><code>.prewall</code></td>
<td>每当WAN接口up并在防火墙之前执行</td>
</tr>
<tr>
<td><code>.wanup</code></td>
<td>每当WAN接口up并在防火墙之后执行</td>
</tr>
<tr>
<td><code>.if</code></td>
<td>将在任何接口和防火墙之后执行（不再在源代码中，必须删除）</td>
</tr>
<tr>
<td><code>.ipup</code></td>
<td>当PPP连接在断开和防火墙之后重新建立时运行</td>
</tr>
<tr>
<td><code>.ipdown</code></td>
<td>当PPP连接被关闭时运行。（不再在源代码中，必须删除吗？）</td>
</tr>
<tr>
<td><code>.sesbutton</code></td>
<td>在按下“SES&#x2F;AOSS&#x2F;EZ-SETUP”按钮时执行</td>
</tr>
</tbody></table>
<p>注意：需要使用chmod命令更改脚本的执行权限。当脚本<code>.wanup</code>启动时，脚本可以运行多次。<br><a href="http://www.dd-wrt.com/phpBB2/viewtopic.php?p=433984">参见：http://www.dd-wrt.com/phpBB2/viewtopic.php?p=433984</a></p>
<p><span style="font-weight: bolder; font-size: 20px">使用不同扩展名或不同文件夹执行脚本</span><br>如果要执行具有不同扩展名的脚本或位于其他文件夹中的脚本，可以创建此脚本。</p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">for I in &#x27;/bin/ls /jffs/etc/config/*.myextension&#x27;;do</span><br><span class="line">    sh $I &amp;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="举例：samba启动脚本"><a href="#举例：samba启动脚本" class="headerlink" title="举例：samba启动脚本"></a>举例：samba启动脚本</h3><p>在文件夹<code>/jffs/etc/config</code>下，建立名为<code>samba.startup</code>脚本</p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">/usr/sbin/smbd -D --configfile=/tmp/smb.conf</span><br><span class="line">/usr/sbin/nmbd -D --configfile=/tmp/smb.conf</span><br></pre></td></tr></table></figure>
<p>没有放在&#x2F;etc&#x2F;config下原因这个目录是read-only的<br>没有放在&#x2F;tmp&#x2F;etc&#x2F;config&#x2F;的原因为这个目录是临时的，重启之后这个目录里的东西就没了。</p>
<h3 id="举例：nginx启动脚本"><a href="#举例：nginx启动脚本" class="headerlink" title="举例：nginx启动脚本"></a>举例：nginx启动脚本</h3><p>假设你安装一个 nginx , 它会在 init.d 目录创建一个名为 S80nginx 的服务脚本（数字可能不一样）。配置上述的脚本以后它会开机启动。但是，如果手动操作这个服务脚本呢？只需要：<br><code>/opt/etc/init.d/S80nginx start|restart|stop</code><br>执行它，给它相应参数即可。<br>但是，这样做未免太麻烦了。因为不仅仅是 init.d 目录不在 PATH 中，而是每个服务由于优先级的原因命名很麻烦。如果想手动 启动&#x2F;停止&#x2F;重启 某个服务还需要记住它的数字，打上大写的 S 也很麻烦。总之，这种手动直接运行服务文件的方式很麻烦。于是，我为了方便管理服务写了一个 lua 脚本，它基于这些服务文件，可以像其他发型版中的 service 一样根据正常服务名称管理服务：</p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">root@DD-WRT:~# ser privoxy restart</span><br><span class="line"> Shutting down privoxy...              done. </span><br><span class="line"> Starting privoxy...              done. </span><br><span class="line">root@DD-WRT:~# </span><br></pre></td></tr></table></figure>
<p>可以看到， ser 管理服务不需要绝对路径，不需要服务文件名，而是以服务应该有的名字（S + 数字之后的部分）。我们在 &#x2F;opt&#x2F;bin 目录创建文件 ser :</p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env lua</span><br><span class="line">function os.capture(cmd, raw)</span><br><span class="line">    local f = assert(io.popen(cmd, &#x27;r&#x27;))</span><br><span class="line">    local s = assert(f:read(&#x27;*a&#x27;))</span><br><span class="line">    f:close()</span><br><span class="line">    if raw then return s end</span><br><span class="line">    return string.sub(s, 0, string.len(s) - 1)</span><br><span class="line">end</span><br><span class="line">PATH = &#x27;/opt/etc/init.d/&#x27;</span><br><span class="line">function handler(s_name, operation)</span><br><span class="line">    local out = os.capture(&#x27;ls &#x27; .. PATH, false)</span><br><span class="line">    local flag = false</span><br><span class="line">    for s in string.gmatch(out, &#x27;%S+&#x27;) do</span><br><span class="line">        local prefix = string.match(s, &#x27;^S%d+&#x27;)</span><br><span class="line">        if prefix then</span><br><span class="line">            local service_name = string.sub(s, string.len(prefix) + 1)</span><br><span class="line">            if service_name == s_name then</span><br><span class="line">                print(os.capture(PATH .. s .. &#x27; &#x27; .. operation))</span><br><span class="line">                flag = true</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    if not flag then</span><br><span class="line">        print(&#x27;No service: &#x27; .. s_name)</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">handler(arg[1], arg[2])</span><br></pre></td></tr></table></figure>
<p>添加执行权限：<code>chmod +x /opt/bin/ser</code><br>后就可以使用它了。当然，由于它是一个 lua 脚本，你需要安装 lua :<code>opkg install lua</code><br>这样子管理服务就方便得多了</p>
<h2 id="Entware安装应用设置开机启用"><a href="#Entware安装应用设置开机启用" class="headerlink" title="Entware安装应用设置开机启用"></a>Entware安装应用设置开机启用</h2><p>通过Entware安装的软件在 &#x2F;opt&#x2F;etc&#x2F;init.d 下生成了服务脚本，它仍然在开关机时不会得到执行。<br>我们可以基于 DD 提供的 ‘Commands’ 功能做到这一点：<br><br/><span style="font-weight: bolder; font-size: 20px">1. 创建相关目录（启用 jffs 的目的是用来存放这些固定的永久储存的东西）：</span></p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">cd /jffs </span><br><span class="line">mkdir scripts </span><br><span class="line">cd scripts</span><br><span class="line">mkdir shutdown</span><br><span class="line">mkdir startup</span><br></pre></td></tr></table></figure>
<p><br/><span style="font-weight: bolder; font-size: 20px">2. 在 scripts 目录创建 operator.sh 脚本（控制 shutdown 目录或者startup 目录的脚本执行）：</span></p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env sh</span><br><span class="line">SCRIPTS_HOME=/jffs/scripts</span><br><span class="line">run_all()&#123;</span><br><span class="line">    for SCRIPT in &quot;$SCRIPTS_HOME&quot;/&quot;$1&quot;/*;</span><br><span class="line">        do</span><br><span class="line">                if [ -f &quot;$SCRIPT&quot; -a -x &quot;$SCRIPT&quot; ]</span><br><span class="line">                then</span><br><span class="line">                        $SCRIPT</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line">run_all &quot;$1&quot;</span><br></pre></td></tr></table></figure>
<p><br/><span style="font-weight: bolder; font-size: 20px">3. 在 startup 目录分别创建 S10service 和 S30swapon：</span></p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">RC=&#x27;/opt/etc/init.d/rc.unslung&#x27;</span><br><span class="line">i=30</span><br><span class="line">until [ -x &quot;$RC&quot; ] ; do</span><br><span class="line">  i=$(($i-1))</span><br><span class="line">  if [ &quot;$i&quot; -lt 1 ] ; then</span><br><span class="line">    logger &quot;Could not start Entware&quot;</span><br><span class="line">    exit</span><br><span class="line">  fi</span><br><span class="line">  sleep 1</span><br><span class="line">done</span><br><span class="line">$RC start</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Turn On Usage Of Swapfile</span><br><span class="line">if [ -f &quot;/opt/swapfile&quot; ];then</span><br><span class="line">    swapon /opt/swapfile</span><br><span class="line">    echo &quot;Turning Swapfile On&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>它们分别是启动 init.d 中的服务和启用 swap （交换空间）的脚本。<br><br/><span style="font-weight: bolder; font-size: 20px">4. 设置开&#x2F;关机执行脚本</span><br>路由器 WEB UI -&gt; Tag: Administration - Commands , 分别添加以下两个命令，先后保存为 Startup 和 Shutdown ：<br><code>/jffs/scripts/operator.sh startup</code><br><code>/jffs/scripts/operator.sh shutdown</code><br>其实就是开机执行 operator.sh 脚本添加 startup 参数 和 关机执行 operator.sh 添加 shutdown 参数。而 operator.sh的流程其实就是遍历参数目录（例如 startup 和 shutdown）中所有的脚本并且依次执行。如果你看明白了，就会知道只要将脚本放进 startup 目录它就会开机执行，只要放进 shutdown 它就会关机时执行。<br><br>有关脚本执行顺序需要特意说明一下，这是我的目录结构：</p>
<figure class="highlight plaintext"><figcaption><span>ash shell</span></figcaption><table><tr><td class="code"><pre><span class="line">root@DD-WRT:/jffs/scripts# tree -L 3</span><br><span class="line">.</span><br><span class="line">|-- operator.sh</span><br><span class="line">|-- shutdown</span><br><span class="line">|   |-- S10service</span><br><span class="line">|   `-- S30swapoff</span><br><span class="line">`-- startup</span><br><span class="line">    |-- S10service</span><br><span class="line">    `-- S30swapon</span><br></pre></td></tr></table></figure>
<p>可以注意到，开机执行的脚本都是以 S + 数字 +名称来命名的。这样做的目的是方便遍历时排序，数字低的会被先遍历并执行，也就是根据命名做到了启动优先级。至于前缀的大写字母 S 可以用其他字母替代，但是要统一。是否后缀 .sh 也无所谓。其实这里我就是模仿的 init.d 里边的服务命名方式，因为它们就是用这种方式决定启动优先级的。这样做了以后，就在路由器固件原生不内置相关功能的情况下做到了一样的效果。安装的所有服务可以正常开机启动，并且可以自己添加任意的脚本让它们自动执行。（例如从上面的文件中可以看出来，我还在关机时运行了两个脚本）</p>
<h2 id="DNSMasq配置本地网络"><a href="#DNSMasq配置本地网络" class="headerlink" title="DNSMasq配置本地网络"></a>DNSMasq配置本地网络</h2><p><img src="/dd-wrt_3.png" alt="DD-WRT配置界面" title="dd-wrt配置"></p>
<h3 id="1-启动dnsmasq"><a href="#1-启动dnsmasq" class="headerlink" title="1. 启动dnsmasq"></a>1. 启动dnsmasq</h3><p>服务–&gt;服务–&gt;DNSMasq 启动</p>
<h3 id="2-启动本地DNS"><a href="#2-启动本地DNS" class="headerlink" title="2. 启动本地DNS"></a>2. 启动本地DNS</h3><p>服务–&gt;服务–&gt;本地DNS 启动</p>
<h3 id="3-DNSMasq-附加选项："><a href="#3-DNSMasq-附加选项：" class="headerlink" title="3. DNSMasq 附加选项："></a>3. DNSMasq 附加选项：</h3><p>dnsmasq会自动读取<code>/tmp/hosts</code>文件，重启后<code>/tmp</code>中的内容将会重置。因此建议开启jffs，并指定hosts，在Additional DNSMasq Options中填写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addn-hosts=/jffs/dnsmasq.hosts</span><br></pre></td></tr></table></figure>
<p>也可以设置不读取resolv.conf文件，直接在dnsmasq中设置dns服务器，在Additional DNSMasq Options中填写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no-resolv</span><br><span class="line">server=8.8.8.8</span><br><span class="line">server=8.8.4.4</span><br></pre></td></tr></table></figure>
<p>还可以将某个域名提交给指定的dns服务器解析，在Additional DNSMasq Options中填写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server=/.google.com/208.67.222.222#443</span><br><span class="line">server=/.google.com.hk/208.67.222.222#443</span><br></pre></td></tr></table></figure>
<p>如果Additional DNSMasq Options里的内容太多，也可指定一个目录来读取这些配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conf-dir=/opt/etc/dnsmasq.d</span><br></pre></td></tr></table></figure>



<h1 id="dnsmasq详解及配置"><a href="#dnsmasq详解及配置" class="headerlink" title="dnsmasq详解及配置"></a>dnsmasq详解及配置</h1><p>Dnsmasq提供DNS缓存和DHCP服务功能。作为域名解析服务器（DNS），dnsmasq可以通过缓存DNS计法度来提高对访问过的网址的连接速度。作为DHCP服务器，dnsmasq可以用于为局域网电脑分配内网IP地址和提供路由。DNS和DHCP两个功能可以同时或分别单独实现。dnsmasq轻量且易配置，适用于个人用户或少于50台主机的网络，此外它还自带了一个PXE服务器。</p>
<h2 id="Dnsmasq的主要作用"><a href="#Dnsmasq的主要作用" class="headerlink" title="Dnsmasq的主要作用"></a>Dnsmasq的主要作用</h2><ol>
<li>将Dnsmasq作为本地DNS服务器使用，直接个改电脑的本地DNS的IP地址即可。</li>
<li>应对ISP的DNS劫持（反DNS劫持），输入一个不存在的域名，正常情况下浏览器是显示无法连接，DNS劫持会眺转到一个广告页面。先随便nslookup一个不存在的域名，看看ISP商劫持的IP地址</li>
<li>智能DNS加快解析速度，打开&#x2F;etc&#x2F;dnsmasq.conf文件，server&#x3D;后面添加指定DNS，例如国外不同网站使用不同的DNS<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 国内指定DNS</span><br><span class="line">server=/cn/114.114.114.114</span><br><span class="line">server=/taobao.com/114.114.114</span><br><span class="line">server=/taobaocdn.com/114.114.114</span><br><span class="line"># 国外指定DNS</span><br><span class="line">server=/google.com/8.8.8.8</span><br><span class="line">server=/youtube.com/8.8.8.8</span><br></pre></td></tr></table></figure></li>
<li>屏蔽网页广告，将指广告的URL指定127这个IP，就可以将网页上讨厌的广告去掉了。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address=/ad.youku.com/127.0.0.1</span><br><span class="line">address=/ad.iqiyi.com/127.0.0.1</span><br></pre></td></tr></table></figure></li>
<li>指定域名解析到特定的IP上。这个功能可以让你控制一些网站的访问，非法的DNS就经常把一些正规的网站解析到不正确的IP上。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address=/freehao123.com/123.123.123.123</span><br></pre></td></tr></table></figure></li>
<li>管理控制内网DNS，首先将局域网中的所有的设备的本地DNS设置为已经安装的Dnsmasq的服务器IP地址。然后修改已经安装Dnsmasq的服务器Hosts文件：<code>/etc/hosts</code>，指定域名琶特定的iP中。例如想让局域网的所有用户访问<a href="http://www.freehao123.com时跳转到192.168.0.2，添加：192.168.0.2">www.freehao123.com时跳转到192.168.0.2，添加：192.168.0.2</a> <a href="http://www.freehao123.com在hosts文件中既可,整个过程也可以说是“dns劫持”./">www.freehao123.com在Hosts文件中既可，整个过程也可以说是“DNS劫持”。</a></li>
</ol>
<h2 id="Dnsmasq的解析流程"><a href="#Dnsmasq的解析流程" class="headerlink" title="Dnsmasq的解析流程"></a>Dnsmasq的解析流程</h2><p>dnsmasq先去解析hosts文件，再去解析&#x2F;etc&#x2F;dnsmasq.d&#x2F;下的*.conf文件，并且这些文件的优先级要高于dnsmasq.conf，我们自定义的resolv.dnsmasq.conf中的DNS也被称为上游DNS，这是最后去查询解析的；</p>
<p>如果不想用hosts文件做解析，我们可以在&#x2F;etc&#x2F;dnsmasq.conf中加入no-hosts这条语句，这样的话就直接查询上游DNS了，如果我们不想做上游查询，就是不想做正常的解析。我们就可以加入no-reslov这条语句。</p>
<h2 id="Dnsmasq的参数及常用设置说明"><a href="#Dnsmasq的参数及常用设置说明" class="headerlink" title="Dnsmasq的参数及常用设置说明"></a>Dnsmasq的参数及常用设置说明</h2><p>编辑dnsmasq的配置文件<code>/etc/dnsmasq.conf</code>。这个文件有大量的选项注释。</p>
<h3 id="经常修改的比较重要的参数说明"><a href="#经常修改的比较重要的参数说明" class="headerlink" title="经常修改的比较重要的参数说明"></a>经常修改的比较重要的参数说明</h3><table>
<thead>
<tr>
<th>具体参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>resolv-file</td>
<td>定义dnsmasq从哪里获取上游DNS服务器地址，默认从&#x2F;etc&#x2F;resolv.conf获取。</td>
</tr>
<tr>
<td>strict-order</td>
<td>表示严格按照resolv-file文件中的顺序从上到下进行DNS解析，直到第一个解析成功为止</td>
</tr>
<tr>
<td>listen-address</td>
<td>定义dnsmasq监听的地址，默认是监控本机的所有网卡上。</td>
</tr>
<tr>
<td>address</td>
<td>启用泛域名解析，即自定义解析a记录，例如：address&#x3D;&#x2F;long.com&#x2F;192.168.115.10访问long.com时的所有域名都会被解析成192.168.115.10</td>
</tr>
<tr>
<td>bogus-nxdomain</td>
<td>对于任何被解析到此的IP域名，将响应NXDOMAIN使其解析失效，可以多次指定。通常用于对于访问不存在的域名，禁止其跳转到运营商的广告站点</td>
</tr>
<tr>
<td>server</td>
<td>指定使用哪个DNS服务器进行解析，对不不同的网站可以使用不同的域名对应解析。例如：server&#x3D;&#x2F;google.com&#x2F;8.8.8.8 #表示对于google的服务，使用谷歌的DNS解析。</td>
</tr>
</tbody></table>
<h3 id="查看配置文件语法是否正确，可执行下列命令"><a href="#查看配置文件语法是否正确，可执行下列命令" class="headerlink" title="查看配置文件语法是否正确，可执行下列命令"></a>查看配置文件语法是否正确，可执行下列命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost~]# dnsmasq --test</span><br><span class="line">dnsmasq: syntax check OK.</span><br></pre></td></tr></table></figure>

<h3 id="DNS缓存设置"><a href="#DNS缓存设置" class="headerlink" title="DNS缓存设置"></a>DNS缓存设置</h3><p>要在单台电脑上以守护进程方式启动dnsmasq做DNS缓存服务器，编辑&#x2F;etc&#x2F;dnsmasq.conf，添加监听地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen-address=127.0.0.1</span><br></pre></td></tr></table></figure>
<p>如果用此主机为局域网提供默认DNS，请为该主机绑定固定IP地址，设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen-address=192.168.x.x</span><br></pre></td></tr></table></figure>
<p>多个IP地址设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen-address=127.0.0.1, 192.168.x.x</span><br></pre></td></tr></table></figure>

<h3 id="三个以上域名服务器"><a href="#三个以上域名服务器" class="headerlink" title="三个以上域名服务器"></a>三个以上域名服务器</h3><p>linux处理DNS请求时有个限制，在resolv.conf中最多只能配置三个域名服务器（nameserver）。作为一种变通方法，可以在resolv.conf文件中只保留localhost作为域名服务器，然后为外部域名服务器另外创建resolv-file文件。首先，为dnsmasq新建一个域名解析文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost~]# vim /etc/resolv.dnsmasq.conf</span><br><span class="line"># Google&#x27;s nameservers, for example</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.4.4</span><br></pre></td></tr></table></figure>
<p>然后编辑&#x2F;etc&#x2F;dnsmasq.conf让dnsmasq使用新创建的域名解析文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost~]# vim /etc/dnsmasq.conf</span><br><span class="line">...</span><br><span class="line">resolv-file=/etc/resolv.dnsmasq.conf</span><br></pre></td></tr></table></figure>

<h3 id="使用dhcpcd"><a href="#使用dhcpcd" class="headerlink" title="使用dhcpcd"></a>使用dhcpcd</h3><p>dhcpcd可以通过创建（或编辑）<code>/etc/resolv.conf.head</code>文件或<code>/etc/resolv.conf.tail</code>文件来指定dns服务器，使<code>/etc/resolv.conf</code>不会被每次都被dhcpcd重写。<br><code>echo &quot;nameserver 127.0.0.1&quot; &gt; /etc/resolv.conf.head  设置dns服务器为127.0.0.1</code></p>
<h3 id="使用dhclient"><a href="#使用dhclient" class="headerlink" title="使用dhclient"></a>使用dhclient</h3><p>要使用dhclient，取消<code>/etc/dhclient.conf</code>文件中如下行的注释：<br><code>prepend domain-name-servers 127.0.0.1;</code></p>
<h3 id="使用NetworkManager"><a href="#使用NetworkManager" class="headerlink" title="使用NetworkManager"></a>使用NetworkManager</h3><p>NetworkManager可以靠自身配置文件的设置项启动dnsmasq。在NetworkManager.conf文件的[main]节段添加<code>dns=dnsmasq</code>配置语句，然后禁用由systemd启动的dnsmasq.service:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/NetworkManager/NetworkManager.conf</span></span><br><span class="line">[main]</span><br><span class="line">plugins=keyfile</span><br><span class="line">dns=dnsmasq</span><br></pre></td></tr></table></figure>
<p>可以在<code>/etc/NetworkManager/dnsmasq.d/</code>目录下为dnsmasq创建自定义配置文件。例如，调整DNS缓存大小（保存在内存中）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost~]# vim /etc/NetworkManager/dnsmasq.d/cache</span><br><span class="line">cache-size=1000</span><br></pre></td></tr></table></figure>
<p>dnsmasq 被 NetworkManager 启动后，此目录下配置文件中的配置将取代默认配置。</p>
<p>IPv6</p>
<p>启用 dnsmasq 在 NetworkManager 可能会中断仅持IPv6的DNS查询 (例如 dig -6 [hostname]) 否则将工作。 为了解决这个问题，创建以下文件将配置 dnsmasq 总是监听IPv6的loopback：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/NetworkManager/dnsmasq.d/ipv6_listen.conf</span><br><span class="line">listen-address=::1</span><br></pre></td></tr></table></figure>
<p>此外， dnsmasq不优先考虑上游IPv6的DNS。不幸的是NetworkManager已不这样做 (Ubuntu Bug)。 一种解决方法是将禁用IPv4 DNS的NetworkManager的配置，假设存在。</p>
<p>其他方式</p>
<p>另一种选择是在NetworkManagers“设置（通常通过右键单击小程序）和手动输入设置。设置将取决于前端中使用的类型;这个过程通常涉及右击小程序，编辑（或创建）一个配置文件，然后选择DHCP类型为“自动（指定地址）。”DNS地址将需要输入，通常以这种形式：127.0.0.1, DNS-server-one, ….</p>
<h3 id="DHCP服务器设置"><a href="#DHCP服务器设置" class="headerlink" title="DHCP服务器设置"></a>DHCP服务器设置</h3><p>dnsmasq默认关闭DHCP功能，如果该主机需要为局域网中的其他设备提供IP和中由，应该对dnsmasq配置文件（<code>/etc/dnsmasq.conf</code>）必要的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost~]# vim /etc/dnsmasq.conf</span><br><span class="line"># Only listen to routers&#x27; LAN NIC. Doning so opens up tcp/udp port 53 to</span><br><span class="line"># localhost and udp port 67 to world:</span><br><span class="line"></span><br><span class="line">interface=&lt;LAN-NIC&gt;</span><br><span class="line"># dnsmasq will open tcp/upd port 53 and udp port 67 to world to help with</span><br><span class="line"># dynamic interfaces (assigning dynamic ips). Dnsmasq will discard world</span><br><span class="line"># requests to them, but the parranoid might like to close them and let the</span><br><span class="line"># kernel handle them:</span><br><span class="line">bind-interfaces</span><br><span class="line"></span><br><span class="line"># Dynamic range of IPs to make available to LAN pc</span><br><span class="line">dhcp-range=192.168.111.50,192.168.111.100,12h</span><br><span class="line"></span><br><span class="line"># if you&#x27;d like to have dnsmasq assign static IPs, bind the LAN computer&#x27;s</span><br><span class="line"># NIC MAC address:</span><br><span class="line">dhcp-host=aa:bb:cc:dd:ee:ff,192.168.111.50</span><br></pre></td></tr></table></figure>
<p>查看租约</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost~]# cat /var/lib/misc/dnsmasq.leases</span><br></pre></td></tr></table></figure>

<h3 id="添加自定义域"><a href="#添加自定义域" class="headerlink" title="添加自定义域"></a>添加自定义域</h3><p>它可以将一个自定义域添加到主机中的（本地）网络：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local=/home.lan/</span><br><span class="line">domain=home.lan</span><br></pre></td></tr></table></figure>

<h3 id="启动守护进程"><a href="#启动守护进程" class="headerlink" title="启动守护进程"></a>启动守护进程</h3><p>设置开机启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost~]# systemctl enable dnsmasq</span><br></pre></td></tr></table></figure>
<p>立即启动dnsmasq：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost~]# systemctl start dnsmasq</span><br></pre></td></tr></table></figure>
<p>需要重启网络服务以使DHCP客户端重建一个新的&#x2F;etc&#x2F;resolv.conf，查看dnsmasq是否启动正常，查看系统日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost~]# joumalctl -u d</span><br></pre></td></tr></table></figure>

<h2 id="dnsmasq的配置文件-etc-dnsmasq-conf详解"><a href="#dnsmasq的配置文件-etc-dnsmasq-conf详解" class="headerlink" title="dnsmasq的配置文件/etc/dnsmasq.conf详解"></a>dnsmasq的配置文件<code>/etc/dnsmasq.conf</code>详解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 不加载本地的/etc/hosts文件</span><br><span class="line">#no-hosts</span><br><span class="line"># 添加读取额外的hosts文件路径，可以多次指定。如果指定为目录，则读取目录中的所有文件。</span><br><span class="line">#addn-hosts=/etc/dnsmasq.hosts.d</span><br><span class="line"># 读取目录中的所有文件，文件更新将自动读取</span><br><span class="line">#hostsdir=/etc/dnsmasq.hosts.d</span><br><span class="line"># 例如，/etc/hosts中的os01将扩展成os01.example.com</span><br><span class="line">#expand-hosts</span><br><span class="line"></span><br><span class="line"># 缓存时间设置，一般不需要设置</span><br><span class="line"># 本地hosts文件的缓存时间，通常不要求缓存本地，这样更改hosts文件后就即时生效</span><br><span class="line">#local-ttl=3600</span><br><span class="line"># 同local-ttl仅影响DHCP租约</span><br><span class="line">#dhcp-ttl=&lt;time&gt;</span><br><span class="line"># 对于上游返回的值没有ttl时，dnsmasq给一个默认的ttl，一般不需要设置</span><br><span class="line">#neg-ttl=&lt;time&gt;</span><br><span class="line"># 指定返回给客户端的ttl时间，一般不需要设置</span><br><span class="line">#max-ttl=&lt;time&gt;</span><br><span class="line"># 设置在缓存中的条目的最大TTL</span><br><span class="line">#max-cache-ttl=&lt;time&gt;</span><br><span class="line"># 不需要设置，除非你知道你在做什么</span><br><span class="line">#min-cache-ttl=&lt;time&gt;</span><br><span class="line"># 一般不需要设置</span><br><span class="line">#auth-ttl=&lt;time&gt;</span><br><span class="line"></span><br><span class="line"># 记录dns查询日志，如果指定log-queries=extra那么在每行开始处都有额外的日志信息</span><br><span class="line">#log-queries</span><br><span class="line"># 设置日志记录器，&#x27;-&#x27;为stderr，也可以是文件路径。默认为：DAEMON，调试时使用LOCAL0</span><br><span class="line">#log-facility=&lt;facility&gt;</span><br><span class="line">#log-facility=/var/log/dnsmasq/dnsmasq.log</span><br><span class="line"># 异步log，缓解阻塞，提高性能。默认为5，最大100</span><br><span class="line">#log-async[=&lt;lines&gt;]</span><br><span class="line">#log-async=50</span><br><span class="line"></span><br><span class="line">#指定用户和组</span><br><span class="line">#user=nobody</span><br><span class="line">#group=nobody</span><br><span class="line"></span><br><span class="line"># 指定DNS的端口，默认53，设置port=0将完全禁用DNS功能，仅使用DHCP/TFTP</span><br><span class="line">#port=53</span><br><span class="line"># 指定EDNS.0 UDP包的最大尺寸，默认是随机端口，指定后降低安全性、加快速度、减少资源消耗</span><br><span class="line"># 设置为&#x27;0&#x27;由操作系统分配。</span><br><span class="line">#query-port=53535</span><br><span class="line"># 指定向上游查询的UDP的端口范围，方便防火墙设置。</span><br><span class="line">#min-port=&lt;port&gt;</span><br><span class="line">#max-port=&lt;port&gt;</span><br><span class="line"># 指定接口，指定后同时附加lo接口，可以使用&#x27;*&#x27;通配符</span><br><span class="line"># 不能使用接口别名（例好：“eth1:0”），请用listen-address选项替代</span><br><span class="line">#interface=wlp2s0</span><br><span class="line"># 指定排除的接口，排除优先级高，可以使用“*”通配符</span><br><span class="line">#except-interface=</span><br><span class="line"># 仅接受同一子网的DNS请求。</span><br><span class="line"># 仅在未指定interface、excet-interface、listen-address或者auth-server时有效</span><br><span class="line">#local-service</span><br><span class="line"># 指定不提供DHCP或TFTP服务的接口，仅提供DNS服务。</span><br><span class="line">#no-dhcp-interface=enp3s0</span><br><span class="line"># 指定IP地址，可以多次指定</span><br><span class="line"># interface选项和listen-address选项可以同时使用。</span><br><span class="line"># 下面两行与指定interface选项的作用类似。</span><br><span class="line">listen-address=192.168.10.17</span><br><span class="line">#listen-address=127.0.0.1</span><br><span class="line"># 通常情况下即使设置了interface选项（例如：interface=wlp2s0）</span><br><span class="line"># 将仍然绑定到通配符地址（例如：*:53）</span><br><span class="line"># 开启此项将仅监听指定的接口</span><br><span class="line"># 适用于在同一主机的不同接口或IP地址上运行多个dns服务器</span><br><span class="line">bind-interfaces</span><br><span class="line"># 对于新添加的接口不进行绑定。仅linux系统支持，其他系统等同于bind-interfaces选项</span><br><span class="line">#bind-dynamic</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 如果 hosts 中的主机有多个 IP 地址，仅返回对应子网的 IP 地址。</span><br><span class="line">localise-queries</span><br><span class="line"># 如果反向查找的是私有地址例如192.168.X.X，仅从 hosts 文件查找，不再转发到上游服务器</span><br><span class="line">#bogus-priv</span><br><span class="line"># 对于任何被解析到此 IP 的域名，将响应 NXDOMAIN 使其解析失效，可以多次指定</span><br><span class="line"># 通常用于对于访问不存在的域名，禁止其跳转到运营商的广告站点。</span><br><span class="line">#bogus-nxdomain=64.94.110.11</span><br><span class="line"># 忽略包含指定地址的 A 记录查询的回复。</span><br><span class="line"># 例如上游有台 dns 服务器伪造 www.baidu.com 的 IP 为 1.1.1.1 并且响应速度非常快。</span><br><span class="line"># 指定 ignore-address=1.1.1.1 可以忽略它的响应信息，</span><br><span class="line"># 从而等待 www.baidu.com 正确的查询结果。</span><br><span class="line">#ignore-address=&lt;ipaddr&gt;</span><br><span class="line">filterwin2k</span><br><span class="line"></span><br><span class="line">#############################################################################</span><br><span class="line"># 指定 resolv-file 文件路径，默认/etc/resolv.conf</span><br><span class="line">#resolv-file=/etc/resolv.conf</span><br><span class="line"># 不读取 resolv-file 来确定上游服务器</span><br><span class="line">#no-resolv</span><br><span class="line"># 在编译时需要启用 DBus 支持。</span><br><span class="line">#enable-dbus[=&lt;service-name&gt;]</span><br><span class="line"># 严格按照resolv.conf中的顺序进行查找</span><br><span class="line">#strict-order</span><br><span class="line"># 向所有上游服务器发送查询，而不是一个。</span><br><span class="line">all-servers</span><br><span class="line"># 启用转发循环检测</span><br><span class="line">#dns-loop-detect</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 这项安全设置是拒绝解析包含私有 IP 地址的域名，</span><br><span class="line"># 这些IP地址包括如下私有地址范围：10.0.0.0/8、172.16.0.0/12、192.168.0.0/16。</span><br><span class="line"># 其初衷是要防止类似上游DNS服务器故意将某些域名解析成特定私有内网IP而劫持用户这样的安全攻击。</span><br><span class="line"># 直接在配置文件中注销 stop-dns-rebind 配置项从而禁用该功能。</span><br><span class="line"># 这个方法确实可以一劳永逸的解决解析内网 IP 地址的问题，</span><br><span class="line"># 但是我们也失去了这项安全保护的特性，所以在这里我不推荐这个办法。</span><br><span class="line"># 使用 rebind-domain-ok 进行特定配置，顾名思义该配置项可以有选择的忽略域名的 rebind 行为</span><br><span class="line">stop-dns-rebind</span><br><span class="line">rebind-localhost-ok</span><br><span class="line">#rebind-domain-ok=[&lt;domain&gt;]|[[/&lt;domain&gt;/[&lt;domain&gt;/]</span><br><span class="line">rebind-domain-ok=/.test.com/</span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line"># 也不要检测 /etc/resolv.conf 的变化</span><br><span class="line">#no-poll</span><br><span class="line"># 重启后清空缓存</span><br><span class="line">clear-on-reload</span><br><span class="line"># 完整的域名才向上游服务器查找，如果仅仅是主机名仅查找hosts文件</span><br><span class="line">domain-needed</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line"># IP地址转换</span><br><span class="line">#alias=[&lt;old-ip&gt;]|[&lt;start-ip&gt;-&lt;end-ip&gt;],&lt;new-ip&gt;[,&lt;mask&gt;]</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line">#local=[/[&lt;domain&gt;]/[domain/]][&lt;ipaddr&gt;[#&lt;port&gt;][@&lt;source-ip&gt;|&lt;interface&gt;[#&lt;port&gt;]]</span><br><span class="line">#server=[/[&lt;domain&gt;]/[domain/]][&lt;ipaddr&gt;[#&lt;port&gt;][@&lt;source-ip&gt;|&lt;interface&gt;[#&lt;port&gt;]]</span><br><span class="line">server=/test.com/192.168.10.117</span><br><span class="line">server=/10.168.192.in-addr.arpa/192.168.10.117</span><br><span class="line">#rev-server=&lt;ip-address&gt;/&lt;prefix-len&gt;,&lt;ipaddr&gt;[#&lt;port&gt;][@&lt;source-ip&gt;|&lt;interface&gt;[#&lt;port&gt;]]</span><br><span class="line"># 将任何属于 &lt;domain&gt; 域名解析成指定的 &lt;ipaddr&gt; 地址。</span><br><span class="line"># 也就是将 &lt;domain&gt; 及其所有子域名解析成指定的 &lt;ipaddr&gt; IPv4 或者 IPv6 地址，通常用于屏蔽特定的域名。</span><br><span class="line"># 一次只能指定一个 IPv4 或者 IPv6 地址，要同时返回 IPv4 和IPv6 地址，请多次指定 address= 选项。</span><br><span class="line"># 注意： /etc/hosts 以及 DHCP 租约将覆盖此项设置。</span><br><span class="line">#address=/&lt;domain&gt;/[domain/][&lt;ipaddr&gt;]</span><br><span class="line">#ipset=/&lt;domain&gt;/[domain/]&lt;ipset&gt;[,&lt;ipset&gt;]</span><br><span class="line">#mx-host=&lt;mx name&gt;[[,&lt;hostname&gt;],&lt;preference&gt;]</span><br><span class="line">#mx-target=&lt;hostname&gt;</span><br><span class="line"># SRV 记录</span><br><span class="line">#srv-host=&lt;_service&gt;.&lt;_prot&gt;.[&lt;domain&gt;],[&lt;target&gt;[,&lt;port&gt;[,&lt;priority&gt;[,&lt;weight&gt;]]]]</span><br><span class="line"># A, AAAA 和 PTR 记录 </span><br><span class="line">#host-record=&lt;name&gt;[,&lt;name&gt;....],[&lt;IPv4-address&gt;],[&lt;IPv6-address&gt;][,&lt;TTL&gt;]</span><br><span class="line"># TXT 记录</span><br><span class="line">#txt-record=&lt;name&gt;[[,&lt;text&gt;],&lt;text&gt;]</span><br><span class="line"># PTR 记录 </span><br><span class="line">#ptr-record=&lt;name&gt;[,&lt;target&gt;]</span><br><span class="line">#naptr-record=&lt;name&gt;,&lt;order&gt;,&lt;preference&gt;,&lt;flags&gt;,&lt;service&gt;,&lt;regexp&gt;[,&lt;replacement&gt;]</span><br><span class="line"># CNAME 别名记录</span><br><span class="line">#cname=&lt;cname&gt;,&lt;target&gt;[,&lt;TTL&gt;]</span><br><span class="line">#dns-rr=&lt;name&gt;,&lt;RR-number&gt;,[&lt;hex data&gt;]</span><br><span class="line">#interface-name=&lt;name&gt;,&lt;interface&gt;[/4|/6]</span><br><span class="line">#synth-domain=&lt;domain&gt;,&lt;address range&gt;[,&lt;prefix&gt;]</span><br><span class="line">#add-mac[=base64|text]</span><br><span class="line">#add-cpe-id=&lt;string&gt;</span><br><span class="line">#add-subnet[[=[&lt;IPv4 address&gt;/]&lt;IPv4 prefix length&gt;][,[&lt;IPv6 address&gt;/]&lt;IPv6 prefix length&gt;]]</span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line"># 缓存条数，默认为150条，cache-size=0 禁用缓存。</span><br><span class="line">cache-size=1000</span><br><span class="line"># 不缓存未知域名缓存，默认情况下dnsmasq缓存未知域名并直接返回为客户端。</span><br><span class="line">no-negcache</span><br><span class="line"># 指定DNS同属查询转发数量</span><br><span class="line">dns-forward-max=1000</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line">#dnssec</span><br><span class="line">#trust-anchor=[&lt;class&gt;],&lt;domain&gt;,&lt;key-tag&gt;,&lt;algorithm&gt;,&lt;digest-type&gt;,&lt;digest&gt;</span><br><span class="line">#dnssec-check-unsigned</span><br><span class="line">#dnssec-no-timecheck</span><br><span class="line">#dnssec-timestamp=&lt;path&gt;</span><br><span class="line">#proxy-dnssec</span><br><span class="line">#dnssec-debug</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line">#auth-server=&lt;domain&gt;,&lt;interface&gt;|&lt;ip-address&gt;</span><br><span class="line">#auth-zone=&lt;domain&gt;[,&lt;subnet&gt;[/&lt;prefix length&gt;][,&lt;subnet&gt;[/&lt;prefix length&gt;].....]]</span><br><span class="line">#auth-zone=&lt;domain&gt;[,&lt;interface name&gt;[/6|/4][,&lt;interface name&gt;[/6|/4].....]]</span><br><span class="line">#auth-soa=&lt;serial&gt;[,&lt;hostmaster&gt;[,&lt;refresh&gt;[,&lt;retry&gt;[,&lt;expiry&gt;]]]]</span><br><span class="line">#auth-sec-servers=&lt;domain&gt;[,&lt;domain&gt;[,&lt;domain&gt;...]]</span><br><span class="line">#auth-peer=&lt;ip-address&gt;[,&lt;ip-address&gt;[,&lt;ip-address&gt;...]]</span><br><span class="line"># 启用连接跟踪，读取 Linux 入栈 DNS 查询请求的连接跟踪标记，</span><br><span class="line"># 并且将上游返回的响应信息设置同样的标记。</span><br><span class="line"># 用于带宽控制和防火墙部署。</span><br><span class="line"># 此选项必须在编译时启用 conntrack 支持，并且内核正确配置并加载 conntrack。</span><br><span class="line"># 此选项不能与 query-port 同时使用。</span><br><span class="line">#conntrack</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line">#</span><br><span class="line">#        DHCP 选项</span><br><span class="line">#</span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line"># 设置 DHCP 地址池，同时启用 DHCP 功能。</span><br><span class="line"># IPv4 &lt;mode&gt; 可指定为 static|proxy ，当 &lt;mode&gt; 指定为 static 时，</span><br><span class="line"># 需用 dhcp-host 手动分配地址池中的 IP 地址。</span><br><span class="line"># 当 &lt;mode&gt; 指定为 proxy 时，为指定的地址池提供 DHCP 代理。</span><br><span class="line">#dhcp-range=[tag:&lt;tag&gt;[,tag:&lt;tag&gt;],][set:&lt;tag&gt;,]&lt;start-addr&gt;[,&lt;end-addr&gt;][,&lt;mode&gt;][,&lt;netmask&gt;[,&lt;broadcast&gt;]][,&lt;lease time&gt;]</span><br><span class="line">#dhcp-range=172.16.0.2,172.16.0.250,255.255.255.0,1h</span><br><span class="line">#dhcp-range=192.168.10.150,192.168.10.180,static,255.255.255.0,1h</span><br><span class="line"># 根据 MAC 地址或 id 固定分配客户端的 IP 地址、主机名、租期。</span><br><span class="line"># IPv4 下指定 id:* 将忽略 DHCP 客户端的 ID ，仅根据 MAC 来进行 IP 地址分配。</span><br><span class="line"># 在读取 /etc/hosts 的情况，也可以根据 /etc/hosts 中的主机名分配对应 IP 地址。</span><br><span class="line"># 指定 ignore 将忽略指定客户端得 DHCP 请求。</span><br><span class="line">#dhcp-host=[&lt;hwaddr&gt;][,id:&lt;client_id&gt;|*][,set:&lt;tag&gt;][,&lt;ipaddr&gt;][,&lt;hostname&gt;][,&lt;lease_time&gt;][,ignore]</span><br><span class="line">#dhcp-hostsfile=&lt;path&gt;</span><br><span class="line">#dhcp-hostsdir=&lt;path&gt;</span><br><span class="line"># 读取 /etc/ethers 文件 与使用 dhcp-host 的作用相同。IPv6 无效。</span><br><span class="line">#read-ethers</span><br><span class="line"># 指定给 DHCP 客户端的选项信息，</span><br><span class="line"># 默认情况下 dnsmasq 将发送：子网掩码、广播地址、DNS 服务器地址、网关地址、域等信息。</span><br><span class="line"># 指定此选项也可覆盖这些默认值并且设置其他选项值。</span><br><span class="line"># 重要：可以使用 option:&lt;option-name&gt;或者 option号 来指定。</span><br><span class="line"># &lt;option-name&gt; 和 option号的对应关系可使用命令：</span><br><span class="line"># dnsmasq --help dhcp 以及 dnsmasq --help dhcp6 查看，这点很重要。</span><br><span class="line"># 例如设置网关参数，既可以使用 dhcp-option=3,192.168.4.4 也可以使用 dhcp-option = option:router,192.168.4.4。</span><br><span class="line"># 0.0.0.0 意味着当前运行 dnsmasq 的主机地址。</span><br><span class="line"># 如果指定了多个 tag:&lt;tag&gt; 必须同时匹配才行。</span><br><span class="line"># [encap:&lt;opt&gt;,][vi-encap:&lt;enterprise&gt;,][vendor:[&lt;vendor-class&gt;],] 有待继续研究。</span><br><span class="line">#dhcp-option=[tag:&lt;tag&gt;,[tag:&lt;tag&gt;,]][encap:&lt;opt&gt;,][vi-encap:&lt;enterprise&gt;,][vendor:[&lt;vendor-class&gt;],][&lt;opt&gt;|option:&lt;opt-name&gt;|option6:&lt;opt&gt;|option6:&lt;opt-name&gt;],[&lt;value&gt;[,&lt;value&gt;]]</span><br><span class="line">#dhcp-option-force=[tag:&lt;tag&gt;,[tag:&lt;tag&gt;,]][encap:&lt;opt&gt;,][vi-encap:&lt;enterprise&gt;,][vendor:[&lt;vendor-class&gt;],]&lt;opt&gt;,[&lt;value&gt;[,&lt;value&gt;]]</span><br><span class="line">#dhcp-optsfile=&lt;path&gt;</span><br><span class="line">#dhcp-optsdir=&lt;path&gt;</span><br><span class="line">#dhcp-option=3,1.2.3.4</span><br><span class="line">#dhcp-option=option:router,1.2.3.4</span><br><span class="line">#dhcp-option=option:router,192.168.10.254</span><br><span class="line">#dhcp-option=option:dns-server,192.168.10.254,221.12.1.227,221.12.33.227</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line"># (IPv4 only) 禁用重用服务器名称和文件字段作为额外的 dhcp-option 选项。</span><br><span class="line"># 一般情况下 dnsmasq 从 dhcp-boot 移出启动服务器和文件信息到 dhcp-option 选项中。</span><br><span class="line"># 这使得在 dhcp-option 选项封包中有额外的选项空间可用，但是会使老的客户端混淆。</span><br><span class="line"># 此选项将强制使用简单并安全的方式来避免此类情况。可以认为是一个兼容性选项。</span><br><span class="line">#dhcp-no-override</span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line"># 配置 DHCP 中继。</span><br><span class="line"># &lt;local address&gt; 是运行 dnsmasq 的接口的 IP 地址。</span><br><span class="line"># 所有在 &lt;local address&gt; 接口上接收到的 DHCP 请求将中继到 &lt;server address&gt; 指定的远程 DHCP 服务器。</span><br><span class="line"># 可以多次配置此选项，使用同一个 &lt;local address&gt; 转发到多个不同的 &lt;server address&gt; 指定的远程 DHCP 服务器。</span><br><span class="line"># &lt;server address&gt; 仅允许使用 IP 地址，不能使用域名等其他格式。</span><br><span class="line"># 如果是 DHCPv6，&lt;server address&gt; 可以是 ALL_SERVERS 的多播地址 ff05::1:3 。</span><br><span class="line"># 在这种情况下必须指定接口 &lt;interface&gt; ，不能使用通配符，用于直接多播到对应的 DHCP 服务器所在的接口。</span><br><span class="line"># &lt;interface&gt; 指定了仅允许接收从 &lt;interface&gt; 接口的 DHCP 服务器相应信息。</span><br><span class="line">#dhcp-relay=&lt;local address&gt;,&lt;server address&gt;[,&lt;interface&gt;]</span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line"># 设置标签</span><br><span class="line">#dhcp-vendorclass=set:&lt;tag&gt;,[enterprise:&lt;IANA-enterprise number&gt;,]&lt;vendor-class&gt;</span><br><span class="line">#dhcp-userclass=set:&lt;tag&gt;,&lt;user-class&gt;</span><br><span class="line">#dhcp-mac=set:&lt;tag&gt;,&lt;MAC address&gt;</span><br><span class="line">#dhcp-circuitid=set:&lt;tag&gt;,&lt;circuit-id&gt;</span><br><span class="line">#dhcp-remoteid=set:&lt;tag&gt;,&lt;remote-id&gt;</span><br><span class="line">#dhcp-subscrid=set:&lt;tag&gt;,&lt;subscriber-id&gt;</span><br><span class="line">#dhcp-match=set:&lt;tag&gt;,&lt;option number&gt;|option:&lt;option name&gt;|vi-encap:&lt;enterprise&gt;[,&lt;value&gt;]</span><br><span class="line">#tag-if=set:&lt;tag&gt;[,set:&lt;tag&gt;[,tag:&lt;tag&gt;[,tag:&lt;tag&gt;]]]</span><br><span class="line">#dhcp-proxy[=&lt;ip addr&gt;]......</span><br><span class="line"></span><br><span class="line"> ##############################################################################</span><br><span class="line"># 不分配匹配这些 tag:&lt;tag&gt; 的 DHCP 请求。</span><br><span class="line">#dhcp-ignore=tag:&lt;tag&gt;[,tag:&lt;tag&gt;]</span><br><span class="line">#dhcp-ignore-names[=tag:&lt;tag&gt;[,tag:&lt;tag&gt;]]</span><br><span class="line">#dhcp-generate-names=tag:&lt;tag&gt;[,tag:&lt;tag&gt;]</span><br><span class="line"># IPv4 only 使用广播与匹配 tag:&lt;tag&gt; 的客户端通信。一般用于兼容老的 BOOT 客户端。</span><br><span class="line">#dhcp-broadcast[=tag:&lt;tag&gt;[,tag:&lt;tag&gt;]] </span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># IPv4 only 设置 DHCP 服务器返回的 BOOTP 选项，</span><br><span class="line"># &lt;servername&gt; &lt;server address&gt; 可选，</span><br><span class="line"># 如果未设置服务器名称将设为空，服务器地址设为 dnsmasq 的 IP 地址。</span><br><span class="line"># 如果指定了多个 tag:&lt;tag&gt; 必须同时匹配才行。</span><br><span class="line"># 如果指定 &lt;tftp_servername&gt; 将按照 /etc/hosts 中对应的 IP 地址进行轮询负载均衡。  </span><br><span class="line">#dhcp-boot=[tag:&lt;tag&gt;,]&lt;filename&gt;,[&lt;servername&gt;[,&lt;server address&gt;|&lt;tftp_servername&gt;]]</span><br><span class="line"># 根据不同的类型使用不同的选项。</span><br><span class="line"># 使用示例：</span><br><span class="line">#        dhcp-match=set:EFI_x86-64,option:client-arch,9</span><br><span class="line">#        dhcp-boot=tag:EFI_x86-64,uefi/grubx64.efi</span><br><span class="line">#        #dhcp-match=set:EFI_Xscale,option:client-arch,8</span><br><span class="line">#        #dhcp-boot=tag:EFI_Xscale,uefi/grubx64.efi</span><br><span class="line">#        #dhcp-match=set:EFI_BC,option:client-arch,7</span><br><span class="line">#        #dhcp-boot=tag:EFI_BC,uefi/grubx64.efi</span><br><span class="line">#        #dhcp-match=set:EFI_IA32,option:client-arch,6</span><br><span class="line">#        #dhcp-boot=tag:EFI_IA32,uefi/grubx64.efi</span><br><span class="line">#        #dhcp-match=set:Intel_Lean_Client,option:client-arch,5</span><br><span class="line">#        #dhcp-boot=tag:Intel_Lean_Client,uefi/grubx64.efi</span><br><span class="line">#        #dhcp-match=set:Arc_x86,option:client-arch,4</span><br><span class="line">#        #dhcp-boot=tag:Arc_x86,uefi/grubx64.efi</span><br><span class="line">#        #dhcp-match=set:DEC_Alpha,option:client-arch,3</span><br><span class="line">#        #dhcp-boot=tag:DEC_Alpha,uefi/grubx64.efi</span><br><span class="line">#        #dhcp-match=set:EFI_Itanium,option:client-arch,2</span><br><span class="line">#        #dhcp-boot=tag:EFI_Itanium,uefi/grubx64.efi</span><br><span class="line">#        #dhcp-match=set:NEC/PC98,option:client-arch,1</span><br><span class="line">#        #dhcp-boot=tag:NEC/PC98,uefi/grubx64.efi</span><br><span class="line">#        dhcp-match=set:Intel_x86PC,option:client-arch,0</span><br><span class="line">#        dhcp-boot=tag:Intel_x86PC,pxelinux.0</span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line"># DHCP 使用客户端的 MAC 地址的哈希值为客户端分配 IP 地址，</span><br><span class="line"># 通常情况下即使客户端使自己的租约到期，客户端的 IP 地址仍将长期保持稳定。</span><br><span class="line"># 在默认模式下，IP 地址是随机分配的。</span><br><span class="line"># 启用 dhcp-sequential-ip 选项将按顺序分配 IP 地址。</span><br><span class="line"># 在顺序分配模式下，客户端使租约到期更像是仅仅移动一下 IP 地址。</span><br><span class="line"># 在通常情况下不建议使用这种方式。</span><br><span class="line">#dhcp-sequential-ip</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 多数情况下我们使用 PXE，只是简单的允许 PXE 客户端获取 IP 地址，</span><br><span class="line"># 然后 PXE 客户端下载 dhcp-boot 选项指定的文件并执行，也就是 BOOTP 的方式。</span><br><span class="line"># 然而在有适当配置的 DHCP 服务器支持的情况下，PXE 系统能够实现更复杂的功能。</span><br><span class="line"># pxe-service 选项可指定 PXE 环境的启动菜单。</span><br><span class="line"># 为不同的类型系统设定不同的启动菜单，并且覆盖 dhcp-boot 选项。</span><br><span class="line"># &lt;CSA&gt; 为客户端系统类型：x86PC, PC98, IA64_EFI, Alpha, Arc_x86, Intel_Lean_Client, </span><br><span class="line"># IA32_EFI, X86-64_EFI, Xscale_EFI, BC_EFI, ARM32_EFI 和 ARM64_EFI，其他类型可能为一个整数。</span><br><span class="line"># &lt;basename&gt; 引导 PXE 客户端使用 tftp 从 &lt;server address&gt; 或者 &lt;server_name&gt; 下载文件。</span><br><span class="line">#     注意：&quot;layer&quot; 后缀 (通常是 &quot;.0&quot;) 由 PXE 提供，也就是 PXE 客户端默认在文件名附加 .0 后缀。</span><br><span class="line">#     示例：pxe-service=x86PC, &quot;Install Linux&quot;, pxelinux         （读取 pxelinux.0 文件并执行）</span><br><span class="line">#           pxe-service=x86PC, &quot;Install Linux&quot;, pxelinux, 1.2.3.4（不适用于老的PXE）</span><br><span class="line">#     &lt;bootservicetype&gt; 整数，PXE 客户端将通过广播或者通过 &lt;server address&gt; </span><br><span class="line">#           或者 &lt;server_name&gt; 搜索对应类型的适合的启动服务。。</span><br><span class="line">#     示例：pxe-service=x86PC, &quot;Install windows from RIS server&quot;, 1</span><br><span class="line">#           pxe-service=x86PC, &quot;Install windows from RIS server&quot;, 1, 1.2.3.4</span><br><span class="line">#     未指定 &lt;basename&gt;、&lt;bootservicetype&gt; 或者 &lt;bootservicetype&gt; 为 “0”，将从本地启动。</span><br><span class="line">#     示例：pxe-service=x86PC, &quot;Boot from local disk&quot;</span><br><span class="line">#           pxe-service=x86PC, &quot;Boot from local disk&quot;, 0</span><br><span class="line"># 如果指定 &lt;server_name&gt; 将按照 /etc/hosts 中对应的 IP 地址进行轮询负载均衡。  </span><br><span class="line">#pxe-service=[tag:&lt;tag&gt;,]&lt;CSA&gt;,&lt;menu text&gt;[,&lt;basename&gt;|&lt;bootservicetype&gt;][,&lt;server address&gt;|&lt;server_name&gt;]</span><br><span class="line"># 在 PXE 启动后弹出提示，&lt;prompt&gt; 为提示内容，&lt;timeout&gt; 为超时时间，为 0 则立即执行。</span><br><span class="line"># 如果未指定此选项，在有多个启动选项的情况下等待用户选择，不会超时。</span><br><span class="line">#pxe-prompt=[tag:&lt;tag&gt;,]&lt;prompt&gt;[,&lt;timeout&gt;]</span><br><span class="line"># 根据不同的类型使用不同的菜单，使用示例：</span><br><span class="line">#        #pxe-prompt=&quot;What system shall I netboot?&quot;, 120</span><br><span class="line">#        # or with timeout before first available action is taken:</span><br><span class="line">#        pxe-prompt=&quot;Press F8 or Enter key for menu.&quot;, 60</span><br><span class="line">#        pxe-service=x86PC, &quot;Now in x86PC (BIOS mode), boot from local&quot;, 0</span><br><span class="line">#        pxe-service=x86PC, &quot;Now in x86PC (BIOS mode)&quot;, pxelinux</span><br><span class="line">#        pxe-service=PC98, &quot;Now in PC98 mode&quot;, PC98</span><br><span class="line">#        pxe-service=IA64_EFI, &quot;Now in IA64_EFI mode&quot;, IA64_EFI</span><br><span class="line">#        pxe-service=Alpha, &quot;Now in Alpha mode&quot;, Alpha</span><br><span class="line">#        pxe-service=Arc_x86, &quot;Now in Arc_x86 mode&quot;, Arc_x86</span><br><span class="line">#        pxe-service=Intel_Lean_Client, &quot;Now in Intel_Lean_Client mode&quot;, Intel_Lean_Client</span><br><span class="line">#        pxe-service=IA32_EFI, &quot;Now in IA32_EFI mode&quot;, IA32_EFI</span><br><span class="line">#        pxe-service=X86-64_EFI, &quot;Now in X86-64_EFI (UEFI mode), boot from local&quot;, 0</span><br><span class="line">#        pxe-service=X86-64_EFI, &quot;Now in X86-64_EFI (UEFI mode)&quot;, grub/grub-x86_64.efi</span><br><span class="line">#        pxe-service=Xscale_EFI, &quot;Now in Xscale_EFI mode&quot;, Xscale_EFI</span><br><span class="line">#        pxe-service=BC_EFI, &quot;Now in BC_EFI mode&quot;, BC_EFI</span><br><span class="line">#        # CentOS7 系统不支持下列两个选项</span><br><span class="line">#        #pxe-service=ARM32_EFI,&quot;Now in ARM32_EFI mode&quot;,ARM32_EFI</span><br><span class="line">#        #pxe-service=ARM64_EFI,&quot;Now in ARM64_EFI mode&quot;,ARM64_EFI</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 默认为150，即最多分配150个ip地址出去，最大1000个ip</span><br><span class="line">#dhcp-lease-max=150</span><br><span class="line"># (IPv4 only) 指定DHCP端口，默认为67和68。如果不指定则为1067和1068，单指定一个，第二个加1</span><br><span class="line">#dhcp-alternate-port[=&lt;server port&gt;[,&lt;client port&gt;]]</span><br><span class="line"># 谨慎使用此选项，避免 IP 地址浪费。(IPv4 only) 允许动态分配 IP 地址给 BOOTP 客户端。</span><br><span class="line"># 注意：BOOTP 客户端获取的 IP 地址是永久的，将无法再次分配给其他客户端。</span><br><span class="line">#bootp-dynamic[=&lt;network-id&gt;[,&lt;network-id&gt;]]</span><br><span class="line"># 谨慎使用此选项。</span><br><span class="line"># 默认情况下 DHCP 服务器使用 ping 的方式进行确保 IP 未被使用的情况下将 IP 地址分配出去。</span><br><span class="line"># 启用此选项将不使用 ping 进行确认。</span><br><span class="line">#no-ping</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 记录额外的 dhcp 日志，记录所有发送给 DHCP 客户端的选项（option）以及标签（tag）信息</span><br><span class="line">#log-dhcp</span><br><span class="line"># 禁止记录日常操作日志，错误日志仍然记录。启用 log-dhcp 将覆盖下列选项。</span><br><span class="line">#quiet-dhcp</span><br><span class="line">#quiet-dhcp6</span><br><span class="line">#quiet-ra</span><br><span class="line"># 修改 DHCP 默认租约文件路径，默认情况下无需修改</span><br><span class="line">#dhcp-leasefile=/var/lib/dnsmasq/dnsmasq.leases</span><br><span class="line"># (IPv6 only)</span><br><span class="line">#dhcp-duid=&lt;enterprise-id&gt;,&lt;uid&gt;</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line">#dhcp-script=&lt;path&gt;</span><br><span class="line">#dhcp-luascript=&lt;path&gt;</span><br><span class="line">#dhcp-scriptuser=root</span><br><span class="line">#script-arp</span><br><span class="line">#leasefile-ro</span><br><span class="line">#bridge-interface=&lt;interface&gt;,&lt;alias&gt;[,&lt;alias&gt;]</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 给 DHCP 服务器指定 domain 域名信息，也可以给对应的 IP 地址池指定域名。</span><br><span class="line">#     直接指定域名</span><br><span class="line">#     示例：domain=thekelleys.org.uk</span><br><span class="line">#     子网对应的域名</span><br><span class="line">#     示例：domain=wireless.thekelleys.org.uk,192.168.2.0/24</span><br><span class="line">#     ip范围对应的域名</span><br><span class="line">#     示例：domain=reserved.thekelleys.org.uk,192.68.3.100,192.168.3.200</span><br><span class="line">#domain=&lt;domain&gt;[,&lt;address range&gt;[,local]]</span><br><span class="line"># 在默认情况下 dnsmasq 插入普通的客户端主机名到 DNS 中。</span><br><span class="line"># 在这种情况下主机名必须唯一，即使两个客户端具有不同的域名后缀。</span><br><span class="line"># 如果第二个客户端使用了相同的主机名，DNS 查询将自动更新为第二个客户端的 IP 地址。</span><br><span class="line"># 如果设置了 dhcp-fqdn 选项，普通的主机名将不再插入到 DNS 中去，</span><br><span class="line"># 仅允许合格的具有域名后缀的主机名插入到 DNS 服务器中。</span><br><span class="line"># 指定此选项需同时指定不含 &lt;address range&gt; 地址范围的 domain 选项。</span><br><span class="line">#dhcp-fqdn</span><br><span class="line"># 通常情况下分配 DHCP 租约后，dnsmasq 设置 FQDN 选项告诉客户端不要尝试 DDNS 更新主机名与 IP 地址。</span><br><span class="line"># 这是因为  name-IP 已自动添加到 dnsmasq 的 DNS 视图中的。</span><br><span class="line"># 设置此选项将允许客户端 DDNS 更新，</span><br><span class="line"># 在 windows 下允许客户端更新 windows AD 服务器是非常有用的。</span><br><span class="line"># 参看  RFC 4702 。</span><br><span class="line">#dhcp-client-update</span><br><span class="line">#enable-ra</span><br><span class="line">#ra-param=&lt;interface&gt;,[high|low],[[&lt;ra-interval&gt;],&lt;router lifetime&gt;]</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line">#</span><br><span class="line">#        TFTP 选项</span><br><span class="line">#</span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line"># 对于绝大多数的配置，仅需指定 enable-tftp 和 tftp-root 选项即可。</span><br><span class="line"># 是否启用内置的 tftp 服务器，可以指定多个逗号分隔的网络接口</span><br><span class="line">#enable-tftp[=&lt;interface&gt;[,&lt;interface&gt;]]</span><br><span class="line">#enable-tftp</span><br><span class="line">#enable-tftp=enp3s0,lo</span><br><span class="line"># 指定 tftp 的根目录，也就是寻找传输文件时使用的相对路径，可以附加接口，</span><br><span class="line">#tftp-root=&lt;directory&gt;[,&lt;interface&gt;]</span><br><span class="line">#tftp-root=/var/lib/tftpboot/</span><br><span class="line"># 如果取消注释，那么即使指定的 tftp-root 无法访问，仍然启动 tftp 服务。</span><br><span class="line">#tftp-no-fail</span><br><span class="line"># 附加客户端的 IP 地址作为文件路径。此选项仅在正确设置了 tftp-root 的情况下可用，</span><br><span class="line"># 示例：如果 tftp-root=/tftp，客户端为 192.168.1.15 请求 myfile.txt 文件时，</span><br><span class="line"># 将优先请求 /tftp/192.168.1.15/myfile.txt 文件， 其次是 /tftp/myfile.txt 文件。</span><br><span class="line"># 感觉没什么用。</span><br><span class="line">#tftp-unique-root</span><br><span class="line"># 启用安全模式，启用此选项，仅允许 tftp 进程访问属主为自己的文件。</span><br><span class="line"># 不启用此选项，允许访问所有 tftp 进程属主可读取的文件。</span><br><span class="line"># 如果 dnsmasq 是以 root 用户运行，tftp-secure 选项将允许访问全局可读的文件。</span><br><span class="line"># 一般情况下不推荐以 root 用户运行 dnsmasq。</span><br><span class="line"># 在指定了 tftp-root 的情况下并不是很重要。</span><br><span class="line">#tftp-secure</span><br><span class="line"># 将所有文件请求转换为小写。对于 Windows 客户端来说非常有用，建议开启此项。</span><br><span class="line"># 注意：dnsmasq 的 TFTP 服务器总是将文件路径中的“\”转换为“/”。</span><br><span class="line">#tftp-lowercase</span><br><span class="line"># 允许最大的连接数，默认为 50 。</span><br><span class="line"># 如果将连接数设置的很大，需注意每个进程的最大文件描述符限制，详见文档手册。</span><br><span class="line">#tftp-max=&lt;connections&gt;</span><br><span class="line">#tftp-max=50</span><br><span class="line"># 设置传输时的 MTU 值，建议不设置或按需设置。</span><br><span class="line"># 如果设定的值大于网络接口的 MTU 值，将按照网络接口的 MTU 值自动分片传输（不推荐）。</span><br><span class="line">#tftp-mtu=&lt;mtu size&gt;</span><br><span class="line"># 停止 tftp 服务器与客户端协商 &quot;blocksize&quot; 选项。启用后，防止一些古怪的客户端出问题。</span><br><span class="line">#tftp-no-blocksize</span><br><span class="line"># 指定 tftp 的连接端口的范围，方便防火墙部署。</span><br><span class="line"># tftp 侦听在 69/udp ，连接端口默认是由系统自动分配的，</span><br><span class="line"># 非 root 用户运行时指定的连接端口号需大于 1025 最大 65535。</span><br><span class="line">#tftp-port-range=&lt;start&gt;,&lt;end&gt;</span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"></span><br><span class="line">#conf-dir=&lt;directory&gt;[,&lt;file-extension&gt;......]</span><br><span class="line">#conf-file=/etc/dnsmasq.more.conf</span><br><span class="line">conf-dir=/etc/dnsmasq.d</span><br><span class="line">#servers-file=&lt;file&gt;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>DD-WRT</tag>
      </tags>
  </entry>
  <entry>
    <title>Daphile数播平台中文手册</title>
    <url>/2021/09/07/Daphile/</url>
    <content><![CDATA[<p><img src="/Daphile/1.png" alt="1"></p>
<h3 id="快速入门指南"><a href="#快速入门指南" class="headerlink" title="快速入门指南"></a>快速入门指南</h3><ul>
<li>下载Daphile ISO文件</li>
<li>使用USBWriter或者类似工具将其写入U盘</li>
<li>从U盘启动Daphile系统</li>
<li>在其他PC浏览器输入地址：<ul>
<li><a href="http://daphile.local/">http://daphile.local</a> 或者在Daphile系统设置的IP地址</li>
</ul>
</li>
<li>进入Daphile系统，转到”Settings–&gt;System Firmware”中安装Daphile</li>
</ul>
<span id="more"></span>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    本文档描述了Daphile安装和一些基本系统设置，使系统可以用于听音乐。默认安装方法是假定将用于安装的硬盘或其它存储设置将完全用于Daphile，并且将从中删除所有现有数据。如果想要使用自定义驱动器分区或配置多启动，请阅读后面的相关章节。</p>
<h3 id="运行Daphile主机配置要求"><a href="#运行Daphile主机配置要求" class="headerlink" title="运行Daphile主机配置要求"></a>运行Daphile主机配置要求</h3><ul>
<li>处理器：基于x86架构，最低i486</li>
<li>内存：512MB</li>
<li>网络适配器：以太网或WIFI</li>
<li>可启动存储设备：2GB（SATA、IDE或USB）</li>
<li>音频设备：PCI声卡、USB声卡或USB解码器等</li>
<li>第二台设置用于访问Daphile</li>
</ul>
<h3 id="下载Daphile"><a href="#下载Daphile" class="headerlink" title="下载Daphile"></a>下载Daphile</h3><p>从<a href="http://www.daphile.com下载daphile/">http://www.daphile.com下载Daphile</a> ISO文件</p>
<p>X86_64版本为推荐版本</p>
<h3 id="准备安装介质"><a href="#准备安装介质" class="headerlink" title="准备安装介质"></a>准备安装介质</h3><p>U盘是推荐安装盘。以下部分将介绍如何使用不同的操作系统（Windows、OS X和Linux）写入USB安装盘，此阶段只要准备安装盘，而不是最终的Daphile安装。Daphile安装盘仅用于进行最终目标的安装。这其中有许多工具（例如，unetbootin、Rufus等）。</p>
<p>下面描术的所有方未予都将从设备中删除所有数据。您必须小心使用，否则您可能会遇到严重的数据丢失。</p>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>使用USBWriter（<a href="https://sourceforge.net/projects/usbwriter%EF%BC%89">https://sourceforge.net/projects/usbwriter）</a></p>
<p><img src="/Daphile/2.png" alt="2"></p>
<h4 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h4><p>在MacOS系统中创建可启动USB媒体的最简单方法是使用Balena Etcher。您可以从<a href="http://www.balena.io/etcher/%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%E4%B8%89%E6%AD%A5%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://www.balena.io/etcher/下载安装并使用，使用非常简单三步如下图：</a></p>
<p><img src="/Daphile/3.png" alt="3"></p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>运行以下命令，将&#x2F;dev&#x2F;sdx替换为您的驱动器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=/path/to/daphile.iso of=/dev/sdx bs=1M &amp;&amp; <span class="built_in">sync</span></span><br></pre></td></tr></table></figure>

<p>使用lsblk命令找出您的驱动器的名称，确保它没有安装</p>
<h3 id="安装Daphile系统"><a href="#安装Daphile系统" class="headerlink" title="安装Daphile系统"></a>安装Daphile系统</h3><p>插入U盘，使用U盘启动</p>
<p><img src="/Daphile/4.png" alt="4"></p>
<p>按F1键执行初始设置，初始设置包括配置无线网络或配置有线网络，擦除另一个准备安装Daphile的硬盘或存储设备，一旦Daphile启动成功完成，您应该在屏幕上收到以下消息</p>
<p><img src="/Daphile/5.png" alt="5"></p>
]]></content>
      <categories>
        <category>文档手册</category>
      </categories>
      <tags>
        <tag>Daphile</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Docker</title>
    <url>/2018/05/15/Docker/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>Docker自开源以来受到了各大公司的广泛关注，或许现在互联网公司的运维体系不承载在Docker之上都不好意思说自己是互联网公司。</p>
<span id="more"></span>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>对Docker最简单并且带有一定错误的认知就是“Docker是一种性能非常好的虚拟机”。<br>正如上面所说，这是有一定错误的说法。Docker相比于传统虚拟机的技术来说先进了不少，具体表现在Docker不是在宿主机上虚拟出一套硬件后再虚拟出一个操作系统，而是让Docker容器里面的进程直接运行在宿主机上（Docker会做文件、网络等的隔离），这样一来Docker会“体积更轻、跑的更快、同宿主机下可创建的个数更多”。<br>Docker中有三个核心概念：Image、Container、Repository</p>
<ul>
<li>Image：Docker中的镜像是分层的，可复用的，而非简单的一堆文件迭在一起（类似于一个压缩包的源码和一个git仓库的区别）。</li>
<li>Container：容器的存在离不开镜像的支持，他是镜像运行时的一个载体（类似于实例与类的关系）。依托Docker的虚拟化技术，给容器创建了独立的端口、进程、文件等“空间，Containner就是一个与宿机隔离“容器”。容器可宿主机之间可以进行port、volumer、network等的通信。</li>
<li>Repository：Docker的仓库和git仓库比较相似</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Win10"><a href="#Win10" class="headerlink" title="Win10"></a>Win10</h2><ul>
<li>计算机BIOS开机虚拟化支持（VT-x&#x2F;AMD-V）</li>
<li>启用Hyper-V</li>
<li>安装docker for Windows</li>
</ul>
<p><a href="https://www.docker.com下载docker/">https://www.docker.com下载Docker</a> Desktop</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul>
<li>获取安装脚本<a href="https://get.docker.com/">https://get.docker.com</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sh get-docker.sh</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p><strong>需要开启sudo</strong>，验证安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker version</span><br></pre></td></tr></table></figure>

<h1 id="Image-vs-container-镜像与容器"><a href="#Image-vs-container-镜像与容器" class="headerlink" title="Image vs container 镜像与容器"></a>Image vs container 镜像与容器</h1><h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><ul>
<li>docker image是一个只读文件</li>
<li>这个文件包含文件系统，源码，库文件，依赖，工具等一些运行application所需要的文件</li>
<li>docker image具有分层的概念</li>
</ul>
<h2 id="Container容器"><a href="#Container容器" class="headerlink" title="Container容器"></a>Container容器</h2><ul>
<li>一个运行中的docker image</li>
<li>实质是复制image最上层加上一层read-write（称之为container layer容器层）</li>
<li>基于同一个image可以创建多个container</li>
</ul>
<h2 id="docker-image获取"><a href="#docker-image获取" class="headerlink" title="docker image获取"></a>docker image获取</h2><ul>
<li>自己制作</li>
<li>从registry拉取，比如docker hub</li>
</ul>
<h2 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span></span><br><span class="line">docker container run nginx</span><br><span class="line">docker container ps</span><br><span class="line">docker <span class="built_in">ls</span></span><br><span class="line">docker ps -a</span><br><span class="line">docker container logs 容器ID</span><br><span class="line">docker container logs -f 容器ID</span><br><span class="line">docker container run -it ubuntu sh</span><br><span class="line">docker <span class="built_in">exec</span> -it 容器ID sh</span><br><span class="line">docker container run -it busybox sh</span><br><span class="line"><span class="comment">#显示docker运行容器程序所使用的进程</span></span><br><span class="line">docker container top 容器ID</span><br></pre></td></tr></table></figure>

<h2 id="如何批量的停止所有的容器"><a href="#如何批量的停止所有的容器" class="headerlink" title="如何批量的停止所有的容器"></a>如何批量的停止所有的容器</h2><p>停止多个容器可以通过命令<code>docker container stop 容器id1 容器id2....</code>来完成，前提是需要知道容器的ID，如果几十个ID要一个一个写，如何简便操作呢</p>
<ul>
<li>批量获取容器ID，可以通过命令<code>docker container ps -qa</code>来完成</li>
<li>把上面获取的参数传递给<code>docker container stop</code>命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container stop $(docker container ps -qa)</span><br></pre></td></tr></table></figure>

<h1 id="镜像的获取"><a href="#镜像的获取" class="headerlink" title="镜像的获取"></a>镜像的获取</h1><ul>
<li>从registry拉取<ul>
<li>public 公有</li>
<li>private 私有（内部搭建）</li>
</ul>
</li>
<li>从Dockerfile构建</li>
<li>文件导入（离线）</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Dell7080-布署ESXi</title>
    <url>/2022/03/22/Dell7080%E5%B8%83%E7%BD%B2ESXi/</url>
    <content><![CDATA[<p>本篇文章只在记录Dell小主机Optiplex 7080 micro上安装ESXi的过程，主机配置表如下：</p>
<p>CPU：Intel Core i5-10500T</p>
<p>显示：IntelUHD 630</p>
<p>有线网卡：Intel i210</p>
<p>无线网卡：Intel Wi-Fi AX201双频2*2 802.11.ax MU-MIMO +  蓝牙5.0含内置天线</p>
<span id="more"></span> 

<h2 id="难点一"><a href="#难点一" class="headerlink" title="难点一"></a>难点一</h2><h3 id="ESXi无法识别主机的以太网卡Intel-i210"><a href="#ESXi无法识别主机的以太网卡Intel-i210" class="headerlink" title="ESXi无法识别主机的以太网卡Intel i210"></a>ESXi无法识别主机的以太网卡Intel i210</h3><h4 id="首先到官网下载ESXi离线安装包"><a href="#首先到官网下载ESXi离线安装包" class="headerlink" title="首先到官网下载ESXi离线安装包"></a>首先到官网下载ESXi离线安装包</h4><p><img src="/Dell7080%E5%B8%83%E7%BD%B2ESXi/1.png" alt="1"></p>
<h4 id="下载ESXi-Customizer-PS最新版本工具"><a href="#下载ESXi-Customizer-PS最新版本工具" class="headerlink" title="下载ESXi-Customizer-PS最新版本工具"></a>下载ESXi-Customizer-PS最新版本工具</h4><p>官网下载：<a href="https://www.v-front.de/p/exsi-customizer-ps.html">https://www.v-front.de/p/exsi-customizer-ps.html</a></p>
<h4 id="下载需要的驱动"><a href="#下载需要的驱动" class="headerlink" title="下载需要的驱动"></a>下载需要的驱动</h4><p>i210驱动：igb-4.2.16.8-offline_bundle-1242301.zip</p>
<h4 id="封装网卡驱动"><a href="#封装网卡驱动" class="headerlink" title="封装网卡驱动"></a>封装网卡驱动</h4><p>需要在Windows操作系统下完成，建立文件夹将网卡驱动放到pkg文件夹下</p>
<p><img src="/Dell7080%E5%B8%83%E7%BD%B2ESXi/2.png" alt="2"></p>
<p><img src="/Dell7080%E5%B8%83%E7%BD%B2ESXi/3.png" alt="3"></p>
<p><strong>使用管理员权限运行Windows PowerShell</strong>，安装依赖</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Install-Module</span> <span class="literal">-Name</span> VMware.PowerCLI</span><br></pre></td></tr></table></figure>

<p><img src="/Dell7080%E5%B8%83%E7%BD%B2ESXi/4.png" alt="4"></p>
<p>调整PowerShell的执行策略来让脚本可以正常运行。默认的执行策略无法运行脚本</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Unrestricted</span><br></pre></td></tr></table></figure>

<p>开始打驱动补丁并自动封装为ISO</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\ESXi<span class="literal">-Customizer-PS-v2</span>.<span class="number">6.0</span>.ps1 <span class="literal">-izip</span> .\VMware<span class="literal">-ESXi-7</span>.<span class="number">0</span>U3c<span class="literal">-19193900-depot</span>.zip <span class="literal">-pkgDir</span> D:\Dell7080\nic\pkg</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ESXi-Customizer-PS-v2.6.0.ps1：为最新的工具命令</span><br><span class="line">VMware-ESXi-7.0U3c-19193900-depot.zip：为最新的ESXI7.0的离线包</span><br><span class="line">D:\Dell7080\nic\pkg：为VIB驱动的路径</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Dell7080</tag>
        <tag>ESXi</tag>
      </tags>
  </entry>
  <entry>
    <title>Vmware ESXi连接iSCSI</title>
    <url>/2021/08/06/ESXi%E8%BF%9E%E6%8E%A5iSCSI/</url>
    <content><![CDATA[<h3 id="一、-设定VMkernal-NIC"><a href="#一、-设定VMkernal-NIC" class="headerlink" title="一、 设定VMkernal NIC"></a>一、 设定VMkernal NIC</h3><ol>
<li>登陆VMware ESXi</li>
<li>导航器–&gt;网络–&gt;虚拟交换机–&gt;添加标准虚拟交换机</li>
</ol>
<span id="more"></span>

<p><img src="/ESXi%E8%BF%9E%E6%8E%A5iSCSI/1.png" alt="1"></p>
<ol start="2">
<li>前往导航器–&gt;网络–&gt;VMkernel 网卡–&gt;添加VMkernel网卡</li>
</ol>
<img src="ESXi连接iSCSI/3.png" alt="2" style="zoom:80%;" />

<h3 id="二、在Vmware-ESXi上挂载iSCSI-Target"><a href="#二、在Vmware-ESXi上挂载iSCSI-Target" class="headerlink" title="二、在Vmware ESXi上挂载iSCSI Target"></a>二、在Vmware ESXi上挂载iSCSI Target</h3><ol>
<li><p>挂载iSCSI Target，前往导航器–&gt;存储–&gt;适配器–&gt;配置iSCSI</p>
<img src="ESXi连接iSCSI/4.png" alt="3" style="zoom:80%;" />

<ol start="3">
<li><p>启动iSCSI</p>
</li>
<li><p>添加端口绑定，绑定上步添加VMkernel网卡端口</p>
</li>
<li><p>保存配置</p>
</li>
<li><p>前往导航器–&gt;存储–&gt;设备，然后按刷新。确认iSCSI适配器扫描到新的硬盘</p>
</li>
<li><p>可以修改下面的值使您的iSCSI服务更稳定</p>
<p>7.1 LoginTimeout：将数值从5修改到60</p>
<p>7.2 NoopTimeout：将数值从10修改到30</p>
<p>7.3 DelayedAck：取消勾选以关闭DelayedACK</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Esxi</tag>
      </tags>
  </entry>
  <entry>
    <title>Jellyfin问题汇总</title>
    <url>/2021/09/15/Jellyfin%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="一、-Jellyfin硬件加速的问题"><a href="#一、-Jellyfin硬件加速的问题" class="headerlink" title="一、  Jellyfin硬件加速的问题"></a>一、  Jellyfin硬件加速的问题</h3><p>首先，Jellyfin是支持使用FFMpeg进行视频编码&#x2F;解码的硬件加速（HWA）的。FFMpeg和Jellyfin可以通过视频加速API支持多种硬件加速实现，例如：</p>
<ul>
<li>VA-API是一个视频加速API，它使用libva与本地驱动程序接口用以提供HWA的支持</li>
<li>QSV使用VA-API的修改（分支）版本，并将其与libmfx及其专有驱动程序连接</li>
</ul>
<span id="more"></span>

<p>以下是官网提供的操作系统与推荐配置的接口</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>推荐的硬件加速</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>QSV、NVENC、AMF、VA-API</td>
</tr>
<tr>
<td>Windows</td>
<td>QSV、NVENC、AMF</td>
</tr>
<tr>
<td>MacOS</td>
<td>VideoToolbox</td>
</tr>
<tr>
<td>Android</td>
<td>MediaCodec、OMX</td>
</tr>
<tr>
<td>树莓派</td>
<td>OMX</td>
</tr>
</tbody></table>
<p>使用HWA的显卡比较</p>
<table>
<thead>
<tr>
<th>显卡</th>
<th>支持的硬件加速</th>
</tr>
</thead>
<tbody><tr>
<td>nVidia</td>
<td>NVENC、VA-API</td>
</tr>
<tr>
<td>AMD</td>
<td>AMF、VA-API</td>
</tr>
<tr>
<td>Intel</td>
<td>QSV、VA-API</td>
</tr>
<tr>
<td>Apple</td>
<td>VideoToolbox</td>
</tr>
<tr>
<td>Other</td>
<td>OMX、MediaCodec</td>
</tr>
</tbody></table>
<ol>
<li><h4 id="核显在你的Linux系统是否正确的加载？"><a href="#核显在你的Linux系统是否正确的加载？" class="headerlink" title="核显在你的Linux系统是否正确的加载？"></a>核显在你的Linux系统是否正确的加载？</h4><p>我的核显型号为：Intel UHD630，Intel在2017年就启动了Media SDK+相关的Linux图形堆栈&#x2F;驱动程序开源项目。</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>Repo</th>
<th>库名</th>
</tr>
</thead>
<tbody><tr>
<td>libVA API</td>
<td><a href="https://github.com/intel/libva">Libva</a>,<a href="https://github.com/intel/libva-utils">libva-utils</a></td>
<td>Libva*.so</td>
</tr>
<tr>
<td>VAAPI Intel Driver</td>
<td><a href="https://github.com/intel/media-driver">Media-driver</a>,<a href="https://github.com/intel/gmmlib">GMMLib</a></td>
<td>iHD_drv_video.so，igfxcmrt64.so</td>
</tr>
<tr>
<td>Media SDK Library</td>
<td><a href="https://github.com/Intel-Media-SDK/MediaSDK">MediaSDK</a></td>
<td>libmfxhw64.so and files under &#x2F;opt&#x2F;intel&#x2F;mediasdk</td>
</tr>
</tbody></table>
<p>下面以Ubuntun为例，做构建说明</p>
<p>1.1.  安装系统依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sudo apt-get -y install git libssl-dev dh-autoreconf cmake libgl1-mesa-dev libpciaccess-dev libelf-dev</span><br><span class="line"># mkdir &lt;path-to-working-directory&gt;</span><br><span class="line"># export WORKING_DIR=&lt;path-to-working-directory&gt;</span><br></pre></td></tr></table></figure>

<p>1.2. 固件的检查与更新</p>
<p>1.3. 重新编译libra和libdrm</p>
<p>​        基于prefix的不同配置，你可能需要更新LD_LIBRARY_PATH以便安装后可以找到库文件， 另外，记得首先移除其他的libdrm和libva版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /usr -name &quot;libdrm*&quot; | xargs rm -rf</span><br><span class="line">find /usr -name &quot;libva*&quot; | xargs rm -rf</span><br></pre></td></tr></table></figure>

<p>重建和安装libdrm:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /opt/intel/mediasdk/opensource/libdrm/*/libdrm-2.4.54.tar.bz2 .</span><br><span class="line">tar xf libdrm-2.4.54.tar.bz2</span><br><span class="line">cd libdrm-2.4.54</span><br><span class="line">./configure --prefix=/usr/local</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>重建和安装libva:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd $WORKING_DIR</span><br><span class="line">git clone https://github.com/intel/libva.git</span><br><span class="line">git clone https://github.com/intel/libva-utils.git</span><br><span class="line">cd $WORKING_DIR/libva</span><br><span class="line">./autogen.sh --prefix=/usr --libdir=/usr/lib/x86_64-linux-gnu</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br><span class="line">cd $WORKING_DIR/libva-utils</span><br><span class="line">./autogen.sh --prefix=/usr --libdir=/usr/lib/x86_64-linux-gnu</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>注意: 请首先编译libdrm，因为libva依赖于libdrm</p>
<p>编译安装VAAPI Intel Driver</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd $WORKING_DIR</span><br><span class="line">git clone https://github.com/intel/media-driver.git</span><br><span class="line">git clone https://github.com/intel/gmmlib.git</span><br><span class="line">cd $WORKING_DIR/gmmlib</span><br><span class="line">cd $WORKING_DIR/media-driver</span><br><span class="line">cd $WORKING_DIR</span><br><span class="line">mkdir -p build</span><br><span class="line">cd $WORKING_DIR/build</span><br><span class="line">cmake ../media-driver</span><br><span class="line">make -j8</span><br><span class="line">sudo make install</span><br><span class="line">export LIBVA_DRIVER_NAME=iHD</span><br><span class="line">export LIBVA_DRIVERS_PATH=/usr/lib/x86_64-linux-gnu/dri</span><br><span class="line">vainfo</span><br></pre></td></tr></table></figure>

<p>编译安装MediaSDK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd $WORKING_DIR</span><br><span class="line">git clone https://github.com/Intel-Media-SDK/MediaSDK.git</span><br><span class="line">cd MediaSDK</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake ..</span><br><span class="line">make -j8</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>设置必要的环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd $WORKING_DIR</span><br><span class="line">cd MediaSDK/build/__bin/release</span><br><span class="line">export MFX_HOME=/opt/intel/mediasdk</span><br><span class="line">export LIBVA_DRIVERS_PATH=/usr/lib/x86_64-linux-gnu/dri</span><br><span class="line">export LIBVA_DRIVER_NAME=iHD</span><br><span class="line">./sample_multi_transcode -i::h264 input.264 -o::h264 out.264</span><br></pre></td></tr></table></figure>


</li>
<li><h4 id="怎么验证做了正确的转码设置？"><a href="#怎么验证做了正确的转码设置？" class="headerlink" title="怎么验证做了正确的转码设置？"></a>怎么验证做了正确的转码设置？</h4><p>要验证使用了正确的库，可以在控制台–&gt;日志，或者终端下查看 <code>/var/log/jellyfin</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -A2 &#x27;Stream mapping:&#x27; /var/log/jellyfin/ffmpeg-transcode-85a68972-7129-474c-9c5d-2d9949021b44.txt</span><br></pre></td></tr></table></figure>

<p>这返回了以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream mapping:</span><br><span class="line">Stream #0:0 -&gt; #0:0 (hevc (native) -&gt; h264 (h264_omx))</span><br><span class="line">Stream #0:1 -&gt; #0:1 (aac (native) -&gt; mp3 (libmp3lame))</span><br></pre></td></tr></table></figure>

<p><code>Stream #0:0</code>用软件解码HEVC（VAAPI Decode也可以说是native），用HWA编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream mapping:</span><br><span class="line">Stream #0:0 -&gt; #0:0 (h264 (h264_mmal) -&gt; h264 (h264_omx))</span><br><span class="line">Stream #0:1 -&gt; #0:1 (flac (native) -&gt; mp3 (libmp3lame))</span><br></pre></td></tr></table></figure>

<p><code>Stream #0:0</code> 两者都使用HWA。h264_mmal解码，H264_omx编码</p>
</li>
</ol>
<h3 id="二、Jellyfin字幕方框字的问题"><a href="#二、Jellyfin字幕方框字的问题" class="headerlink" title="二、Jellyfin字幕方框字的问题"></a>二、Jellyfin字幕方框字的问题</h3><ol>
<li><h4 id="Jellyfin本地客户端解码导中文字幕显示方块解决方法"><a href="#Jellyfin本地客户端解码导中文字幕显示方块解决方法" class="headerlink" title="Jellyfin本地客户端解码导中文字幕显示方块解决方法"></a>Jellyfin本地客户端解码导中文字幕显示方块解决方法</h4><p>编辑mpv.conf，放到<code>/Users/用户名/Library/Application Support/Jellyfin Media Player/</code>目录中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim: syntax=config</span><br><span class="line"> </span><br><span class="line">###########</span><br><span class="line"># General #</span><br><span class="line">###########</span><br><span class="line"> </span><br><span class="line">save-position-on-quit</span><br><span class="line">no-border                               # no window title bar</span><br><span class="line">msg-module                              # prepend module name to log messages</span><br><span class="line">msg-color                               # color log messages on terminal</span><br><span class="line">term-osd-bar                            # display a progress bar on the terminal</span><br><span class="line">use-filedir-conf                        # look for additional config files in the directory of the opened file</span><br><span class="line">#pause                                  # no autoplay</span><br><span class="line">keep-open                               # keep the player open when a file&#x27;s end is reached</span><br><span class="line">autofit-larger=100%x95%                 # resize window in case it&#x27;s larger than W%xH% of the screen</span><br><span class="line">deinterlace=yes                        # &#x27;auto&#x27; does not imply interlacing-detection</span><br><span class="line">cursor-autohide-fs-only                 # don&#x27;t autohide the cursor in window mode, only fullscreen</span><br><span class="line">input-media-keys=no                     # enable/disable OSX media keys</span><br><span class="line">cursor-autohide=1000                    # autohide the curser after 1s</span><br><span class="line">screenshot-format=png</span><br><span class="line">screenshot-png-compression=8</span><br><span class="line">screenshot-template=&#x27;~/Desktop/%F (%P) %n&#x27;</span><br><span class="line">hls-bitrate=max                         # use max quality for HLS streams</span><br><span class="line">ytdl-raw-options=format=&quot;[protocol!=http_dash_segments][protocol!=rtmp]&quot;</span><br><span class="line">#########</span><br><span class="line"># Cache #</span><br><span class="line">#########</span><br><span class="line">cache=yes</span><br><span class="line">cache-default=81960                     # size in KB  BTW: before is 8000000 it is too big</span><br><span class="line">cache-backbuffer=25000                  # size in KB</span><br><span class="line">cache-initial=0                         # start playback when your cache is filled up with x kB</span><br><span class="line">cache-secs=10                           # how many seconds of audio/video to prefetch if the cache is active</span><br><span class="line">#############</span><br><span class="line"># OSD / OSC #</span><br><span class="line">#############</span><br><span class="line">osd-level=1                             # enable osd and display --osd-status-msg on interaction</span><br><span class="line">osd-duration=2500                       # hide the osd after x ms</span><br><span class="line">osd-status-msg=&#x27;$&#123;time-pos&#125; / $&#123;duration&#125;$&#123;?percent-pos:　($&#123;percent-pos&#125;%)&#125;$&#123;?vo-drop-frame-count:$&#123;!vo-drop-frame-count==0:　Dropped: $&#123;vo-drop-frame-count&#125;&#125;&#125;\n$&#123;?chapter:Chapter: $&#123;chapter&#125;&#125;&#x27;</span><br><span class="line">osd-font=&#x27;Source Sans Pro&#x27;</span><br><span class="line">osd-font-size=32</span><br><span class="line">osd-color=&#x27;#CCFFFFFF&#x27;                   # ARGB format</span><br><span class="line">osd-border-color=&#x27;#DD322640&#x27;            # ARGB format</span><br><span class="line">#osd-shadow-offset=1                    # pixel width for osd text and progress bar</span><br><span class="line">osd-bar-align-y=0                       # progress bar y alignment (-1 top, 0 centered, 1 bottom)</span><br><span class="line">osd-border-size=2                       # size for osd text and progress bar</span><br><span class="line">osd-bar-h=2                             # height of osd bar as a fractional percentage of your screen height</span><br><span class="line">osd-bar-w=60                            # width of &quot; &quot; &quot;</span><br><span class="line">#############</span><br><span class="line"># Subtitles #</span><br><span class="line">#############</span><br><span class="line">sub-use-margins</span><br><span class="line">sub-ass-force-margins</span><br><span class="line">demuxer-mkv-subtitle-preroll            # try to correctly show embedded subs when seeking</span><br><span class="line">sub-auto=fuzzy                          # external subs don&#x27;t have to match the file name exactly to autoload</span><br><span class="line">sub-paths=ass:srt:sub:subs:subtitles    # search for external subs in the listed subdirectories</span><br><span class="line">embeddedfonts=yes                       # use embedded fonts for SSA/ASS subs</span><br><span class="line">sub-fix-timing=no                       # do not try to fix gaps (which might make it worse in some cases)</span><br><span class="line">sub-ass-force-style=Kerning=yes         # allows you to override style parameters of ASS scripts</span><br><span class="line"> </span><br><span class="line">sub-font-size=48            # Font Size UPDATE: 2017-02-20</span><br><span class="line">sub-codepage=utf8:gb18030       # for support Chinese</span><br><span class="line"> </span><br><span class="line"># the following options only apply to subtitles without own styling (i.e. not ASS but e.g. SRT)</span><br><span class="line">sub-font=&quot;Noto Sans CJK SC Medium&quot;</span><br><span class="line">#sub-font-size=36</span><br><span class="line">#sub-color=&quot;#FFFFFFFF&quot;</span><br><span class="line">#sub-border-color=&quot;#FF262626&quot;</span><br><span class="line">#sub-border-size=3.2</span><br><span class="line">#sub-shadow-offset=1</span><br><span class="line">#sub-shadow-color=&quot;#33000000&quot;</span><br><span class="line">#sub-spacing=0.5</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#############</span><br><span class="line"># Languages #</span><br><span class="line">#############</span><br><span class="line"> </span><br><span class="line">#slang=enm,en,eng,de,deu,ger             # automatically select these subtitles (decreasing priority)</span><br><span class="line">#alang=en,eng,de,deu,ger       # automatically select these audio tracks (decreasing priority)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#########</span><br><span class="line"># Audio #</span><br><span class="line">#########</span><br><span class="line"> </span><br><span class="line">audio-file-auto=fuzzy                   # external audio doesn&#x27;t has to match the file name exactly to autoload</span><br><span class="line">audio-pitch-correction=yes              # automatically insert scaletempo when playing with higher speed</span><br><span class="line">volume-max=200                          # maximum volume in %, everything above 100 results in amplification</span><br><span class="line">volume=100                              # default volume, 100 = unchanged</span><br><span class="line">################</span><br><span class="line"># Video Output #</span><br><span class="line">################</span><br><span class="line"># Active VOs (and some other options) are set conditionally</span><br><span class="line"># See here for more information: https://github.com/wm4/mpv-scripts/blob/master/auto-profiles.lua</span><br><span class="line"># The script was slightly modified, functions from scripts/auto-profiles-functions.lua are imported</span><br><span class="line"># Defaults for all profiles</span><br><span class="line">vo=opengl</span><br><span class="line">tscale=linear</span><br><span class="line">[high-quality]</span><br><span class="line">profile-desc=cond:is_desktop() and get(&#x27;width&#x27;, math.huge) &lt; 3840</span><br><span class="line">scale=ewa_lanczossharp</span><br><span class="line">cscale=ewa_lanczossoft</span><br><span class="line">dscale=mitchell</span><br><span class="line">scale-antiring=0.7</span><br><span class="line">cscale-antiring=0.7</span><br><span class="line">dither-depth=auto</span><br><span class="line">correct-downscaling=yes</span><br><span class="line">sigmoid-upscaling=yes</span><br><span class="line">deband=yes</span><br><span class="line">[mid-quality]</span><br><span class="line">profile-desc=cond:(is_laptop() and not on_battery() and get(&#x27;width&#x27;, math.huge) &lt; 1920) or (is_desktop() and get(&#x27;width&#x27;, math.huge) &gt;= 3840)</span><br><span class="line">scale=spline36</span><br><span class="line">cscale=bilinear</span><br><span class="line">dscale=mitchell</span><br><span class="line">scale-antiring=1.0</span><br><span class="line">cscale-antiring=1.0</span><br><span class="line">dither-depth=auto</span><br><span class="line">correct-downscaling=yes</span><br><span class="line">sigmoid-upscaling=yes</span><br><span class="line">deband=yes</span><br><span class="line">[low-quality]</span><br><span class="line">profile-desc=cond:is_laptop() and (on_battery() or get(&#x27;width&#x27;, math.huge) &gt;= 1920)</span><br><span class="line">scale=bilinear</span><br><span class="line">cscale=bilinear</span><br><span class="line">dscale=bilinear</span><br><span class="line">scale-antiring=0.0</span><br><span class="line">cscale-antiring=0.0</span><br><span class="line">dither-depth=no</span><br><span class="line">correct-downscaling=no</span><br><span class="line">sigmoid-upscaling=no</span><br><span class="line">deband=no</span><br><span class="line">[60FPS]</span><br><span class="line">profile-desc=cond:is_laptop() and get(&#x27;container-fps&#x27;, 0) &gt;= 59</span><br><span class="line">scale=bilinear</span><br><span class="line">cscale=bilinear</span><br><span class="line">[4K]</span><br><span class="line">profile-desc=cond:get(&#x27;width&#x27;, -math.huge) &gt;= 3840</span><br><span class="line">vd-lavc-threads=32</span><br><span class="line">[4K-inverted]</span><br><span class="line">profile-desc=cond:get(&#x27;width&#x27;, -math.huge) &lt; 3840</span><br><span class="line">vd-lavc-threads=0</span><br><span class="line">[default]</span><br><span class="line">###################################</span><br><span class="line"># Protocol Specific Configuration #</span><br><span class="line">###################################</span><br><span class="line">[protocol.https]</span><br><span class="line">#cache=yes</span><br><span class="line">#cache-default=500000                    # size in KB</span><br><span class="line">#cache-backbuffer=250000                 # size in KB</span><br><span class="line">cache-secs=100                          # how many seconds of audio/video to prefetch</span><br><span class="line">user-agent=&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0&#x27;</span><br><span class="line">[protocol.http]</span><br><span class="line">#cache=yes</span><br><span class="line">#cache-default=500000                    # size in KB</span><br><span class="line">#cache-backbuffer=250000                 # size in KB</span><br><span class="line">cache-secs=100                          # how many seconds of audio/video to prefetch</span><br><span class="line">user-agent=&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0&#x27;</span><br><span class="line">[extension.gif]</span><br><span class="line">cache=no</span><br><span class="line">no-pause</span><br><span class="line">loop-file=yes</span><br><span class="line">[extension.webm]</span><br><span class="line">#cache=no</span><br><span class="line">#no-pause</span><br><span class="line">#loop-file=yes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要安装字体：NotoSansCJKsc-Medium.otf.zip</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Jellyfin</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript_DOM_编程艺术</title>
    <url>/2017/08/23/JavaScript-DOM-%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="1、JavaScript简史"><a href="#1、JavaScript简史" class="headerlink" title="1、JavaScript简史"></a>1、JavaScript简史</h1><div class="note success"><ul>
<li>JavaScript的起源</li>
<li>浏览器战争</li>
<li>DOM的演变史</li>
</ul>
</div>
<h2 id="1-1、JavaScript的起源"><a href="#1-1、JavaScript的起源" class="headerlink" title="1.1、JavaScript的起源"></a>1.1、JavaScript的起源</h2><p>JavaScript是Netscape公司与Sun公司合作开发的。在JavaScript出现之前，WEB浏览器不过是一种能够显示超文本文档的简单的软件。而在JavaScript出现之后，网页的内容不再局限于枯燥的文本，它们的可交互性得到了显著的改善。JavaScript的第一个版本，即JavaScript 1.0版本，出现在1995年推出的Netscape Navigator 2浏览器中。</p>
<span id="more"></span>
<h2 id="1-2、DOM"><a href="#1-2、DOM" class="headerlink" title="1.2、DOM"></a>1.2、DOM</h2><p>什么是DOM？简单地说，DOM是一套对文档的内容进行抽象和概念化的方法。<br>&amp;emsp;&amp;emsp;在1998年，W3C发布了第一级的DOM规范。这个规范允许访问和操作HTML页面中的每一个单独的元素。所有的浏览器都执行了这个标准，因此，DOM的兼容性问题也难觅踪影了。DOM可被JavaScript用来读取、改变HTMl、XHTML以及XML文档。DOM被分为不同的部分（核心、XML及HTML）和级别（DOM Level 1&#x2F;2&#x2F;3）</p>
<h2 id="1-3、浏览器战争"><a href="#1-3、浏览器战争" class="headerlink" title="1.3、浏览器战争"></a>1.3、浏览器战争</h2><p>Netscape Navigator 4 发布于1997年6月，IE4发布于同年10月。这两种浏览器都对它们的早期版本进行了许多改进，大幅扩展了DOM，使能够通过JavaScript完成的功能大大增加。而网页设计人员也开始接触到一个新名词：DHTML</p>
<h3 id="1-3-1、DHTML"><a href="#1-3-1、DHTML" class="headerlink" title="1.3.1、DHTML"></a>1.3.1、DHTML</h3><p>DHTML是“Dynamic HTML”(动态HTML)的简称。DHTML并不是一项新技术，而是描述HTML、CSS和JavaScript技术组合的术语。DHTML背后的含义是：</p>
<ul>
<li>利用HTML把网页标记为各种元素</li>
<li>利用CSS调置元素样式和它们的显示位置</li>
<li>利用JavaScript实时地操控页面和改变样式</li>
</ul>
<p>不幸的是，NN4和IE4浏览器使用的是两种不兼容的DOM。换句话说，虽然浏览器制造商的目标一样，但他们在解决DOM问题时采用的办法却完全不同。</p>
<h3 id="1-3-2、浏览器之间的冲突"><a href="#1-3-2、浏览器之间的冲突" class="headerlink" title="1.3.2、浏览器之间的冲突"></a>1.3.2、浏览器之间的冲突</h3><p>Netscape公司的DOM使用了专有元素，这些元素称为层（layer）。层有唯一的ID，JavaScript代码需要像下面这样引用它们：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.layers[&#x27;myelement&#x27;]</span><br></pre></td></tr></table></figure>
<p>而在微软公司的DOM中这个元素必须像下面这样的引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.all[&#x27;myelement&#x27;]</span><br></pre></td></tr></table></figure>
<p>这两种DOM的差异并不止这一点。假设你想找出myelement元素的left位置并把它赋值给变量xpos，那么在NN4浏览器里必须这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xpos = document.layers[&#x27;myelement&#x27;].left;</span><br></pre></td></tr></table></figure>
<p>而在IE4浏览器中，需要使用如下所示的语句才能完成同样的工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xpos = document.all[&#x27;myelement&#x27;].leftpos;</span><br></pre></td></tr></table></figure>
<p>这就导致了一种很可笑的局面：程序员在编写DOM脚本代码时必须知道它们将运行在哪种浏览器环境里，所以在实际工作中，许多脚本都不得不编写两次，一次为NN4。另一次为IE。同时，为了确保能够正确地向不同的浏览器提供与之相应的脚本，程序员还必须编写一些代码去探查在客户端运行的浏览器到底是哪一种。<br>&amp;emsp;&amp;emsp;DHTML打开了一个充满机会的新世界，但想要进入其中的人们却发现这是个充满苦难的世界。因此，没多久DHTML就从一个大热门变成一个人们不愿提起的名词，而对这种技术的评价也很快地变成了“宣传噱头”和“难以实现”。</p>
<h2 id="1-4、制定标准"><a href="#1-4、制定标准" class="headerlink" title="1.4、制定标准"></a>1.4、制定标准</h2><p>就在浏览器制造商以DOM为武器展开营销大战的同时，W3C不事声张地结合大家的优点推出了一个标准化的DOM。令人欣慰的是，Netscape、微软和其他一些浏览器制造商们还能抛开彼此的敌意而与W3C携手制定新的标准，并于1998年10月完成了“第1级DOM”（DOM level 1）<br>&amp;emsp;&amp;emsp;回到刚才的例子，我们已经用<code>&lt;div&gt;</code>标签定义了一个ID为myelement的页面元素，现在需要找出它的left位置并把这个值保存到变量xpos中。下面是使用新的标准化DOM时需要用到的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xpos = document.getElementByID(&#x27;myelement&#x27;).style.left</span><br></pre></td></tr></table></figure>
<p>乍看起来，这与刚才那两种非标准化的专有DOM相比并没有明显的改进。但事实上，标准化的DOM有着非常远大的抱负。<br>&amp;emsp;&amp;emsp;浏览器制造商们感兴趣的只不过是通过JavaScript操控网页的具体方法，但W3C推出的标准化DOM却可以让任何一种程序设计语言对使用任何一种标记语言编写出来的任何一份文档进行操控。</p>
<h3 id="1-4-1、浏览器以外的考虑"><a href="#1-4-1、浏览器以外的考虑" class="headerlink" title="1.4.1、浏览器以外的考虑"></a>1.4.1、浏览器以外的考虑</h3><p>DOM是一种API（应用编程接口）。简单地说，API就是一组已经得到有关各方共同认可的基本约定。在现实世界中，相当于API的例子包括（但不限于）摩尔斯码、国际时区、化学元素周期表。以上这些都是不同学科领域中的标准，它们使得人们能够更方便地交流与合作。如果没有一个统一的标准，事情往往会演变成一场灾难。别忘了，因混淆制度量衡与公制度量衡至少导致过一次火星探测任务的失败。<br>&amp;emsp;&amp;emsp;在软件编程领域中，虽然存在着多种不同的语言，但很多任务却是相同或相似的。这也正是人们需要API原因。一旦掌握了某个标准，就可以把它应用在许多不同的环境中。虽然语法会因为使用的程序设计语言而有所变化，但这些约定却总是保持不变的。<br>&amp;emsp;&amp;emsp;因此，虽然本书的重点是教会你如何通过JavaScript使用DOM，当你需要使用诸如PHP或Python之类的程序设计语言去解析XML文档的时候，你获得的DOM新知识将会有很大的帮助。<br>&amp;emsp;&amp;emsp;W3C对DOM的定义是：“一个与系统平台和编程语言无关的接口，程序和脚本可以通过这个接口动态地访问和修改文档的内容、结构和样式。”W3C推出的标准化DOM，在独立性和适用范围等诸多方面，都远远超出了各自为战的浏览器制造商们推出的各种专有DOM。</p>
<h3 id="1-4-2、浏览器战争的结局"><a href="#1-4-2、浏览器战争的结局" class="headerlink" title="1.4.2、浏览器战争的结局"></a>1.4.2、浏览器战争的结局</h3><p>我们知道，浏览器市场份额大战中微软公司战胜了Netscape，具有讽刺意味的是，专有DOM和HTML标记对这个最终结果几乎没有产生影响。IE浏览器注定能击败其他对手，不过是因为所有运行Windows操作系统的个人电脑都预装了它。<br>&amp;emsp;&amp;emsp;受浏览器战争影响最重的人群是那些网站设计人员。跨浏览器开发曾经是他们的噩梦。除了刚才提到的那引些在JavaScript实现方面的差异之外，Netscape Navigator和IE这两种浏览器在对CSS的支持方面也有许多非常不同的地方。而编写那些可以同时支持这两种浏览器的样式表和脚本的工作也成了一种黑色的艺术。<br>&amp;emsp;&amp;emsp;浏览器制造商的自私姿态遭到人们的激烈反对，一个名为Web标准计划（简称WaSP，<a href="http://webstandards.org/">http://webstandards.org/</a> ）的小组应运而生。WaSP小组采取的第一个行动就是，鼓励浏览器制造商们采用W3C制定和推荐和各项标准，也就是在浏览器制造商们的帮助下得以起草和完善的那些标准。<br>&amp;emsp;&amp;emsp;或者是因为来自WaSP小组的压力，又或许是因为企业的内部决策，下一代浏览器产品对WEB标准的支持得到了极大的改善。</p>
<h3 id="1-4-3、崭新的起点"><a href="#1-4-3、崭新的起点" class="headerlink" title="1.4.3、崭新的起点"></a>1.4.3、崭新的起点</h3><p>早期浏览器大战至今，浏览器市场已经发生了巨大的变化，而且到了今天，这一切也几乎每天都变化。有的浏览器，比如Netscape Navigator，差不多已经从人们的视野中消失了，而新一代浏览器则陆续登台亮相。<br>&amp;emsp;&amp;emsp;苹果公司在2003年首次发布了它的Safari浏览器（基于WebKit），它从一开始就坚定不移地遵循DOM标准。今天，包括firefox、Chrome、Opera和IE，以及一些基于WebKit的其他浏览器都对DOM有着良好的支持。很多最潮的智能手机浏览器都在使用WebKit渲染引擎，推动着手持浏览器开发不断向前，让手机上网的体验甚至好过了使用某些桌面浏览器。</p>
<div class="note danger"><p>注意：WebKit( <a href="http://webkit.org/">http://webkit.org</a> )是Safari和Chrome采用的一个开源Web浏览器引擎。以WebKit和Gecko（ Firefox的核心，<a href="https://developer.mozilla.org/en/Gecko">https://developer.mozilla.org/en/Gecko</a> ）为代表的开源引擎，在促进微软的Trident（IE核心）等专有浏览器引擎逐步向WEB标准靠拢方面起到特别积极的作用。</p>
</div>
<p>&amp;emsp;&amp;emsp;今天，几乎所有的浏览器都内置了对DOM的支持。20世纪90年代后期的浏览器大战和硝烟已经散尽。现在的浏览器厂商无一不在争先恐后地实现最新规范。我们已经目睹了由异步数据传输技术（Ajax）所引发的学习DOM脚本编程的热潮，而HTML5 DOM的众多新特性，怎能不让人对Web的未来浮想联翩？HTML5极大的改进了标记的语义，让我们通过<code>audio</code>和<code>video</code>得以控制各种媒体，<code>canvas</code>元素具备了完善的绘图能力，浏览器本地存储超越了<code>cookie</code>限制，更有内置的拖放支持，等等。<br>&amp;emsp;&amp;emsp;WEB设计师的日子已经今非昔比。尽管还没有一款浏览器完美无瑕地实现W3C DOM，但所有现代浏览器对DOM特性的覆盖率都基本达到了95%，而且每款浏览器都几乎会在第一时间实现最新的特性。这意味着什么？意味着大量的任务都不必依靠分支代码了。以前为了探查浏览器，我们不得不编写大量分支判断脚本，现在，终于可以实现“编写一次，随处运行”的梦想了。只要遵循DOM标准，就可以放心大胆地去做，因为你的脚本无论在哪里都不会遇到问题。</p>
<h1 id="2、JavaScript语法"><a href="#2、JavaScript语法" class="headerlink" title="2、JavaScript语法"></a>2、JavaScript语法</h1><div class="note success"><ul>
<li>语句</li>
<li>变量和数组</li>
<li>操作符</li>
<li>条件语句和循环语句</li>
<li>函数与对象</li>
</ul>
</div>

<h2 id="2-1、准备工作"><a href="#2-1、准备工作" class="headerlink" title="2.1、准备工作"></a>2.1、准备工作</h2><p>编写JavaScript脚本不需要任何特殊的软件，一个普通的文本编辑器和一个WEB浏览器就足够了。用JavaScript编写的代码必须通过<code>HTML/XHTML</code>文档才能执行。有两种方式可以做到这点。第一种方式是将JavaScript代码放到文档<code>&lt;head&gt;</code>标签中的<code>&lt;script&gt;</code>标签之间：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    JavaScript goes here...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  Mark-up goes here....</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一种更好的方式是把JavaScript代码存为一个扩展名为.js的独立文件。典型的作法是在文档的<code>&lt;head&gt;</code>部分放一个<code>&lt;script&gt;</code>标签，并把它的src属性指向该文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;file.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  Mark-up goes here....</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但最好的做法是把<code>&lt;script&gt;</code>标签放到HTML文档的最后，<code>&lt;/body&gt;</code>标签之前：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Mark-up goes here......</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;file.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note danger"><p>注意：前面例子中的<code>&lt;script&gt;</code>标签没有包含传统的<code>type=&quot;text/java script&quot; </code> 属性。因为脚本默认是JavaScript，所以没必要指定这个属性。</p>
</div>
<p>如果打算实践一下本章中的例子，用一个文本编辑器创建两个文件。先创建一个简单的HTML或XHTML文件，保存为诸如test.html之类的名称。这个文件一定要包含一个<code>&lt;script&gt;</code>标签，这个标签的src属性设置成你创建的第二个文件的名字，比如example.js。你的test.html文件应该包含如下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Just a test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以把本单中的任何一个示例复制到你的example.js文件中。虽说那些示例没有什么特别令人激动的地方，但它们可以把有关的语法演示得明明白白。<br>&amp;emsp;&amp;emsp;在本书后面的单节里，我们将演示如何使用JavaScript改变文档的行为和内容。但在本章里，我们只使用一个简单的对话框来显示消息。<br>&amp;emsp;&amp;emsp;如果改变了example.js文件的内容，只需在WEB浏览器中重新载入test.html文档即可看到效果。WEB浏览器会立刻解释并执行你的JavaScript代码。<br>&amp;emsp;&amp;emsp;程序设计语言分为解释型和编译型两大类。Java或C++等语言需要一个编译器（compiler）。编译器是一种程序，能够把用JAVA等高级语言编写出来的源代码翻译为直接在计算机上执行的文件。<br>&amp;emsp;&amp;emsp;解释型程序设计语言不需要编译器–它们仅需要解释器。对于JavaScript语言，在互联网环境下，WEB浏览器负责完成有关的解释和执行工作。浏览器中的JavaScript解释器将直接读入源代码并执行。浏览器中如果没有解释器，JavaScript代码就无法执行。<br>&amp;emsp;&amp;emsp;用编译型语言编写的代码有错误，这些错误在代码编译阶段就能被发现。而解释型语言代码中的错误只能等到解释器执行到有关代码时才能被发现。<br>&amp;emsp;&amp;emsp;与解释型语言相比，编译型语言往往速度更快，可移值性更好，但它们的学习曲线也往往相当陡峭。<br>&amp;emsp;&amp;emsp;JavaScript的优点之一就是相当容易入门，但千万不要因此小看JavaScript，其实它能完成许多相当复杂的编程任务。不过，本章主要介绍它最基本的语法和用法。</p>
<h2 id="2-2、语法"><a href="#2-2、语法" class="headerlink" title="2.2、语法"></a>2.2、语法</h2><p>英语是一种解释型语言。在阅读和处理我们用英语写出来的文字时，你就相当于一个英语解释器。只要遵守英语的语法规则，我们想表达的意思就可以被正确地解读。这些语言结构方面的各有项规则，我这就称之为“语法”。如同书面的人类语言，每种程序设计语言也都有自己的语法。JavaScript的语法与Java和C++语言的语法非常相似。</p>
<h3 id="2-2-1、语句"><a href="#2-2-1、语句" class="headerlink" title="2.2.1、语句"></a>2.2.1、语句</h3><p>用JavaScript编写的脚本，与其他语言编写出来的脚本一样，都由一系统指令构成，这些指令叫做语句（statement）。只有按照正确的语法编写出来的语句才能得到正确的解释。JavaScript语句与英语中的句子很上似。它们是构成任何一个脚本的基本单位。英语语法要求每个句子必须以一个大写字母开头、以一个句号结尾。JavaScript在这个方面的要求不那么严格，程序员只需简单地把<b>各条语句放在不同的行上</b>就可以分隔它们。如果你想把<b>多条语句放在同一行上，就必须像下面这样用分号来分隔它们</b>。我们建议在每条<b>语句的末尾都加上一个分号，这是一种良好的编程习惯</b>。这样做让代码更容易阅读，让每条语句独占一行的做法能更容易跟踪JavaScript脚本的执行顺序。</p>
<h3 id="2-2-2、注释"><a href="#2-2-2、注释" class="headerlink" title="2.2.2、注释"></a>2.2.2、注释</h3><p>有多种方式可以在JavaScript中插入注释</p>
<ol>
<li><code>//</code> 行注释</li>
<li><code>/*  ......... */</code> 多行注释</li>
<li><code>&lt;!-- ....... --&gt;</code> HTML风格注释，<b>需要注意的是，HTML允许上面这样的注释跨越多个行，但JavaScript要坟这种注释的每行都必须在开头加上<code>&lt;!--</code>来作为标志</b>，因为JavaScript在处理这种风格的注释时与HTML处理方法不同，为避免发生混淆，最好不要在JavaScript脚本看使用这种风格的注释。建议使用<code>//</code>来注释单行，用<code>/*</code>注释多行。</li>
</ol>
<h3 id="2-2-3、变量"><a href="#2-2-3、变量" class="headerlink" title="2.2.3、变量"></a>2.2.3、变量</h3><p>JavaScript允许程序员直接对变量赋值而无需事先声明。这在许多程序设计语言中是不允许的。有很多语言要求在使用任何变量之前必须先对它做出声明（declare）。在JavaScript脚本中，如果程序员在对某个变量赋值之前末声明，赋值操作将自动声明该变量。虽然JavaScript没有强制要求程序员必须提前声明变量，但提前声明变量是一种良好的编程习惯。下面的语句对变量mood和age做出了声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mood;</span><br><span class="line"><span class="keyword">var</span> age;</span><br><span class="line"><span class="comment">//不必单独声明每个变量，也可以用一条语句一次声明多个变量</span></span><br><span class="line"><span class="keyword">var</span> mood,age</span><br><span class="line"><span class="comment">//你甚至可以一石两鸟：把声明变量和对该变量赋值一次完成</span></span><br><span class="line"><span class="keyword">var</span> mood = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">33</span>;</span><br><span class="line"><span class="comment">//甚至还可以这样</span></span><br><span class="line"><span class="keyword">var</span> mood = <span class="string">&quot;happy&quot;</span> , age = <span class="number">33</span>;</span><br></pre></td></tr></table></figure>
<p>在JavaScript语言里，<b>变量和其他语法元素的名字是区分字母大小写的。JavaScript语法不允许变量名中包含空格或标点符号（美元符号除外<code>$</code>）</b>。JavaScript变量名允许包含字母、数字、美元符号和下划线（但第一个字符不允许是数字）。为了让比较长的变量名更容易阅读，可以在变量名中适当位置插入下划线，就像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> my_mood = <span class="string">&quot;happy&quot;</span></span><br></pre></td></tr></table></figure>
<p>另一种方式就使用驼峰格式（camel case），删除中间的下划线，后面的每个新单词改用大写字母开头：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMood = <span class="string">&quot;happy&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-4、数据类型"><a href="#2-2-4、数据类型" class="headerlink" title="2.2.4、数据类型"></a>2.2.4、数据类型</h3><p>变量mood的值是一个字符串，age的值则是一个数。虽然它们是两种不同类型的数据，但在JavaScript中对这两个变量进行声明和赋值的语法却是完全一样。有此其他的语言要求在声明变量的同时还必须同时声明变量的数据类型，这种做法称为类型声明（typing）。<br>&amp;emsp;&amp;emsp;必须明确类型声明语言称之为强类型语言（strongly typed），JavaScript不需要进行类型声明，因此它是一种弱类型语言（weakly typed）。这意味着程序员可以在任何阶段改变变量的数据类型。<br>&amp;emsp;&amp;emsp;接下来，我们一起来复习一下JavaScript中最重要的几种数据类型。</p>
<h4 id="2-2-4-1、字符串"><a href="#2-2-4-1、字符串" class="headerlink" title="2.2.4.1、字符串"></a>2.2.4.1、字符串</h4><p>字符串由零个或多个字符构成。字符包括（但不限于）字母、数字、标点符号和空格。字符串必须包在引号里，单引号或双引号都可以。下面这两条语句含义完全相同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mood = <span class="string">&#x27;happy&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> mood = <span class="string">&quot;happy&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>你可以随意选用引号，但最好是根据字符串所包含的字符来选择。如果字符串包含双引号，就把整个字符串放在单引号里；如果字符串包含单引号，就把整个字符吕放在双引号里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mood = <span class="string">&quot;don&#x27;t ask&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果想在上面这条语句使用单引号，就必须保证字母“n”和“t”之间的单引号能被当成这个字符串的一部分。这种情况下这个单引号需要被看做一个普通字符，而不是这个字符串的结束标志。这种情况我们需要对这个字符进行转义（escaping）。在JavaScript里用反斜线对字符进行转义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mood = <span class="string">&#x27;don\&#x27;t ask&#x27;</span></span><br></pre></td></tr></table></figure>
<p>类似的，如果想用双引号来包住一个本身就包含双引号的字符串，就必须用反斜线对字符串中的双引号进行转义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> height = <span class="string">&quot;about 5 &#x27;10\&quot; tall&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>实际上这些反斜线并不是字符串的一部分。你可以自己去验证一下：把这段代码添加到example.js文件中，然后重新加载test.html文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> height = <span class="string">&quot;about 5&#x27;10\&quot;tall&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(height);</span><br></pre></td></tr></table></figure>
<p>执行结果如下[图2-3]：<br><img src="2-3.png" style="margin : auto;"  width="50%" height="50%" title="[图2-3]"><br>&amp;emsp;&amp;emsp;我个人比较喜欢用双引号来包住字符串。作为一个好的编程习惯，不管选择用双引号还是单引号，请在整个脚本中保持一致。如果在同一个脚本中一会使用双引号，一会又使用单引号，代码就很快就会变得难以阅读和理解。</p>
<h4 id="2-2-4-2、数值"><a href="#2-2-4-2、数值" class="headerlink" title="2.2.4.2、数值"></a>2.2.4.2、数值</h4><p>如果想给一个变量赋一个数值，不用限定它必须是一个整数。JavaScript允许使用带小数点的数值，并且允许任意位小数，这样的数称为浮点数（floating-point number）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">33.25</span>;</span><br><span class="line"><span class="comment">//也可以使用负数。在有关数值的前面加上一个减号（-）表示它是一个负数：</span></span><br><span class="line"><span class="keyword">var</span> temperature = -<span class="number">20</span></span><br><span class="line"><span class="comment">//JavaScript也支持负数浮点数：</span></span><br><span class="line"><span class="keyword">var</span> temperature = -<span class="number">20.33333333</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-3、布尔值"><a href="#2-2-4-3、布尔值" class="headerlink" title="2.2.4.3、布尔值"></a>2.2.4.3、布尔值</h4><p>另一种重要的数据类型是布尔（boolean）类型。<br>布尔数据只有两个可选值–true或false。假设需要这样一个变量：如果我正在睡觉，这个变量将存储一个值；如果我没有睡觉，这个变量将存储另一个值。可以用字符串数据类型把变量赋值为“sleeping”或“not sleeping”，但使用布尔数据类型显然是一个更好的选择：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sleeping = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>从某种意义上讲，为计算机设计程序就是与布尔值打交道。作为最基本的事实，所有的电子电路只能识别和使用布尔数据：电路中有电流或是没有电流。不管是使用术语true和false、yes和no或者1和0，重要的是只能取两种可取值的一种。<br>&amp;emsp;&amp;emsp;<b>布尔值不是字符串，千万不要把布尔值用引号括起来。布尔值false与字符串值”false”是两码事！！</b><br>&amp;emsp;&amp;emsp;下面这条语句将把变量married设置为布尔值true：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> married = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>下面这条语句把变量married设置为字符串”true”：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> married = <span class="string">&quot;true&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-4、数组"><a href="#2-2-4-4、数组" class="headerlink" title="2.2.4.4、数组"></a>2.2.4.4、数组</h4><p>字符串、数值和布尔值都是标量（scalar）。如果某个变量是标量，它在任意时刻就只能有一个值。如果想用一个变量业存储一组值，就需要使用数组（array）。<br>&amp;emsp;&amp;emsp;数组是指用一个变量表示一个值的集合，集合中的每个值都是这个数组的一个元素（emement）。例如，我们可以用名为beatles的变量来保存Beatles乐队全体四位成员的姓名。<br>&amp;emsp;&amp;emsp;在JavaScript中，数组可以用关键字Array声明。声明数组的同时还可以指定数组初始元素个数，也就是这个数组的长度（length）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> beatles = <span class="title class_">Array</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>有时，我们无法预知某个数组有多少个元素。没有关系，JavaScript根本不要求在声明数组时必须给出元素个数，我们完全可以在声明数组时不给出元素的个数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> beatles = <span class="title class_">Array</span>();</span><br></pre></td></tr></table></figure>
<p>向数组中添加元素的操作称为填充（populating）。在填充数组时，不仅需要给出新元素的值，还需要给出新元素在数组中的存放位置，这个位置就是这个元素的下标（index）。数组里一个元素一个下标。下标必须用方括号括起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array[index] = element;</span><br></pre></td></tr></table></figure>
<p>现在来填充刚才声明的beatles数组，我们按照Beatles乐队成员的传统顺序（即John、Paul、George和Ringo）进行填充。第一个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beatles[<span class="number">0</span>] = <span class="string">&quot;John&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>用0而不是1作为第一个下标多少会让人感到有些不习惯，这是JavaScript世界里的一条规则，所以我们只能这么做。人们很容易忘记这一点，很多程序员新手在刚接触数组时经常在这个问题上犯错误。下面是声明和填充beatles数组的全过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> beatles = <span class="title class_">Array</span>(<span class="number">4</span>);</span><br><span class="line">beatles[<span class="number">0</span>] = <span class="string">&quot;john&quot;</span>;</span><br><span class="line">beatles[<span class="number">1</span>] = <span class="string">&quot;Paul&quot;</span>;</span><br><span class="line">beatles[<span class="number">2</span>] = <span class="string">&quot;George&quot;</span>;</span><br><span class="line">beatles[<span class="number">3</span>] = <span class="string">&quot;Ringo&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>我们现在可以在脚本中通过下标值“2”（beatles[2]）来获取元素“George”了。请注意，beatles数组的长度是4，但它最后一个元素的下标却是3。因为数组下标是从0开始计数的，你或许需要一些时间才能习惯这一事实。<br>&amp;emsp;&amp;emsp;像上面这样填充数组未免有些麻烦。有一种相对简单的方式：在声明数组的同时对它进行填充。这种方式要求用逗号把各个元素隔开：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> beatles = <span class="title class_">Array</span>(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;Paul&quot;</span>,<span class="string">&quot;George&quot;</span>,<span class="string">&quot;Ringo&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面这条语句会为每个元素自动分配一个下标：第一个下标是0，第二个是1，依次类推。因此，beatles[2]仍将对应于取值为“George”的元素。<br>&amp;emsp;&amp;emsp;我们甚至用不着明确地表明我们是在创建数组。事实上，只需用一对方括号把各个元素的初始值括起来就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> beatles = [<span class="string">&quot;John&quot;</span>,<span class="string">&quot;Paul&quot;</span>,<span class="string">&quot;George&quot;</span>,<span class="string">&quot;Ringo&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>数组元素不必非得是字符串。可以把一些布尔值存入一个数组，还可以把一组数值存入一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> years = [<span class="number">1979</span>,<span class="number">1980</span>,<span class="number">1981</span>,<span class="number">1982</span>];</span><br></pre></td></tr></table></figure>
<p>甚至可以把这3种数据类型混在一起存入一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lennon = [<span class="string">&quot;John&quot;</span>,<span class="number">1940</span>,<span class="literal">false</span>];</span><br></pre></td></tr></table></figure>
<p>数组元素还可以是变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">beatles[<span class="number">0</span>] = name;</span><br></pre></td></tr></table></figure>
<p>这将把beatles数组的第一个元素赋值为“John”。数组元素的值还可以是另一个数组的元素。下面两条语句将把beatles数组的第二元素赋值为“Paul”：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;Ringo&quot;</span>,<span class="string">&quot;John&quot;</span>,<span class="string">&quot;George&quot;</span>,<span class="string">&quot;Paul&quot;</span>];</span><br><span class="line">beatles[<span class="number">1</span>] = names[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>事实上，数组还可以包含其他的数组！数组中的任何一个元素都可以把一个数组作为它的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lennon = [<span class="string">&quot;John&quot;</span>,<span class="number">1940</span>,<span class="literal">false</span>];</span><br><span class="line"><span class="keyword">var</span> beatles = [];</span><br><span class="line">beatles[<span class="number">0</span>] = lennon;</span><br></pre></td></tr></table></figure>
<p>现在，beatles数组的第一个元素的值是另外一个数组。要想获得那个数组里的某个元素的值，需要使用更多的方括号。<code>beatles[0][0]</code>的值是”John”，<code>beatles[0][1]</code>的值是1940，<code>beatles[0][2]</code>的值是false。<br>&amp;emsp;&amp;emsp;这是一种功能相当强大的存储和获取信息的方式，但如果不得不记住第个下标数字的话（尤其是需要从零开始数的时候），编程工作将是一种非常痛苦和麻烦的体验。幸好还有几种方法可以填充数组。首先看看一种更可读的填充数组的方式，然后介绍存放数据的首选方式：将数据保存为对象。</p>
<h5 id="2-2-4-4-1、关联数组"><a href="#2-2-4-4-1、关联数组" class="headerlink" title="2.2.4.4.1、关联数组"></a>2.2.4.4.1、关联数组</h5><p>beatles数组是传统数组的典型例子：每个元素的下标是一个数字，每增加一个元素，这个数字就依次增加1。第一个元素的下标是0，第二个元素的下标是1，依次类推。<br>&amp;emsp;&amp;emsp;如果在填充数组时只给出了元素的值，这个数组就将是一个传统数组，它的各个元素的下标将被自动创建和刷新。<br>&amp;emsp;&amp;emsp;可以通过在填充数组时为每个新元素明确地给出下标来改变这种默认的行为。在为新元素给出下标时，不必局限于使用整数数字。你可以用字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lennon = <span class="title class_">Array</span>();</span><br><span class="line">lennon[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">lennon[<span class="string">&quot;year&quot;</span>] = <span class="number">1940</span>;</span><br><span class="line">lennon[<span class="string">&quot;living&quot;</span>] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>这样的数组叫做关联数组。由于可以使用字符串来代替数字值，因而代码更具有可读性。但是，这种用法并不是一个好习惯，不推荐大家使用。本质上，在创建关联数组时，你创建的是Array对象的属性。在JavaScript中，所有的变量实际上都是某种类型的对象。比如，一个布尔值就是一个Boolean类型的对象，一个数组就是一个Array类型的对象。在上面这个例子中，你实际上是给lennon数组添加了name、year和living三个属性。理想情况下，你不应该修改Array对象的属性，而应该使用通用的对象（Object）。</p>
<h4 id="2-2-4-5、对象"><a href="#2-2-4-5、对象" class="headerlink" title="2.2.4.5、对象"></a>2.2.4.5、对象</h4><p>与数组类似，对象也是使用一个名字表示一组值。对象的每个值都是对象的一个属性。例如，前一节的lennon数组也可以创建成下面这个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lennon = <span class="title class_">Object</span>();</span><br><span class="line">lennon.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">lennon.<span class="property">year</span> = <span class="number">1940</span>;</span><br><span class="line">lennon.<span class="property">living</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>与使用Array类似，创建对象使用Object关键字。它不使用方括号和下标来获取元素，而是像任何JavaScript对象一样，使用点号来获取属性。创建对象还有一种更简洁的语法，即花括号语法：<br><code>&#123;propertyName:value,propertyName:value&#125;</code><br>&amp;emsp;&amp;emsp;比如，lennon对象也可以写成下面这样：<br><code>var lennon = &#123;name:&quot;John&quot;,year:1940,living:false&#125;;</code><br>&amp;emsp;&amp;emsp;属性名与JavaScript变量的命名规则有相同之处，属性值可以是任何JavaScript值，包括其他对象。<br>&amp;emsp;&amp;emsp;用对象来代替传统数组的做法意味着可以通过元素的名字而不是下标数字来引用它们。这大大提高了脚本的可读性。<br>&amp;emsp;&amp;emsp;下面，我们将创建一个新的beatles数组，并用刚才创建的lennon对象来填充它的第一个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> beatles = <span class="title class_">Array</span>();</span><br><span class="line">beatles[<span class="number">0</span>] = lennon;</span><br></pre></td></tr></table></figure>
<p>现在，不需要使用那么多数就可以获得想要的元素。我们不能使用<code>beatles[0][0]</code>而是使用<code>beatles[0].name</code>得到的值”John”。<br>&amp;emsp;&amp;emsp;在此基础上，还可以做进一步的改进：把beatles数组也声明为对象而不是传统数组。这样一来，我们就可以用“drummer”或“bassist”等更有意义且更容易记忆的字符串值–而不是一些枯燥乏味的整数–做为下标去访问这个数组里的元素了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> beatles = &#123;&#125;</span><br><span class="line">beatles.<span class="property">vocalist</span> = lennon;</span><br></pre></td></tr></table></figure>
<p>现在，beatles.vocalist.name的值是“John”，beatles.vocalist.year的值是1940，beatles.vocalist.living值是false。</p>
<h2 id="2-3、操作"><a href="#2-3、操作" class="headerlink" title="2.3、操作"></a>2.3、操作</h2><p>此前给出的示例都非常简单，只是创建了一些不同类型的变量而已。要用JavaScript做一些有用的工作，还需要能够进行计算和处理数据。也就是需要完成一些操作（operation）。</p>
<h3 id="2-3-1、算术操作符"><a href="#2-3-1、算术操作符" class="headerlink" title="2.3.1、算术操作符"></a>2.3.1、算术操作符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面是一个简单的加法操作</span></span><br><span class="line"><span class="number">1</span> + <span class="number">4</span></span><br><span class="line"><span class="comment">//还可以把多种操作组合在一起</span></span><br><span class="line"><span class="number">1</span> + <span class="number">4</span> * <span class="number">5</span></span><br><span class="line"><span class="comment">//为避免产生歧义，可以用括号把不同的操作分隔开来</span></span><br><span class="line"><span class="number">1</span> + (<span class="number">4</span> * <span class="number">5</span>)</span><br><span class="line">(<span class="number">1</span> + <span class="number">4</span>) * <span class="number">5</span></span><br><span class="line"><span class="comment">//变量可以包含操作</span></span><br><span class="line"><span class="keyword">var</span> total = (<span class="number">1</span> + <span class="number">4</span>) * <span class="number">5</span></span><br><span class="line"><span class="comment">//不仅如此，还可以对变量进行操作</span></span><br><span class="line"><span class="keyword">var</span> temp_fahrenheit = <span class="number">95</span>;</span><br><span class="line"><span class="keyword">var</span> temp_celsius = (temp_fahrenheit - <span class="number">32</span>) / <span class="number">1.8</span>;</span><br><span class="line"><span class="comment">//JavaScript还提供了一些非常有用的操作符作为各种常用操作的缩写。例如，如果想给一个数值变量加上1，可以使用如下所示的语句：</span></span><br><span class="line">year = year + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//也可以使用++操作符来达到同样的目的</span></span><br><span class="line">year++;</span><br><span class="line"><span class="comment">//类似地，可以进行减1操作</span></span><br><span class="line">year--;</span><br></pre></td></tr></table></figure>

<h2 id="2-4、条件语句"><a href="#2-4、条件语句" class="headerlink" title="2.4、条件语句"></a>2.4、条件语句</h2><p>在解释脚本时，浏览器将依次执行这个脚本中的各条语句，我们可以在这个脚本中用条件语句来设置一个条件，只有满足了这一条件才能让更多的语句得到执行。最常见的条件语句是if语句，下面是if语句的基本语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  statements;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事实上，if语句中的花括号本身并不是必不可少的。如果if语句中的花括号部分只包含着一条语句的话，那就可以不使用花括号，而且这条if语句的全部内容可以写在同一行上</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="number">2</span>) <span class="title function_">alert</span>(<span class="string">&quot;The world has gone mad!&quot;</span>);</span><br><span class="line"><span class="comment">//if语句可以有一个else子句</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;The world has gone mad!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;All is well with the world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1、比较操作符"><a href="#2-4-1、比较操作符" class="headerlink" title="2.4.1、比较操作符"></a>2.4.1、比较操作符</h3><p>JavaScript还提供了许多几乎只能用在条件语句里的操作符，其中包括诸如大于（&gt;）、小于（&lt;）、大于或等于（&gt;&#x3D;）、小于或等于（&lt;&#x3D;）之类的比较操作符。<br>&amp;emsp;&amp;emsp;如果想比较两个值是否相等，可以使用“等于”比较操作符。这个操作符由两个等号构成（&#x3D;&#x3D;），单个等号（&#x3D;）是用于完成赋值操作的。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> my_mood = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> your_mood = <span class="string">&quot;sad&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (my_mood == your_mood) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;We both feel the same.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;JavaScript还提供了一个用来进行“不等于”比较操作符，它由一个感叹号和一个等号构成（!&#x3D;）</p>
<h3 id="2-4-2、逻辑操作符"><a href="#2-4-2、逻辑操作符" class="headerlink" title="2.4.2、逻辑操作符"></a>2.4.2、逻辑操作符</h3><p>JavaScript允许把条件语句里的操作组合在一起。例如，如果想检查某个变量，不妨假设这个变量的名字是num。逻辑“与”操作符<code>&amp;&amp;</code>，逻辑“或”操作符<code>||</code>，逻辑“非”操作符<code>!</code></p>
<h2 id="2-5、循环语句"><a href="#2-5、循环语句" class="headerlink" title="2.5、循环语句"></a>2.5、循环语句</h2><p>if语句或许是最重要、最有用的条件语句了，它的唯一不足是无法完成重复性的操作。在if语句里，包含在花括号里的代码只能执行一次。如果需要多次执行同一代码块，就必须使用循环语句。<br>&amp;emsp;&amp;emsp;循环语句可以让我们反复多次地执行同一段代码。循环语句分为几种不同的类型，但它们的工作原理几乎一样：只要给定条件仍能得到满足，包含在循环语句里的代码就将重复地执行下去；一旦给条件的求值结果不再是ture，循环也就到此为止。</p>
<h3 id="2-5-1、while循环"><a href="#2-5-1、while循环" class="headerlink" title="2.5.1、while循环"></a>2.5.1、while循环</h3><p>while循环与if语句非常相似，它们的语法几乎完全一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while循环与if语句唯一的区别是：只要给定条件的求值结果是true，包含在花括号里的代码就将反复地执行下去。下面是一个while循环的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">11</span>) &#123;</span><br><span class="line">  alert (count);</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-2、do…while循环"><a href="#2-5-2、do…while循环" class="headerlink" title="2.5.2、do…while循环"></a>2.5.2、do…while循环</h3><p>类似于if语句的情况，while循环的花括号部分所包含的语句有可能不被执行，因为对循环控制条件的求值发生在每次循环开始之前，所以如果循环控制条件的首次求值结果是false，那些代码将一次也不会被执行。<br>&amp;esmp;&amp;esmp;在某些场合，我们希望那些包含在循环语句内部的代码至少执行一次。这时do循环是我们的最佳选择。下面是do循环的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  statements;</span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>
<h3 id="2-5-3、for循环"><a href="#2-5-3、for循环" class="headerlink" title="2.5.3、for循环"></a>2.5.3、for循环</h3><p>用for循环来重复执行一些代码也很方便，它类似于while循环。事实上，for循环只是刚才介绍的while循环的一种变体。如果仔细观察上一小节里的while循环的例子，就会发现它们都可以改写为如下所示的样子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">initialize;</span><br><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  statements;</span><br><span class="line">  increment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而for循还不过是进一步改写为如下所示的紧凑形式而已：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initial condition;test condition;alter condition) &#123;</span><br><span class="line">  statements;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> cont = <span class="number">1</span>; cont &lt; <span class="number">11</span>; count++) &#123;</span><br><span class="line">  alert (count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for循环最常见的用途之一是对某个数组里的全体元素进行遍历处理。这往往需要用到数组的array.length属性，这个属性可以告诉我们在给定数组里的元素的个数。一定要记住数组下标是从0而不是1开始。下面的例子中，数组有4个元素。count变量对于数组中每个元素都是从0开始按1递增。数到4时，测试条件失败，循环终止，3是从数组中检索到的最后一个下标。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> beatles = <span class="title class_">Array</span>(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;Paul&quot;</span>,<span class="string">&quot;George&quot;</span>,<span class="string">&quot;Ringo&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; beatles.<span class="property">length</span>; count++) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(beatles[count]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这段代码，将看到4条alert消息，它们分别对应着Beatles乐队的四位成员。</p>
<h2 id="2-6、函数"><a href="#2-6、函数" class="headerlink" title="2.6、函数"></a>2.6、函数</h2><p>如果需要多次使用同一段代码，可以把它们封装成一个函数。函数（function）就是一组允许在你的代码里随时高用的语句。事实上，每个函数实际上就是一个短小的脚本。<br>&amp;emsp;&amp;emsp;作为一种良好的编程习惯，应该先对函数做出定义再调用它们。下面就是一个简单的示例函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shout</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> beatles = <span class="title class_">Array</span>(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;Pual&quot;</span>,<span class="string">&quot;George&quot;</span>,<span class="string">&quot;Ringo&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span> ; count &lt; beatles.<span class="property">lenght</span> ; count++) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(beatles[count]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数里的循环语句将依次弹出对话框来显示Beatles乐队成员的名字。现在,如果想在自己的脚本里执行这一动作，可以随时使用如下的语句来调用这个函数：<code>shout();</code><br>&amp;emsp;&amp;emsp;每当需要反复做一件事时，都可以利用函数来避免重复键入大量的相同内容。不对，函数的真正威力体现在，你可以把不同的数据传递给它们，而它们将使用这些数据去完成预定的操作。我们把传递给函数的数据称为参数（argument）。定义一个函数的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">name</span>(<span class="params"><span class="variable language_">arguments</span></span>) &#123;</span><br><span class="line">  statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript提供了许多内建函数，在前面多次出现过的alert就是一例。这个函数需要我们提供一个参数，它将弹出一个对话框来显示这个参数的值。<br>&amp;emsp;&amp;emsp;在定义函数时，你可以为它声明任意多个参数，只要用逗号把它们分隔开来就行。在函数的内部，你可以像使用普通变量那样使用它的任何一个参数。<br>&amp;emsp;&amp;emsp;下面是一个需要传递两个参数的函数。如果把两个数值传递给这个函数，这个函数将对它们进行乘法运算：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">num1,num2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> total = num1 * num2;</span><br><span class="line">  <span class="title function_">alert</span>(total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义了这个函数的脚本里，我们可以从任意位置去调用这个函数，如下所示：<code>multiply(10,2);</code><br>&amp;emsp;&amp;emsp;我们还可以创建一个函数并让它返回一个数值、一个字符串、一个数组或一个布尔值。这需要用到return语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">num1,num2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> totle=num1*num2;</span><br><span class="line">  <span class="keyword">return</span> totle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个函数只有一个参数（一个华氏温度值），它将返回一个数值（同一温度的摄氏温度值）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convertToCelsius</span>(<span class="params">temp</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> reult=temp-<span class="number">32</span>;</span><br><span class="line">  result=result/<span class="number">1.8</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的真正价值体现在，我们还可以把它们当做一种数据类型来使用，这意味着可以把一个函数的调用结果赋给一个变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp_fahrenheit=<span class="number">95</span>;</span><br><span class="line"><span class="keyword">var</span> tmp_celsius=<span class="title function_">convertToCelsius</span>(tmp_fahrenheit);</span><br><span class="line"><span class="title function_">alert</span>(temp_celsius);</span><br></pre></td></tr></table></figure>
<p>在这个例子里，变量temp_celsius的值将是35，这个数值由convertToCelsius函数返回。<br>&amp;emsp;&amp;emsp;你一定想了解应该如何命名变量和函数。在命名变量时，我用下划线来分隔各个单词；在命名函数时，我从第二个单词开始把每个单词的第一个字母写成大写形成（也就是所谓的驼峰命名法）。我这么做是为了能够一眼看出哪些名字是变量，哪些名字是函数。与变量的情况一样，JavaScript语言也不允许函数的名字里包含空格。驼峰命名法可以在不违反这一规定的前提下，把变量和函数的名字以一种既简单又明确的方式区分开来。</p>
<h3 id="2-6-1、变量的作用域"><a href="#2-6-1、变量的作用域" class="headerlink" title="2.6.1、变量的作用域"></a>2.6.1、变量的作用域</h3><p>前面讲过，作为一种好的编程习惯，在第一次对某个变量赋值时应该用var对其做出声明。当在函数内部使用变量时，就更应该这么做。<br>&amp;emsp;&amp;emsp;变量既可以是全局的，也可以是局部的。在谈论全局变量和局部变量之间的区别时，我们其实是在讨论变量的作用域（scope）。</p>
<ul>
<li>全局变量（global variable）：可以在脚本中的任何位置被引用。一旦你在某个脚本里声明一个全局变量，就可以从这个脚本中的任何位置–包括函数内部–引用它。全局变量的作用域是整个脚本。</li>
<li>局部变量（local variable）：只存在于声明它的那个函数内部，在那个函数的外部是无法引用它的。局部变量的作用域仅限于某个特定的函数。</li>
</ul>
<p>&amp;emsp;&amp;emsp;因此，我们在函数里既可以使用全局变量，也可以使用局部变量。这很有用，但它也会导致一些问题。如果在一个函数的内部不小心使用了某个全局变量的名字，即使本意是想使用一个局部变量，JavaScript也会认为是在引用那个全局变量。<br>&amp;emsp;&amp;emsp;还好，可以用var关键字明确地为函数变量设定作用域。<br>&amp;emsp;&amp;emsp;如果在某个函数中使用了var，那个变量就将被视为一个局部变量，它只存在于这个函数的上下文中；反之，如果没有使用var，那个变量就被视为一个全局变量，如果脚本里已经存在一个与之同名的全局变量，这个函数就会改变那个全局变量的值。我们来看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">num</span>)&#123;</span><br><span class="line">  total=num*num;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> total=<span class="number">50</span>;</span><br><span class="line"><span class="keyword">var</span> number=<span class="title function_">square</span>(<span class="number">20</span>);</span><br><span class="line"><span class="title function_">alert</span>(total);</span><br></pre></td></tr></table></figure>
<p>这些代码将不可避免地导致全部变量total的值发生变化，如图2-10所示。<br><img src="2-10.png" style="margin : auto;"  width="50%" height="50%" title="[图2-10]"><br>全局变量total的值变成400。我的本意是让square()函数只把它计算出来的平方值返回给变量number，但因为未把这个函数内部的total变量声明为局部变量，这个函数把名字同样是total的那个全局变量的值也改变了。把这个函数写成如下所示的样子才是正确的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">num</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> total=num*num;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，全局变量total变得安全了，再怎么调用square()函数也不会影响到它。<br>&amp;emsp;&amp;emsp;请记住，函数在行为方面应该像一个自给自足的脚本，在定义一个函数时，我们一定要把它内部的变量全都明确地声明为局部变量。如果你总是在函数里使用var关键字来定义变量，就能避免任何形式的二义性隐患。</p>
<h2 id="2-7、对象"><a href="#2-7、对象" class="headerlink" title="2.7、对象"></a>2.7、对象</h2><p>对象（object）是一种非常重要的数据类型，但此前我们还没有认真对待它。对象是自包含的数据集合，包含在对象里的数据可以通过两种形式依问–属性（property）和方法（method）：</p>
<ul>
<li>属性是隶属于某个特定对象的变量</li>
<li>方法是只有某个特定对象才能调用的函数</li>
</ul>
<p>对象就是由一些属性和方法组合在一起而构成的一个数据实体。在JavaScript里，属性和方法都使用“点”语法来访问：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">property</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">method</span>()</span><br></pre></td></tr></table></figure>
<p>你已经见过如何用mood和age等变量来存放诸如“心情”和“年龄”之类的值。如果它们是某个对象的属性–这里不妨假设那个对象的名字是Person，我们就必须使用如下所示的记号来使用它们：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property">mood</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">age</span></span><br></pre></td></tr></table></figure>
<p>假如Person对象还关联着一些诸如walk()和sleep()之类的函数，这些函数就是这个对象的方法，而我们必须使用如下所示的记号来访问它们：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="title function_">walk</span>()</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">sleep</span>()</span><br></pre></td></tr></table></figure>
<p>把这些属性和方法全部集合在一起，我们就得到了一个Person对象。<br>&amp;emsp;&amp;emsp;为了使用Person对象来描述一个特定的人，需要创建一个Person对象的实例（instance）。实例是对象的具体个体。例如，你和我都是人，都可以用Person对象来描述；但你和我是两个不同的个体，很可能有着不同的属性（例如，你和我的处龄可能不一样）。因此，你和我对应首两个不同的Person对象–它们虽然都是Person对象，但它们是两个不同的实例。<br>&amp;emsp;&amp;emsp;为给定对象创建一个新实例需要使用new关键字，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jeremy = <span class="keyword">new</span> <span class="title class_">Person</span>;</span><br></pre></td></tr></table></figure>
<p>上面这条语句将创建出Person对象的一个新实例jeremy。我们就可以像下面这样利用Person对象的属性来检索关于jeremy的信息了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jeremy.<span class="property">age</span></span><br><span class="line">jeremy.<span class="property">mood</span></span><br></pre></td></tr></table></figure>
<p>对明、属性、方法和实例等概念比较抽象，为了让大家对这些概念有一个直观的认识，我在这里用虚构的Person对象作为例子。JavaScript里没有Person对象。我们可以利用JavaScript来创建自己的对象–术语为用户自定义对象（user-defined object）。这是一个相当高级的主题，我们眼下还无需对它做进一步讨论。<br>&amp;emsp;&amp;emsp;在电视上的烹饪节目里，只要镜头一转，厨师就可以端出一盘美味的菜肴并向大家介绍说：“这是我刚刚做好的”。JavaScript与这种节目里的主持人颇有几分相似：它提供了一系列预先定义好的对象，这引起可以拿来就用的对象称为内建对象（native object）。</p>
<h3 id="2-7-1、内建对象"><a href="#2-7-1、内建对象" class="headerlink" title="2.7.1、内建对象"></a>2.7.1、内建对象</h3><p>你其实已经见过一些内建对象了，数组就是其中一种。当我们使用new关键字去初始化一个数组时，其实是在创建一个Array对象的新实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> beatles = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br></pre></td></tr></table></figure>
<p>当需要了解某个数组有多少个元素时，利用Array对象的length属性来获得这一信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beatles.<span class="property">lenght</span>;</span><br></pre></td></tr></table></figure>
<p>Array对象只是诸多JavaScript内建对象中的一种。其他例子包括Math对象和Date对象，它们分别提供了许多非常有用的方法供人们处理数值和日期值。例如，Math对象的round方法可以把十进制数值舍入为一个与之最接近的整数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">7.561</span>;</span><br><span class="line"><span class="keyword">var</span> num=<span class="title class_">Math</span>.<span class="title function_">round</span>(num);</span><br><span class="line"><span class="title function_">alert</span>(num);</span><br></pre></td></tr></table></figure>
<p>Date对胆可以用来存储和检索与特定日期和时间有关的信息。在创建Date对象的新实例时，JavaScript解释器将自动地使用当前日期和时间对它进行初始化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> current_date= <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>
<p>Date对象提供了getDay()、getHours()、getMonth()等一系列方法，以供人们来检索与特定日期有关的各有种信息。例如，getDay()方法可以告诉我们给定日期是星期几：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> today = current_date.<span class="title function_">getDay</span>();</span><br></pre></td></tr></table></figure>
<p>在编写JavaScript脚本时，内建对象可以帮助我们愉快速、简单地完成许多任务。</p>
<h3 id="2-7-2、宿主对象"><a href="#2-7-2、宿主对象" class="headerlink" title="2.7.2、宿主对象"></a>2.7.2、宿主对象</h3><p>除了内建对象，还可以在JavaScript脚本里使用一些已经预先定义好的其他对象。这些对象不是由JavaScript语言本身而是由它的运行环境所提供的。具体到WEB应用，这个环境就是浏览器。由浏览器提供的预定义的对象称为宿主对象（host Object）。<br>&amp;emsp;&amp;emsp;宿主对象包括Form、Image和Element等。我们可以通过这些对象获得关于网页上的表单、图像和各种表单元素等信息。<br>&amp;emsp;&amp;emsp;本书没有收录几个宿主对象的例子。另一种宿主对象也能用来获得网页上的任何一个元素的信息，它就是docment对象。在本书后续的内容里，我们将向大家介绍docment对象的许多属性和方法。</p>
<h1 id="3、DOM"><a href="#3、DOM" class="headerlink" title="3、DOM"></a>3、DOM</h1><div class="note success"><ul>
<li>节点的概念</li>
<li>5个常用的DOM方法：getElementById、getElementsByTagName、getElementsByClassName、getAttribute和setAttribute</li>
</ul>
</div>

<p>终于要与DOM面对面了。本章将介绍DOM，带领大家透过DOM去看世界。</p>
<h2 id="3-1、文档：DOM中的“D”"><a href="#3-1、文档：DOM中的“D”" class="headerlink" title="3.1、文档：DOM中的“D”"></a>3.1、文档：DOM中的“D”</h2><p>如果没有document（文档），DOM也就无从谈起。当创建了一个网页并把它加载到WEB浏览器中时，DOM就在幕后悄然而生。它把你编写的网页文档转换为一个文档对象。<br>&amp;emsp;&amp;emsp;在人类语言中，“对象”这个词的含义往往不那么明确，它几乎可以用来称呼任何一种东西。但在程序设计语言中，“对象”这个词的含义非常明确。</p>
<h2 id="3-2、对象：DOM中的“O”"><a href="#3-2、对象：DOM中的“O”" class="headerlink" title="3.2、对象：DOM中的“O”"></a>3.2、对象：DOM中的“O”</h2><p>在上一章的末尾，我们向大家展示了几个JavaScript对象的例子。你应该还记得，“对象”是一种自足的数据集合。与某个特定对象相关联的变量被称为这个对象的属性；只能通过某个特定对象去调用的函数称为这个对象的方法。<br>&amp;emsp;&amp;emsp;JavaScript语言里的对象可以分为三种类型</p>
<ul>
<li>用户定义对象（user-defined object）：由程序员自行创建的对象，本书不讨论这种对象。</li>
<li>内建对象（native object）：内建在JavaScript语言里的对象，如Array、Math和Date等</li>
<li>宿主对象（host objest）：由浏览器提供的对象<br>即使是在JavaScript的最初版本里，对编写脚本来说非常重要的一些宿主对象就已经可用了，它们当中最基础的对象是window对象。</li>
</ul>
<p>window对象对应着浏览器窗口本身，这个对象的属性和方法通常统称为BOM（浏览器对象模型），但我觉得称为Window Object Model（窗口对象模型）更为贴切。BOM提供了window.open和window.blur等方法，这些方法某种程序上要为到处被滥用的各种弹出窗口和下拉菜单负责。难怪JavaScript会有一个不好的名声！<br>&amp;emsp;&amp;emsp;值得庆幸的是，我们不需要与BOM打太多的交道，而是把注意力集中在浏览器窗口内的网页内容上。document对象的主要功能就是处理网页的内容。在本书的后续内容里，我们几乎只讨论document对象的属性我方法。<br>&amp;emsp;&amp;emsp;现在，我们已经对DOM中的字母“D”（document，文档）和字母“O”（object，对象）做了解释，那么字母“M”又代表着什么呢？</p>
<h2 id="3-3、模型：DOM中的“M”"><a href="#3-3、模型：DOM中的“M”" class="headerlink" title="3.3、模型：DOM中的“M”"></a>3.3、模型：DOM中的“M”</h2><p>DOM中的“M”代表着“Model”（模型），但说它代表着“Map”（地图）也未尝不可。模型也好，地图也罢，它们的含义都是某种事物的表现形式。就像一个模型火车代表着一列真正的火车、一张城市街道图代表着一个实际存在的城市那样。DOM代表着加载到浏览器窗口的当前网页。浏览器提供了网页的地图（或者说模型），而我们可以通过JavaScript去读取这张地图。<br>&amp;emsp;&amp;emsp;既然是地图，就必须有诸如方向、等高线和比例尺之类的图例。要想看懂和使用地图，就必须知道这些图例的含义和用途，这个道理同样适用于DOM。要想从DOM获得信息，必须先把各种表示的描述文档的“图例”弄明白。<br>&amp;emsp;&amp;emsp;DOM把一份文档表示为一棵树（这里所说的“树”是数字意义上的概念），这里我们理解和运用这一模型的关键。更具体地说，DOM把文档表示为一模家谱树。<br>&amp;emsp;&amp;emsp;家谱树本身又是一种模型。家谱树的典型用法是表示一个人类家族的谱系，并使用parent（父）、child（子）、sibling（兄弟）等记号来表明家庭成员之间的关系。家谱树可以把一些相当复杂的关系简明地表示出来：一位特定的家庭成员既是某些成员的父辈，又是另一位成员的子辈，同时还是另一位成员的兄弟。<br>&amp;emsp;&amp;emsp;家谱树模型非常适合用来表示一份用（X）HTML语言编写出来的文档。<br>&amp;emsp;&amp;emsp;请看图3-1中这份非常基本的网页，它的内容是一份购物清单。<br><img src="3-1.PNG" style="margin : auto;"  width="50%" height="50%" title="[图3-1]" /></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Shopping list<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>What to buy<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">p</span> <span class="attr">title</span>=<span class="string">&quot;a gentle reminder&quot;</span>&gt;</span>Do not forget to buy this stuff.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;purchases&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	  <span class="tag">&lt;<span class="name">li</span>&gt;</span>A tin of beans<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;sale&quot;</span>&gt;</span>Cheese<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;sale important&quot;</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	 <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这份文档可以用图3-2中的模型来表示。<br><img src="3-2.PNG" style="margin: auto;" width=50% height=50% title="[图3-2]" /></p>
<p>现在我们一米分析一下这个网页的结构，了解它的构成，看看它为什么那么适合用前面提到的模型表示。DOCTYPE之后，一个打开了的<code>&lt;html&gt;</code>标签标识整个文档的开始，这个网页里的所有其他元素都包含在这个元素里，这表示它至少是一个父亲（parent）。又因为所有其他的元素都包含在其内部，所以这个<html>标签既没有父亲，也没有兄弟。如果这是一棵真正的树，这个<code>&lt;html&gt;</code>标签就是树根。<br>&amp;emsp;&amp;emsp;根元素是html。不管从哪个角度看，html都代表整个文档。<br>&amp;emsp;&amp;emsp;接下来深入一层，我们发现有<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>两个分支。它们位于同一层次且互不包含，所以它们是兄弟关系。它们有着共同的父元素<code>&lt;html&gt;</code>，但又各有各的子元素，所以它们本身又是其他一些元素的父元素。<br>&amp;emsp;&amp;emsp;<head>元素有两个子素：<code>&lt;meta&gt;</code>和<code>&lt;title&gt;</code>（这两个元素是兄弟关系）。<code>&lt;body&gt;</code>元素有三个子元素：<code>&lt;h1&gt;</code>、<code>&lt;p&gt;</code>和<code>&lt;ul&gt;</code>（这三个元素是兄弟关系）。继续深入下去，我们发现<code>&lt;ul&gt;</code>也是一个父元素，它有三个子元素，它们都是<code>&lt;li&gt;</code>元素，有一些class属性。<br>&amp;emsp;&amp;emsp;利用这种简单的家谱关系记号，我们可以把各元素之间的关系简明清晰地表达出来。例如，<code>&lt;h1&gt;</code>和<code>&lt;ul&gt;</code>之间是什么关系？答案是它们是兄弟关系。那么<code>&lt;body&gt;</code>和<code>&lt;ul&gt;</code>之间又是什么关系？<code>&lt;body&gt;</code>是<code>&lt;ul&gt;</code>的父元素，<code>&lt;ul&gt;</code>是<code>&lt;body&gt;</code>的一个子元素。<br>&amp;emsp;&amp;emsp;如果你能把一个文档的各种元素想象成一棵家谱树，我们就可以用同样的术语描述DOM。不过，与使用“家谱树”这个术语相比，把文档称为“节点树”更准确。</p>
<h2 id="3-4、节点"><a href="#3-4、节点" class="headerlink" title="3.4、节点"></a>3.4、节点</h2><p>节点（node）这个词是个网络术语，它表示网络中的一个连接点。一个网络就是由一些节点构成的集合。<br>&amp;emsp;&amp;emsp;在现实世界里，一切事物都由原子构成。原子是现实世界的节点。但原子本身还可以进一步分解为更细小的亚原子微粒。这些亚原子微粒同样也被当成是节点。<br>&amp;emsp;&amp;emsp;DOM也是同样的情况。文档是由节点构成的集合，只不过此时的节点是文档树上的树支和树叶而已。<br>&amp;emsp;&amp;emsp;在DOM里有许多不同类型的节点。就像原子包含着亚原子微粒那样，也有很多类型的DOM节点包含其他类型的节点。接下来我们先看看其中的三种：元素节点、文本节点和属情节点。</p>
<h3 id="3-4-1、元素节点"><a href="#3-4-1、元素节点" class="headerlink" title="3.4.1、元素节点"></a>3.4.1、元素节点</h3><p>DOM的原子是元素节点（element node）。<br>&amp;emsp;&amp;emsp;在描述刚才那份“购物清单”文档时，我们使用了诸如<code>&lt;body&gt;</code>、<code>&lt;p&gt;</code>和<code>&lt;ul&gt;</code>之类的元素。如果把WEB上的文档比做一座大厦，元素就是建造这座大厦的砖块，这些元素在文档中的布局形成了文档的结构。<br>&amp;emsp;&amp;emsp;标的名字是就是元素的名字。文本段落元素的名字是“p”，无序清单元素的名字是“ul”，列表项元素的名字是“li”。<br>&amp;emsp;&amp;emsp;元素可以包含其他的元素。在我们的“购物清单”文档里，所有的列表项元素都包含在一个无序清单元素的内部。事实上，没有被包含在其他元素里的唯一元素是<code>&lt;html&gt;</code>元素，它是我们的节点树的根元素。</p>
<h3 id="3-4-2、文本节点"><a href="#3-4-2、文本节点" class="headerlink" title="3.4.2、文本节点"></a>3.4.2、文本节点</h3><p>元素节点只是节点类型的一种。如果一份文档完全由一些空白元素构成，它将有一个结构，但这份文档本身将不会包含什么内容。在内容为王的互联网上，绝大数内容都是由文本提供的。<br>&amp;emsp;&amp;emsp;在“购物清单”例子里，<code>&lt;p&gt;</code>元素包含着文本“Do not forget to buy this stuff”。它是一个文本节点（text node）。<br>&amp;emsp;&amp;emsp;在XHTML文档里，文本节点总是被包含在元素节点的内部。但并非所有的元素节点都包含有文本节点。在“购物清单”文档里，<code>&lt;ul&gt;</code>元素没有直接包含任何文本节点，它包含着其他的元素节点（一些<code>&lt;li&gt;</code>元素），后者包含着文本节点。</p>
<h3 id="3-4-3、属性节点"><a href="#3-4-3、属性节点" class="headerlink" title="3.4.3、属性节点"></a>3.4.3、属性节点</h3><p>属性结点用来对元素做出更具体的描述。例如，几乎所有的元素都有一个title属性，而我们可以利用这个属性对包含在元素里的东西做出准确的描述：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p title=<span class="string">&quot;a gentle reminder&quot;</span>&gt;<span class="title class_">Do</span> not forget to buy <span class="variable language_">this</span> stuff.&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>在DOM中，<code>title=&quot;a gentle reminder&quot; </code>是一个属性节点（attribute node），所图3-3所示。<br><img src="3-3.PNG" style="margin : auto ;" width="50%" height="50%" title="[图3-3]" /><br>&amp;emsp;&amp;emsp;因为属性总是被放在起始标签里，所以属性节点总是被包含在元素节点中。并非所有的元素都包含着属性，但所有的属性都被元素包含。<br>&amp;emsp;&amp;emsp;在前面的“购物清单”示例文档里，可以清楚地看到那个无序清单元素（<code>&lt;ul&gt;</code>）有个id属性。有些清单元素（<code>&lt;li&gt;</code>）有class属性。如果曾经用过CSS，你对id和class之类的属性应该不会感到陌生。不过，为了照顾那些对CSS还不太熟悉的读者，我们下面将简要地重温几个最基本的CSS概念。</p>
<h3 id="3-4-4、CSS"><a href="#3-4-4、CSS" class="headerlink" title="3.4.4、CSS"></a>3.4.4、CSS</h3><p>DOM并不是与网成立结构打交道的唯一技术。我们还可以通过CSS（层叠样式表）告诉浏览器应该如何显示一份文档的内容。<br>&amp;emsp;&amp;emsp;类似JavaScript脚本，对样式的声明既可以嵌在文档的<code>&lt;head&gt;</code>部分（<code>&lt;style</code>标签之间），也可以放在另外一个样式表的文件里。CSS声明元素样式的语法与JavaScript函数的定义语法很相似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selector &#123;</span><br><span class="line">  property: value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在样式声明里，我们可以定义浏览器在显示元素时使用的颜色、字体和字号，如下所示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;arial&quot;</span>, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承（inheritance）是CSS技术中的一项强大功能。类似于DOM，CSS也把文档的内容视为一棵节点树。节点树上的各个元素将继承其父元素的样式属性。<br>&amp;emsp;&amp;emsp;例如，如果我们为body元素定义了一些颜色或字体，包含在body元素里的所有元素都将自动获得那些样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  backgroud-<span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些颜色将不仅作用于那此直接包含在<code>&lt;body&gt;</code>标签里的内容，还将作用于嵌套在body元素内部的所有元素。<br>&amp;emsp;&amp;emsp;图3-4是把刚才定义的样式应用在“购物清单”示例文档上后得到的网页显示效果。<br><img src="3-4.PNG" style="margin : auto ; " width="50%" height="50%" title="[图3-4]" /></p>
<p>&amp;emsp;&amp;emsp;在某些场合，当把样式应用于一份文档时，我们其实只想让那些样式作用于某个特定的元素。例如，我们只想让某一段文本变成某种特殊的颜色和字体，但不想让其他段落受到影响。为了获得如此精细的控制，需要在文档里插入一些能够把这段文本与其他段落区别开来的特殊标志。<br>&amp;emsp;&amp;emsp;为了把某一个或某几个元素与其他元素区别开来，需要使用class属性或id属性。</p>
<h4 id="3-4-4-1、class属性"><a href="#3-4-4-1、class属性" class="headerlink" title="3.4.4.1、class属性"></a>3.4.4.1、class属性</h4><p>你可以在所有的元素上任意应用class属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;special&quot;</span>&gt;</span>This paragraph has the special class<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;special&quot;</span>&gt;</span>So does this headline<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在样式表里，可以像下面这样为class属性值相同的所有元素定义同一种样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.special</span> &#123;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以像下面这样利用class属性为一种特定类型的元素定义一种特定的样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h2</span><span class="selector-class">.special</span> &#123;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-4-2、id属性"><a href="#3-4-4-2、id属性" class="headerlink" title="3.4.4.2、id属性"></a>3.4.4.2、id属性</h4><p>id属性的用途是给网页里的某个元素加上一个独一无二的标识符，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;purchases&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p>在样式表里，可以像下面这样为有特定id属性值的元素定义一种独享的样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#purchases</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid white;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管id本身只能使用一次，样式表还是可以利用id属性为包含在该特定元素里的其他元素定义样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#purchases</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>id 属性就像是一个挂钩，它一头连着文档里的某个元素，另一头连着CSS样式表里的某个样式。DOM也可以使用这种挂钩。</p>
<h3 id="3-4-5、获取元素"><a href="#3-4-5、获取元素" class="headerlink" title="3.4.5、获取元素"></a>3.4.5、获取元素</h3><p>有3种DOM方法可以获取元素节点，分别是通过元素ID、通过标签名字和通过类名字来获取。</p>
<h4 id="3-4-5-1、getElementByID"><a href="#3-4-5-1、getElementByID" class="headerlink" title="3.4.5.1、getElementByID"></a>3.4.5.1、getElementByID</h4><p>DOM提供了一个名为getElementById的方法，这个方法将返回一个与那个有着给定id属性值的元素节点对应的对象。请注意，JavaScript是区分字母大小写的，所以在写出“getElementById”时千万不要把大小写弄错了。如果把它错写成“GetElementById”或“getElementbyid”，你都得不到正确的结果。<br>&amp;emsp;&amp;emsp;它是document对象特有的函数。在脚本代码里，函数名的后面必段跟有一对圆括号，这对圆括号包含着函数的参数。getElementById方法只有一个参数：你想获得的那个元素的id属性的值，这个id值必须放在单引号或双引号里。<code>document.getElementById(id)</code><br>&amp;emsp;&amp;emsp;下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;purchases&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这个调用将返回一个对象，这个对象对应着document对象里的一个独一无二的元素，那个元素的HTML id属性值是purchases。你可以用typeof操作符来验证这一点。typeof操作符可以告诉我们它的操作数是一个字符串、数值、函数、布尔值还是对象。<br>&amp;emsp;&amp;emsp;下面是把一些JavaScript语句插入到前面给出的“购物清单”文档之后得到的一份代码清单，新增的代码出现在<code>&lt;/body&gt;</code>结束标签之前。顺便说一句，我本人并不赞成把JavaScript代码直接嵌入文档，但这确实是一种简便快捷的测试手段：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Shopping list<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>What to buy<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">title</span>=<span class="string">&quot;a gentle reminder&quot;</span>&gt;</span>Don&#x27;t forget to buy this stuff.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;purchases&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>A tin of beans<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;sale&quot;</span>&gt;</span>Cheese<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;sale important&quot;</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;purchases&quot;</span>));</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>把上面的这些代码保存为一个XHTML文件。当在Web浏览器加载这个文件，会弹出一个如图3-6所示的alert对话框，它向你们报告<code>document.getElmentById(&quot;purchases&quot;)</code>的类型–它是一个对象。如下图<br><img src="3-6.PNG" style="margin : auto;" width="50%" height="50%" title="[图3-6]" /><br>&amp;emsp;&amp;emsp;事实上，文档中的每一个元素都是一个对象。利用DOM提供的方法能得到任何一个对象。一般来说，用不着为文档里的每个元素都定义一个独一无二的id值，那也太小题大做了。DOM提供了另一个方法来获取那些没有id属性的对象。</p>
<h4 id="3-4-5-2、getElementsByTagName"><a href="#3-4-5-2、getElementsByTagName" class="headerlink" title="3.4.5.2、getElementsByTagName"></a>3.4.5.2、getElementsByTagName</h4><p>getElementsByTagName方法返回一个对象数组，每个对象分别对应着文档里有着给定标签的一个元素。类似于getElementId，这个方法也是只有一个参数的函数，它的参数是标签的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element.getElementsByTagName(tag)</span><br></pre></td></tr></table></figure>
<p>它与getElementById方法有许多相似之处，但它返回的是一个数组，你在编写脚本时千万注意不要把这两个方法弄混了。下面是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docment.getElementsByTagName(&quot;li&quot;)</span><br></pre></td></tr></table></figure>
<p>这个调用将返回一个对象数组，每个对象分别对应着document对象中的一个列表项元素。与任何其他的数组一样，我们可以利用length属性查出这个数组里的元素个数。<br>&amp;emsp;&amp;emsp;首先，在上一小节给出的XHTML示例文档里把<code>&lt;script&gt;</code>标签中的alert语句替换为下面这条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(document.getElementsByTagName(&quot;li&quot;).length);</span><br></pre></td></tr></table></figure>
<p>你会看到这份示例文档里的列表项元素的个数：3。这个数组里的每个元素都是一个对象。可以通过利用一个循环语句和typeof操作符去遍历这个数组来验证这一点。例如，你可试试下面这个for循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>).<span class="property">length</span>;i++) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>)[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，即使在整个文档里这个标签只有一个元素，getElementsByTagName也返回一个数组，此时，那个数组的长度是1。<br>&amp;emsp;&amp;emsp;你或许已经开始觉得用键盘反复敲入document.getElementsByTagName(“li”)是件很麻烦的事件，而这些长长的字符串会让代码变得越来越难以阅读。有个简单的方法可以减少不必要的打字量并改善代码的可读性：只要把<code>document.getElementsByTagName(&quot;li&quot;)</code>赋值给一个变量即可。请把<code>&lt;script&gt;</code>标签中的alert语句替换为下面这些语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; items.<span class="property">length</span>;i++) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="keyword">typeof</span> items[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你将看到三个alert对话框，显示的消息是“object”。<br>&amp;emsp;&amp;emsp;getElementById和getElementsByTagName结合起来运行。例如刚才给出的几个例子都是通过document对象调用getElementsByTagName的，如果只想知道id属性值是purchase的元还给包含着多少个列表项，必须通过一个更具体的对象去调用这个方法，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shopping = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;purchases&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> items = shopping.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在这两条语句执行完毕后，items数组将只包含id属性值是purchase的无序清单里的元素。具体到这个例子，items数组的长度刚好与这份文档里的列表项元素的总数相等：<code>alert(items.length);</code><br>&amp;emsp;&amp;emsp;如果还需要更多的证据，下面这些语句将证明items数组里的每个值确实是一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.<span class="property">lenght</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="keyword">typeof</span> items[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-5-3、getElementsByClassName"><a href="#3-4-5-3、getElementsByClassName" class="headerlink" title="3.4.5.3、getElementsByClassName"></a>3.4.5.3、getElementsByClassName</h4><p>HTML5 DOM(<a href="http://www.whatwg.org/specs/web-apps/current-work/">http://www.whatwg.org/specs/web-apps/current-work/</a> )中新增了一个令人期待已久的方法：getElementByClassName。这个方法让我们能够通过class属性中的类名来访问元素。不过，由于这个方法还比较新，某些DOM实现里可能还没有，因此在使用的时候要当心。下面我们先来看一看这个方法能帮我们做什么，然后再讨论怎么可靠地使用该方法。<br>&amp;emsp;&amp;emsp;与getElementsByTagName方法类似，getElementsByTagName也只接受一个参数，就是类名：<code>getElementsByClassName(class)</code>，这个方法的返回值也与getElementsByTagName类似，都是一个具有相同类名的元素的数组。下面这行代码返回的就是一个数组，其中包含类名为“sale”的所有元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;sale&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>使用这个方法还可以查找那些带有多个类名的元素。要指定多个类名，只要在字符串参数中用空格分隔类名即可。例如，在<code>&lt;script&gt;</code>标签中添加下面这行alert代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;important sale&quot;</span>).<span class="property">length</span>);</span><br></pre></td></tr></table></figure>
<p>你会看到警告框中显示1，表示只有一个元素匹配，因为只有一个元素同时带有“important”和“sale”类名。注意，即使在元素的class属性中，类名的顺序是“sale import”而非参数中指定的“import sale”，也照样会匹配该元素。不仅类名的实际顺序不重要，就算元素还带有更多类名也没有关系。<br>&amp;emsp;&amp;emsp;与使用getElementsByTagName一样，也可以组合使用getElementsByClassName和getElementById。如果你想知道在id为“purchases”的元素中有多少类名包含“sale”列表项，可以先找到那个特定的对象，然后再调用getElementsByClassName:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shopping = docment.<span class="title function_">getElementById</span>(<span class="string">&quot;purchases&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> sales = shopping.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;sale&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这样，sales数组中包含的就只是位于“purchases”列表中的带有“sale”类的元素。运行下面这行代码，就会看到sales数组中包含两项：<code>alert(sales.length);</code><br>&amp;emsp;&amp;emsp;这个getElementsByClassName方法非常有用，但只有较新的浏览器才支持它。为了弥补这一不足，DOM脚本程序员需要使用已有的DOM方法来实现自己的getElementsByClassName；有点像是成人礼似的。而多数情况下，他们的实现过程都与下面这个getElementsByClassName大至相似，这个函数能适用于新老浏览器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getElementsByClassName</span>(<span class="params">node, classname</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">getElementsByClassName</span>) &#123;</span><br><span class="line">    <span class="comment">//使用现有方法</span></span><br><span class="line">    <span class="keyword">return</span> node.<span class="title function_">getElementsByClassName</span>(classname);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> results = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">var</span> elems = node.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;elems.<span class="property">length</span>;i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems[i].<span class="property">className</span>.<span class="title function_">indexof</span>(classname) != -<span class="number">1</span> ) &#123;</span><br><span class="line">        results[results.<span class="property">length</span>] = elems[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个getElementsByClassName函数接受两个参数。第一个node表示DOM树中的搜索起点，第二个classname就是要搜索的类名了。如果传入节点上已经存在了适当的getElementsByClassName函数，那么这个新函数就直接返回相应的节点列表。如果getElementsByClassName函数不存在，这个新函数就会循环遍历所有标签，查找带有相应类名的元素。（这个例子不适用于多个类名。）如果使用这个函数来模拟前面取得购物列表的操作，就可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shopping = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;purchases&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> sales = <span class="title function_">getElementsByClassName</span>(shopping,<span class="string">&quot;sale&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>当然搜索匹配的DOM元素的方法有很多，但直正高效的却不多，有兴趣的读者可以参考Robert Nyman的文章The Ultimate getElementsByClassName(<a href="http://robernyman.com/2008/05/27/theultimate-gelementsbyclassname-anno-2008">http://robernyman.com/2008/05/27/theultimate-gelementsbyclassname-anno-2008</a> )。<br>&amp;emsp;&amp;emsp;第5章将继续讨论类似的支持性的问题，以及如何解决这些问题。第7单将更详细地控讨DOM操作方法。</p>
<h3 id="3-4-6、盘点知识点"><a href="#3-4-6、盘点知识点" class="headerlink" title="3.4.6、盘点知识点"></a>3.4.6、盘点知识点</h3><p>你一定已经厌倦了看那么多遍显示着单词“object”的alert对话框。你一定已经明白：文档中的每个元素节点都是一个对象。不仅如此，这些对象中的每一个还天生具有一系列非常有用的方法，还要归功于DOM。利用这些预先定义好的方法，我们不仅可以检索出文档里任何一个对象的信息，甚至还可以改变元素的属性。<br>&amp;emsp;&amp;emsp;下面是对本章此前学习内容的一个简要总结</p>
<ul>
<li>一份文档就是一棵节点树</li>
<li>节点分为不同的类型：元素节点、属性节点和文本节点等。</li>
<li>getElementById将返回一个对象，该对象对应着文档里的一个特定的元素节点。</li>
<li>getElementsByTagName和getElementByClassName将返回一个对象数组，它们分别对应着文档里的一组特定的元素节点。</li>
<li>每个节点都是一个对象</li>
</ul>
<p>&amp;emsp;&amp;emsp;接下来介绍节点对象的属性和方法。</p>
<h2 id="3-5、获取和设置属性"><a href="#3-5、获取和设置属性" class="headerlink" title="3.5、获取和设置属性"></a>3.5、获取和设置属性</h2><p>至此，我们已经介绍了3种获取特定元素的方法：分别是getElementById，getElementsByTagName和getElementByClassName。得到需要的元素以后，我们就可以设法获取它的各个属性。getAttribute方法就是用来做这件事的。相应地，setAttribute方法则可以更改属性节点的值。</p>
<h3 id="3-5-1、getAttribute"><a href="#3-5-1、getAttribute" class="headerlink" title="3.5.1、getAttribute"></a>3.5.1、getAttribute</h3><p>getAttribute是一个函数。它只有一个参数–你打算查询的属性名字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">object.<span class="title function_">getAttribute</span>(attribute)</span><br></pre></td></tr></table></figure>
<p>与此前我们介绍过的那些方法不同，getAttribute方法不属于document对象，所以不能通过document对象调用。它只能通过元素节点对象调用。例如，可以与getElementsByTagName方法合用，获取每个<code>&lt;p&gt;</code>元素的title属性，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> paras = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; paras.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(paras[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把上面这段代码放到前面给出的“购物清单”文件的末尾，然后在WEB浏览器里重新加载这个页面，屏幕上将弹出一个显示着文本消息“a gentle reminder”的alert对话框。<br>&amp;emsp;&amp;emsp;在“购物清单”文件里只有一个<code>&lt;p&gt;</code>元素，并且它有title属性。假如这份文档有更多个<code>&lt;p&gt;</code>元素，并且它们没有title属性，则getAttribute(“title”)方法会返回null值。在JavaScript里，null含义是“没有值”。把下面代码添加到“购物清单”文件中的现有<code>&lt;p&gt;</code>标签之后：<code>&lt;p&gt;This is just a test&lt;/p&gt;</code><br>&amp;emsp;&amp;emsp;重新加载这个页面。这一次，你将看到两个alert对话框，而第二个对话框将是一片空白或者是只显示着单词“null”，这取决于你哪种Web浏览器。<br>&amp;emsp;&amp;emsp;我们可以修改脚本，让它只在title属性有值时才弹出消息。我们将增加一条if语句来检查getAttribute的返回值是不是null。趁着这个机会，我们顺便增加几个变量以提高脚本的可读性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> paras = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paras.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> title_text = paras[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (title_text != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(title_text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在重新加载这个页面，你会看到一个显示着“a gentle reminder”消息的alert对话框，如图3-7所示。<br><img src="3-7.PNG" style="margin : auto;"  width="50%" height="50%" title="[图3-7]" /><br>&amp;emsp;&amp;emsp;我们甚至可以把这段代码缩得更短一些。当检查某项数据是否是null值时，我们其实是在检查它是否存在。这种检查可以简化为直接把被检查的数据用作if语句的条件。if(something)与if(something !&#x3D; null)完全等价，但是前者显然更为简明。此时，如果something存在，则if语句条件将为真；如果something不存在，则if语句的条件将为假。<br>&amp;emsp;&amp;emsp;具体到这个例子，只要我们把if(title_text !&#x3D; null)替换为if(title_text)，我们就可以得到更简明的代码。此外，为了进一步增加代码的可读性，我们还可以趁此机会把alert语句与if语句写在同一行上，这可以让它们更接近于我们日常生活中的英语句子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> paras=<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;paras.<span class="property">length</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> title_text = paras[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (title_text)   <span class="title function_">alert</span>(title_text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-2、setAttribute"><a href="#3-5-2、setAttribute" class="headerlink" title="3.5.2、setAttribute"></a>3.5.2、setAttribute</h3><p>此前介绍的所有方法都是用来获取信息。setAttribute()有点不同：它允许我们对属性节点的值做出修改。与getAttribute一样，setAttribute也只能用于元素节点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">object.<span class="title function_">setAttribute</span>(attribute,value)</span><br></pre></td></tr></table></figure>
<p>在下面的例子里，第一条语句得到id是purchase的元素，第二条语句是把这个元素的title属性值设置为a list of goods:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shopping = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;purchase&quot;</span>);</span><br><span class="line">shopping.<span class="title function_">setAttribute</span>(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;a list of goods&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以利用getAttribute来证明这个元素的title属性值确实发生了变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shopping = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;purchase&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(shopping.<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>));</span><br><span class="line"><span class="title function_">alert</span>(shopping.<span class="title function_">setAttribute</span>(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;a list of goods&quot;</span>));</span><br><span class="line"><span class="title function_">alert</span>(shopping.<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;加载页面后将弹出两个alert对话框：第一个alert对话框出现在setAttribute被调用之前，它将是一片空白或显示单词“null”；第二个出现在设置title属性值之后，它将显示“a list of goods”消息。<br>&amp;emsp;&amp;emsp;在上例中，我们设置了一个节点title属性，这个属性原先并不存在。这表明setAttribute实际上完成了两项操作：先创建这个属性，然后设置它的值。如果setAttribute用在一个本身就有这个属性的元素节点上，这个属性的值就会被覆盖掉。<br>&amp;emsp;&amp;emsp;在购物清单示例文档里，<p>元素已经有了一个title属情，这个属性的值是a gentle reminder。可以用setAttribute来改变它的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> paras = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;paras.<span class="property">length</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">var</span> title_text=paras[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (title_text) &#123;</span><br><span class="line">    paras[i].<span class="title function_">setAttribute</span>(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;brand new title text&quot;</span>);</span><br><span class="line">    <span class="title function_">alert</span>(prars[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;上面这段代码将先从文档里获取全部带有title属性的<code>&lt;p&gt;</code>元素，然后把它们的title属性值都修改为brand new title text。对“购物清单”文件来说，属性值a gentle reminder会被覆盖。<br>&amp;emsp;&amp;emsp;这里有一个非常值行关注的细节：通过setAttribute对文档做出修改后，在通过浏览器的view source（查看源码）选项去查看文档本身的源代码里。这种“表里不一”的现够用源自DOM的工作模式：先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力：对页面内容进行刷新去不需要在浏览器里刷新页面。</p>
<h1 id="4、案例研究：JavaScript图片库"><a href="#4、案例研究：JavaScript图片库" class="headerlink" title="4、案例研究：JavaScript图片库"></a>4、案例研究：JavaScript图片库</h1><div class="note success"><ul>
<li>编写一个优秀的标记文件</li>
<li>编写一个JavaScript函数以显示用户想要查看的图片</li>
<li>由标记触发函数调用</li>
<li>使用几个新方法扩展这个JavaScript函数</li>
</ul>
</div>
<p>现在，是时候让DOM去做些事了。在这一章中，我将带领大家用JavaScript和DOM去建立一个图片库。<br>&amp;emsp;&amp;emsp;把图片发布到网上的办法很多。你可以简单地把所有图片都放到一个网页里。不过如果想打算发布的图片比较多，这个页面就很快变得过于庞大。要知道，虽然网页标记代码没有多大，但加上那些图片后用户要下载的数据量就相当可观了。我们必须而对这样一个现实：没有人愿意等待很长很长的时间去下载一个网页。<br>&amp;emsp;&amp;emsp;因此，为每张图片分别创建一个网页的解决方案值得考虑。这样你的图片库将不再是一个体积庞大、难以下载的网页，而变成了许多个尺寸合理、便于下载和浏览的页面。不过，这一解决方案并非尽善尽美。首先，为每张图片分别制作一个网页需要花费很多很多的时间；其次，每个网页上应该提供某种导航链接来给出当前图片在整个图片库里的位置，方便人们从当前图片转到其他图片。<br>&amp;emsp;&amp;emsp;如果想两全其美，利用JavaScript来创建图片库将是最佳的选择：把整个图片库的浏览链接集中安排在图片库主页里，只在用户点击了这个主页里的某个图片链接时才把相应的图片传送给他。</p>
<h2 id="4-1、标记"><a href="#4-1、标记" class="headerlink" title="4.1、标记"></a>4.1、标记</h2><p>为了完成JavaScript图片库，我特意用数码相机拍摄了几张照片，并把它们修整成最适合于用浏览器来查看的尺寸，即400像素宽×300像素高。在你自己做练习时，大可不必拘泥于这个尺寸，你可以使用任何尺寸。<br>&amp;emsp;&amp;emsp;第一项工作是为这些图片创建一个链接清单。国为我没打算让这些图片按照特定顺序排列，所以将使用一个无序清单元素（<code>&lt;ul&gt;</code>）来列出那些链接。如果你自己的图片已事先排好序，那就最好使用一个有序清单元素（<ol>）来标记这些图片链接。<br>&amp;emsp;&amp;emsp;下面是我的标记清单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Image Gallery<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Snapshots<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/fireworks.jpg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;A Fireworks display&quot;</span>&gt;</span>Fireworks<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/coffee.jpg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;A Cup of black Coffee&quot;</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span>    </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/rose.jpg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;A red,red rose&quot;</span>&gt;</span>Rose<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/bigben.jpg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;The famous clock&quot;</span>&gt;</span>Big Ben<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>我们将把这些标记保存到gallery.html文件，并把图片集中保存在目录images里。我的images目录和gallery.html文件位于同一个目录下。在gallery.html文件里，无序清单元素中的每个链接分别指向不同的图片。在浏览器窗口里点击某个链接就可以转到相应的图片，但从图片重新返回到链接清单目前还必须借助于浏览器Back（回退）按钮。图4-1是这个基本的链接清单在浏览器窗口里的显示效果。<br><img src="4-1.PNG" style="margin : auto;" width="50%" height="50%" title="[图4-1]" /><br>&amp;emsp;&amp;emsp;这是一个相当令人满意的网页，但它的默认行为还不太理想。下面是我希望改进的几个地方。</p>
<ol>
<li>当点击某个链接时，我希望能留在这个网页而不是转到另一个窗口</li>
<li>当点击某个链接时，我希望能在这个网页上同时看到那张图片以及原有的图片清单。</li>
</ol>
<p>&amp;emsp;&amp;emsp;下面是我为了实现上述的目标而需要完成的几项改进</p>
<ul>
<li>通过增加一个“占位符”图片的办法在这个主页上为图片预留一个浏览区域。</li>
<li>在点击某个链接时，拦截这个网页的默认行为</li>
<li>在点击某个链接时，把“占位符”图片替换为与那个链接相对应的图片。</li>
</ul>
<p>先来解决“占位符”图片的问题。我选用了一个类似于名片的图片，你可以根据个人喜好来决定选用的图片，即使选用一个空白图片也没问题。<br>&amp;emsp;&amp;emsp;把下面这些代码插入到图片清单的末尾：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;placeholder&quot;</span> <span class="attr">src</span>=<span class="string">&quot;images/placeholder.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;my image gallery&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>我对这个图片的id属性进行了设置，这将使我可以通过一个外部的样式表对图片的显示位置和显示效果加以控制。例如，可以让这个图片出现在链接清单的旁边而不是它的下方，还可以在自己的JavaScript代码里使用这个id值。下面是这个页面在增加了“占位符”图片后的显示效果。<br><img src="4-2.PNG" style="margin:auto;" width="50%" height="50%" title="[图4-2]" /><br>&amp;emsp;&amp;emsp;现在，标记文件已经准备好了，接下来的工作是编写JavaScript代码。</p>
<h2 id="4-2、JavaScript"><a href="#4-2、JavaScript" class="headerlink" title="4.2、JavaScript"></a>4.2、JavaScript</h2><p>为了把“点位符”图片替换为想要查看的图片，需要改变它的src属性。setAttribute是完成这项工作的最佳选择，而我将利用这个方法写一个函数。这个函数只有一个参数，即一个图片链接。它通过改变“占位符”图片的src属性的办法将其替换为参数图片。<br>&amp;emsp;&amp;emsp;首先，需要给函数起一个好名字，它应能描述这个函数的用途，还要简明扼要。我决定把这个函数命名为showPic。还需要给这个函数的参数起一个名字，我决定把它命名为whichpic：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showPic</span>(<span class="params">whickpic</span>)</span><br></pre></td></tr></table></figure>
<p>whickpic代表着一个元素节点，具体地说，那是一个指向某个图片的<code>&lt;a&gt;</code>元素。我需要分解出图片的文件路径，这可以通过在whickpic元素上调用getAttribute得到，只要把“href”作为参数传递给getAttribute就行了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showpic.<span class="title function_">getAttribute</span>(<span class="string">&quot;href&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>我将把这个路径存入变量source:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source = showpic.<span class="title function_">getAttribute</span>(<span class="string">&quot;href&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>接下来，还需要获取“占位符”图片，这对getElementById来说不过是小菜一碟：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;placeholder&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>我不想重复敲入“document.getElementById(“placerholder”)”这么长的字符串，所以将把这个元素赋给变量placerholder：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> placeholder = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;placeholder&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>现在，已经声明并赋值了两个变量：source和placerholder。它们可以让脚本简明易读。我将使用setAttribute对placerholder元素的src属性进行刷新。还记得吗，这个方法有两个参数：一个是属性名，另一个是属性的值。具体到这个例子，因为我想对src属性进行设置，所以第一个参数是“src”；至于第二个参数，也就是src属性的值，我已经把它保存在source变量里了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">placerholder.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>,source);</span><br><span class="line"><span class="comment">//这显然要比下面这么冗长的代码更空易阅讯和理解：</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;placerholder&quot;</span>).<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>,showpic.<span class="title function_">getAttribute</span>(<span class="string">&quot;href&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="4-2-1、非DOM解决方案"><a href="#4-2-1、非DOM解决方案" class="headerlink" title="4.2.1、非DOM解决方案"></a>4.2.1、非DOM解决方案</h3><p>其实，不使用setAttribute方法也可以改变图片的src属性。<br>&amp;emsp;&amp;emsp;setAttribute方法是“第1级DOM（DOM Level 1）”的组成部分，它可以设置任意元素节点的任意属性。在“第1级DOM”出现之前，你可以通过另外一种办法设置大部分元素的属性，这个办法到现在仍然有效。例如，如果想改变某个<code>input</code>元素的<code>value</code>属性，可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="property">value</span> = <span class="string">&quot;the new value&quot;</span></span><br></pre></td></tr></table></figure>
<p>这与下面语句的效果是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">setAttribute</span>(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;the new value&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>类似的方法也可以用来改变图片的src属性。例如，在我的图片库脚本里，完全可以用下面这条语句来代替setAttribute:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">placeholder.<span class="property">src</span> = souce</span><br></pre></td></tr></table></figure>
<p>我个人更喜欢使用setAttribute。起码不必费心去记忆哪些元素的哪些属性可以用DOM之前的哪些方法去设置。虽然用那些老办法可以毫无问题地对文档里的图片、表单和其他一些元素的属性进行设置，但setAttribute的优势在于它可以修改文档中的任何一个元素的任何一个属性。<br>&amp;emsp;&amp;emsp;“第1级DOM”的另一个优势是可移植性更好。那些老方法只适用于WEB文档，DOM则适用于任何一种标记语言。虽然这种差异对我们这个例子没有影响，但我希望大家能够牢牢记住这一点：DOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把从本书学到的DOM技巧运用在WEB浏览器以外的应用环境里，严格遵守“第1级DOM”能够让你避免与兼容性有关的任何问题。</p>
<h3 id="4-2-2、最终的函数代码清单"><a href="#4-2-2、最终的函数代码清单" class="headerlink" title="4.2.2、最终的函数代码清单"></a>4.2.2、最终的函数代码清单</h3><p>下面是showPic函数完整的代码清单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showPic</span>(<span class="params">whichpic</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> source = whichpic.<span class="title function_">getAttribute</span>(<span class="string">&quot;href&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> placeholder = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;placeholder&quot;</span>);</span><br><span class="line">  placeholder.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>,source)</span><br><span class="line">&#125;</span><br><span class="line">接下来的任何是把这个<span class="title class_">JavaScript</span>函数与标记文档结合起来。</span><br></pre></td></tr></table></figure>
<h2 id="4-3、应用这个JavaScript函数"><a href="#4-3、应用这个JavaScript函数" class="headerlink" title="4.3、应用这个JavaScript函数"></a>4.3、应用这个JavaScript函数</h2><p>函数写完了，接下来就要在图片库文档里使用它。把这个函数保存在扩展名为js的文本文件中。在此，可以给它起个名字叫showPic.js</p>
<div class="note success"><p>若一个站点用到多个JavaScript文件，为了减少对站点的请求次数（提高性能），应该把这些.js文件合并到一个文件中。本书为了便于说明问题，不少例子都使用了多个文件。等到第5章，我们会专门讨论这个问题以及其他提升站点性能的最佳实践。</p>
</div>
<p>&amp;emsp;&amp;emsp;就像我刚才决定把所有的图片集中存放在images子目录里那样，把所有的JavaScript脚本文件集中存在一个子目录里是一个好主意。我创建了一个名为script的子目录并把showPic.js文件保存到其中。<br>&amp;emsp;&amp;emsp;现在，需要在图片库文档里插入一个链接来引用这个Javascript脚本文件。我将把下面这行插入到HTML文档的<code>&lt;/body&gt;</code>标签之前。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;script/showPic.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这样在图片库文档里就可以使用showPic函数了。如果到此打住，那么showPic函数永远也不会被调用。我们需要给图片列表的链接添加行为，也就是事件处理函数（event handler），才能达成目标。</p>
<h3 id="4-3-1、事件处理函数"><a href="#4-3-1、事件处理函数" class="headerlink" title="4.3.1、事件处理函数"></a>4.3.1、事件处理函数</h3><p>事件处理函数的作用是，在特定事件发生时调用特定的JavaScript代码。例如，如果想在鼠标指针悬停在某个元素上时触发一个动作，就需要使用onmouseover事件处理函数；如果想在鼠标指针离开某个元素时触发一个动作，就需要使用onmouseout事件处理函数。在我的图片库里，我想在用户点击某个链接时触发一个动作，所以需要使用onclick事件处理函数。<br>&amp;emsp;&amp;emsp;需要注意的是showPic()函数需要一个参数：一个带有href属性的元素节点参数。当我把onclick事件处理函数嵌入到一个链接中时，需要把这个链接本身用作showPic函数的参数。<br>&amp;emsp;&amp;emsp;有个非常简单有效的办法可以做到这一点：使用this关键字。这个关键字在这儿的含义是“这个对象”。具体到当前的例子，this表示“这个<a>元素节点”：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">showPic</span>(<span class="variable language_">this</span>)</span><br></pre></td></tr></table></figure>
<p>综上所述，我将使用onclick事件处理函数来给链接添加行为。添加事件处理函数的语法如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event = <span class="string">&quot;JavaScript statement(s)&quot;</span></span><br></pre></td></tr></table></figure>
<p>请注意，JavaScript代码包含在一对引号之间。我们可以把任意数量的JavaScript语句放在这对引号之间，只要把各条语句用分号隔开即可。<br>&amp;emsp;&amp;emsp;下面这样onclick事件就可以调用showPic方法了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onclick = <span class="string">&quot;showPic(this);&quot;</span></span><br></pre></td></tr></table></figure>
<p>不过，如果仅仅把事件处理函数放到图片列表的一个链接中，我们会遇到一个问题：点击这个链接时，不仅showPic函数被调用，链接被点击的默认行为也会被调用。这意味着用户还是会被带到图片查看窗口，而这是我不希望发生的。我需要阻止这个默认行为被调用。<br>&amp;emsp;&amp;emsp;让我们近距离了解一下事件处理函数的工作机制。在给某个元素添加了事件处理函数后，一旦事件发生，相应的javascript代码就会得到执行。补调用的javascript代码可以返回一个值，这个值将被传递给那个事件处理函数。例如，我们可以给某个链接添加一个onclick事件处理函数，并让这个处理函数所触发的javascript代码返回的值是true，onclick事件处理函数就认为“这个链接被点击了”；反之，如果返回值是false，onclick事件处理函数就认为“这个链接没有被点击”。<br>&amp;emsp;&amp;emsp;可以通过下面这个简单测试去验证这一结论：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;http://www.example.com&quot;</span> onclick=<span class="string">&quot;return false;&quot;</span> &gt;<span class="title class_">Click</span> me&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>当点击这个链接时，因为onclick事件处理函数所触发的JavaScript代码返回给它的值是false，所以这个链接的默认行为没有被触发。<br>&amp;emsp;&amp;emsp;同样道理，如果像下面这样，在onclick事件处理函数所触发的javascript代码里增加一条<code>return false;</code>语句，就可以防止用户被带到目标链接窗口：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onclick = <span class="string">&quot;showPic(this); return false;&quot;</span></span><br></pre></td></tr></table></figure>
<p>下面是最终完成的onclick事件处理函数在图片库HTML文档里的样子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/fireworks.jpg&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;showPic(this);return false;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;fireworks display&quot;</span>&gt;</span>fireworksw<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<p>接下来，我要在图片列表的每个链接上添加这个事件处理函数。这当然有些麻烦，但眼下只能这么做，我们将在第6章介绍一个避免这种麻烦的办法。下面的标记文档是我一个个手动添加onclick事件处理函数之后的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;</span><br><span class="line">  &lt;a href=&quot;images/fireworks.jpg&quot; onclick=&quot;showPic(this);return false;&quot; title=&quot;A fireworks display&quot;&gt;Fireworks&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">  &lt;a href=&quot;images/coffee.jpg&quot; onclick=&quot;showPic(this);return false&quot; title=&quot;A cup of black coffee&quot;&gt;Coffee&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">  &lt;a href=&quot;images/rose.jpg&quot; onclick=&quot;showPic(this);return false&quot; title=&quot;A red,red rose&quot;&gt;Rose&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">  &lt;a href=&quot;images/bigben.jpg&quot; onclick=&quot;showPic(this);return false;&quot; title=&quot;The famous clock&quot;&gt;Big Ben&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<p>现在，把这个页面加载到Web浏览器里，你将看到一个能够正常工作的“JavaScript图片库”：如图4-3所示，不管点击图片列表里的哪个链接，都能在这个页面里看到相应的图片。<br><img src="4-3.PNG" title="[图4-3]" style="margin:auto;" width="50%" height="50%" ></p>
<h2 id="4-4、对这个函数进行扩展"><a href="#4-4、对这个函数进行扩展" class="headerlink" title="4.4、对这个函数进行扩展"></a>4.4、对这个函数进行扩展</h2><p>在一个网页上切换显示不同的图片并不是什么新鲜事。早在W3C推出它们标准化的DOM和JavaScript语言之前，有着这类效果的网页和脚本就已经出现了，如今更是得到了广泛的流行。<br>&amp;emsp;&amp;emsp;在这种情形下，如果想让自己与众不同，就必须另辟蹊径。有没有想过在同一个网页上切换显示不同的文本？利用JavaScript语言和DOM，确实可以做到这一点。<br>&amp;emsp;&amp;emsp;图片库文档里的每个图片链接都有一个title属性。可以把这个属性取出来并让它和相应的图片一同显示在网页上。title属性的值可以用getAttribute轻而易举地得到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = whichpic.<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>光提取title属性的值还不够，我们还需要把它插入到HTML文档中。为完成这一工作，我需要用到几个新的DOM属性。</p>
<h3 id="4-4-1、childNodes属性"><a href="#4-4-1、childNodes属性" class="headerlink" title="4.4.1、childNodes属性"></a>4.4.1、childNodes属性</h3><p>在一棵节点树上，childNodes属性可以用来获取任何一个元素的所有子元素，它是一个包含这个元素全部子元素的数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="property">childNodes</span></span><br></pre></td></tr></table></figure>
<p>假设需要把某个文档的body元素的全体子元素检索出来。首先，我们使用getElementsByTagName得到body元素。因为每份文档只有一个body元素，所以它将是getElementByTagName(“body”)方法所返回的数组中的第一个（也是唯一一个）元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body_element = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>现在，变量body_element已经指向了那个文档的body元素。接下来，可以用如下所示的语法获取body元素的全体子元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">body_element.<span class="property">childNodes</span></span><br></pre></td></tr></table></figure>
<p>这显然要比像下面这样写简明得多：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>].<span class="property">childNodes</span></span><br></pre></td></tr></table></figure>
<p>现在，已经知道如何获取body元素的全体子元素了，接下来看看这些信息的用途。<br>&amp;emsp;&amp;emsp;首先，可以精确地查出body元素一共有多少个子元素。因为childNodes属性返回的是一个数组，所以用数组的length属性就可以知道它所包含的元素的个数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">body_element.<span class="property">childNodes</span>.<span class="property">length</span>;</span><br></pre></td></tr></table></figure>
<p>现在把下面这个小函数添加到showPic.js文件里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countBodyChildren</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> body_element = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="title function_">alert</span>(body_element.<span class="property">childNodes</span>.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个简单的小函数将弹出一个alert对话框，显示body元素的子元素的总个数。<br>我想让这个函数在页面加载时执行，而这需要使用onload事件处理函数。把下面这条语句添加到代码段的末尾：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = countBodyChildren;</span><br></pre></td></tr></table></figure>
<p>这条语句的作用是在页面加载时调用countBodyChildren函数。<br>&amp;emsp;&amp;emsp;在WEB浏览器里刷新gallery.html文件。你会看到一个alert对话框，其显示的内容是body元素的子元素的总个数。这个数字很可能会让你大吃一惊。</p>
<h3 id="4-4-2、nodeType属性"><a href="#4-4-2、nodeType属性" class="headerlink" title="4.4.2、nodeType属性"></a>4.4.2、nodeType属性</h3><p>根据gallery.html文件的结构，body元素应该只有3个子元素：一个h1元素、一个ul元素和一个img元素。可是，countBodyChildren()函数给出来的数字却远大于此，这是因为文档树的节点类型并非只有元素节点一种。<br>&amp;emsp;&amp;emsp;由childNodes属性返回的数组包含所有类型的节点，而不仅仅是元素节点。事实上，文档里几乎每一样东西都是一个节点，甚至连空格和换行符都会被解释为节点，而它们也全都包含在childNodes属性所返黑历史的数组当中。<br>&amp;emsp;&amp;emsp;因此，countBodyChildren的返回结果才会这么大。<br>&amp;emsp;&amp;emsp;还好，每一个节点都有nodeType属性。这个属性可以让我们知道自己正在与哪一种节点打交道，差劲的一点是nodeType的值并不是英文。<br>&amp;emsp;&amp;emsp;用下面的语法获取节点的nodeType属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node.<span class="property">nodetype</span></span><br></pre></td></tr></table></figure>
<p>nodeType的值是一个数字而不是像“element”或“attribute”那样的英文字符串。<br>&amp;emsp;&amp;emsp;为了验证这一点，把countBodyChildren中的alert语句替换为下面这条语句，这样一来，我们就知道body_element元素的nodeType属性了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(body_element.<span class="property">nodeType</span>);</span><br></pre></td></tr></table></figure>
<p>在Web浏览器里刷新gallery.html文件，将看到一个显示数字“1”的alert对话框。换句话说，元素节点的nodeType属性值是1。<br>&amp;emsp;&amp;emsp;nodeType属性总共有12种可取值，但其中仅有3种具有实用价值。</p>
<ul>
<li>元素节点的nodeType属性值是1</li>
<li>属性节点的nodeType属性值是2</li>
<li>文本节点的nodeType属性值是3</li>
</ul>
<p>这就意味着，可以让函数只对特定类型的节点进行处理。例如，完全可以编写出一个只处理元素节点的函数。</p>
<h3 id="4-4-3、在标记里增加一段描述"><a href="#4-4-3、在标记里增加一段描述" class="headerlink" title="4.4.3、在标记里增加一段描述"></a>4.4.3、在标记里增加一段描述</h3><p>为了增强我的图片库的函数，我决定维护一个文本节点。我想在显示图片时，把这个文本节点的值替换成目标图片链接的title的值。<br>&amp;emsp;&amp;emsp;首先，需要为目标文本安排显示位置。我在gallery.html文件里增加一个新的文本段。我把它安排在<img>标签之后，为它设置一个独一无二的id值，这样就能在JavaScript函数里方便的引用它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;description&quot;</span>&gt;<span class="title class_">Choose</span> an image.&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>上面这条语句将把<code>&lt;p&gt;</code>元素的id属性为description（描述），这个id可以让这个元素的用途一目了然。如图4-4所示，包含在此元素里的文本现在是“Choose an image.”，你能看到添加了新段落。<br><img src="4-4.PNG" title="[图4-4]" style="margin:auto;" width="50%" height="30%" ></p>
<h3 id="4-4-4、用JavaScript改变这段描述"><a href="#4-4-4、用JavaScript改变这段描述" class="headerlink" title="4.4.4、用JavaScript改变这段描述"></a>4.4.4、用JavaScript改变这段描述</h3><h3 id="4-4-5、nodeValue属性"><a href="#4-4-5、nodeValue属性" class="headerlink" title="4.4.5、nodeValue属性"></a>4.4.5、nodeValue属性</h3><h3 id="4-4-6、firstChild和lastChild属性"><a href="#4-4-6、firstChild和lastChild属性" class="headerlink" title="4.4.6、firstChild和lastChild属性"></a>4.4.6、firstChild和lastChild属性</h3><h3 id="4-4-7、利用nodeValue属性刷新这段描述"><a href="#4-4-7、利用nodeValue属性刷新这段描述" class="headerlink" title="4.4.7、利用nodeValue属性刷新这段描述"></a>4.4.7、利用nodeValue属性刷新这段描述</h3><h2 id="4-5、小结"><a href="#4-5、小结" class="headerlink" title="4.5、小结"></a>4.5、小结</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>LetsEncrypt证书申请</title>
    <url>/2023/01/31/LetsEncrypt%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/</url>
    <content><![CDATA[<h2 id="Let’s-Encrypt简介"><a href="#Let’s-Encrypt简介" class="headerlink" title="Let’s Encrypt简介"></a>Let’s Encrypt简介</h2><p>Let’s Encrypt 是 一个叫 ISRG （ Internet Security Research Group ，互联网安全研究小组）的组织推出的免费安全证书计划。参与这个计划的组织和公司可以说是互联网顶顶重要的先驱，除了前文提到的三个牛气哄哄的发起单位外，后来又有思科（全球网络设备制造商执牛耳者）、 Akamai 加入，甚至连 Linux 基金会也加入了合作，这些大牌组织的加入保证了这个项目的可信度和可持续性。<br>   部署 HTTPS 网站的时候需要证书，证书由 CA 机构签发，大部分传统 CA 机构签发证书是需要收费的，这不利于推动 HTTPS 协议的使用。</p>
<p>​        Let’s Encrypt 也是一个 CA 机构，但这个 CA 机构是免费的！！！也就是说签发证书不需要任何费用。<br>​        Let’s Encrypt 由于是非盈利性的组织，需要控制开支，他们搞了一个非常有创意的事情，设计了一个 ACME 协议，目前该协议的版本是 v1。<br>​        那为什么要创建 ACME 协议呢，传统的 CA 机构是人工受理证书申请、证书更新、证书撤销，完全是手动处理的。而 ACME 协议规范化了证书申请、更新、撤销等流程，只要一个客户端实现了该协议的功能，通过客户端就可以向 Let’s Encrypt 申请证书，也就是说 Let’s Encrypt CA 完全是自动化操作的。<br>​       任何人都可以基于 ACME 协议实现一个客户端，官方推荐的客户端是 Certbot 。</p>
<span id="more"></span> 

<h3 id="Let’s-Encrypt通配符证书"><a href="#Let’s-Encrypt通配符证书" class="headerlink" title="Let’s Encrypt通配符证书"></a>Let’s Encrypt通配符证书</h3><p>在没有出现通配符证书之前，Let’s Encrypt 支持两种证书。<br>1）<font style="color:red;"><strong>单域名证书</strong></font>：证书仅仅包含一个主机。<br>2）<font style="color:red;"><strong>SAN 证书</strong>：</font>一张证书可以包括多个主机（Let’s Encrypt 限制是 20），也就是证书可以包含下列的主机：<a href="http://www.example.com、www.example.cn、blog.example.com/">www.example.com、www.example.cn、blog.example.com</a> 等等。</p>
<p>​       证书包含的主机可以不是同一个注册域，不要问我注册域是什么？注册域就是向域名注册商购买的域名。对于个人用户来说，由于主机并不是太多，所以使用 SAN 证书完全没有问题，但是对于大公司来说有一些问题：</p>
<ul>
<li>子域名非常多，而且过一段时间可能就要使用一个新的主机。</li>
<li>注册域也非常多</li>
</ul>
<p>​        对于大企业来说，SAN 证书可能并不能满足需求，类似于 sina 这样的网站，所有的主机全部包含在一张证书中，而使用 Let’s Encrypt 证书是无法满足的。通配符证书就是证书中可以包含一个通配符，比如 .example.com、.example.cn，读者很快明白，大型企业也可以使用通配符证书了，一张证书可以用更多的主机了。这个功能可以说非常重要，从功能上看 Let’s Encrypt 和传统 CA 机构没有什么区别了，会不会触动传统 CA 机构的利益呢？</p>
<h3 id="如何申请-Let’s-Encrypt-通配符证书"><a href="#如何申请-Let’s-Encrypt-通配符证书" class="headerlink" title="如何申请 Let’s Encrypt 通配符证书"></a>如何申请 Let’s Encrypt 通配符证书</h3><p>​        为了实现通配符证书，Let’s Encrypt 对 ACME 协议的实现进行了升级，只有 v2 协议才能支持通配符证书。也就是说任何客户端只要支持 ACME v2 版本，就可以申请通配符证书了，是不是很激动。在了解该协议之前有几个注意点：<br>​        客户在申请 Let’s Encrypt 证书的时候，需要校验域名的所有权，证明操作者有权利为该域名申请证书，目前支持三种验证方式：</p>
<ul>
<li>dns-01：给域名添加一个 DNS TXT 记录。（<strong>申请通配符证书，只能使用 dns-01 的方式</strong>）</li>
<li>http-01：在域名对应的 Web 服务器下放置一个 HTTP well-known URL 资源文件。</li>
<li>tls-sni-01：在域名对应的 Web 服务器下放置一个 HTTPS well-known URL 资源文件。</li>
</ul>
<h2 id="acme脚本工具"><a href="#acme脚本工具" class="headerlink" title="acme脚本工具"></a>acme脚本工具</h2><h3 id="acme-sh介绍"><a href="#acme-sh介绍" class="headerlink" title="acme.sh介绍"></a>acme.sh介绍</h3><p>​        acme.sh 实现了 acme 协议, 可以从 letsencrypt 生成免费的证书。一个纯粹用 Shell（Unix shell）语言编写的 ACME 协议客户端。完整的 ACME 协议实施。 支持 ACME v1 和 ACME v2 支持 ACME v2 通配符证书简单，功能强大且易于使用。你只需要 3 分钟就可以学习它。Let’s Encrypt 免费证书客户端最简单的 shell 脚本。纯粹用 Shell 编写，不依赖于 python 或官方的 Let’s Encrypt 客户端。只需一个脚本即可自动颁发，续订和安装证书。 不需要 root&#x2F;sudoer 访问权限。支持在 Docker 内使用，支持 IPv6。acme.sh 实现了 acme 协议支持的所有验证协议，一般有两种方式验证： http 和 dns 验证.</p>
<h3 id="acme-sh获取与安装"><a href="#acme-sh获取与安装" class="headerlink" title="acme.sh获取与安装"></a>acme.sh获取与安装</h3><p>github地址：<a href="https://github.com/acmesh-official/acme.sh">https://github.com/acmesh-official/acme.sh</a></p>
<h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install openssl cron socat curl unzip vim</span><br></pre></td></tr></table></figure>

<h4 id="安装acme-sh"><a href="#安装acme-sh" class="headerlink" title="安装acme.sh"></a>安装acme.sh</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://get.acme.sh | sh -s email=my@example.com  <span class="comment">#后面输入邮箱，否则会报错</span></span><br><span class="line"><span class="built_in">ls</span> -s /root/.acme.sh/acme.sh usr/local/bin/acme.sh  <span class="comment">#添加软链接</span></span><br><span class="line"><span class="comment"># echo &#x27;alias acme.sh=~/.acme.sh/acme.sh&#x27; &gt;&gt; ~/.bashrc</span></span><br><span class="line"><span class="comment"># source ~/.bashrc</span></span><br></pre></td></tr></table></figure>

<h4 id="开放防火墙端口"><a href="#开放防火墙端口" class="headerlink" title="开放防火墙端口"></a>开放防火墙端口</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -F</span><br></pre></td></tr></table></figure>

<h4 id="切换证书机构"><a href="#切换证书机构" class="headerlink" title="切换证书机构"></a>切换证书机构</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">acme.sh --set-default-ca --server letsencrypt  <span class="comment">#使用letsencrypt机构签发证书</span></span><br></pre></td></tr></table></figure>

<h4 id="申请且安装证书"><a href="#申请且安装证书" class="headerlink" title="申请且安装证书"></a>申请且安装证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 申请证书</span></span><br><span class="line">acme.sh --issue -d 你的域名 --standalone -k ec-256 <span class="comment">#使用standalone方式申请证书需要一个空闲的80端口</span></span><br><span class="line"><span class="comment"># 安装证书</span></span><br><span class="line">acme.sh --installcert -d 你的域名 --ecc --key-file 证书路径/XXX.key --fullchain-file 证书路径/XXX.crt</span><br></pre></td></tr></table></figure>

<h4 id="2-2-6-acme-sh自动保持更新"><a href="#2-2-6-acme-sh自动保持更新" class="headerlink" title="2.2.6 acme.sh自动保持更新"></a>2.2.6 acme.sh自动保持更新</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">acme.sh --upgrade --auto-upgrade <span class="comment">#由于acme协议与LetsetcryptCA都在频繁的更新，所以acme.sh工具也需保持同步</span></span><br></pre></td></tr></table></figure>

<h4 id="设置证书自动续签"><a href="#设置证书自动续签" class="headerlink" title="设置证书自动续签"></a>设置证书自动续签</h4><p>创建shell脚本：letsencryptUpdate.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">acme.sh --install-cert -d 你的域名 --ecc --key-file 证书路径/XXX.key --fullchain-file 证书路径/XXX.crt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Certficates Renewed&quot;</span></span><br><span class="line"><span class="built_in">chmod</span> +r 证书路径/XXX.key</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Read Permission Granted for Private Key&quot;</span></span><br><span class="line"><span class="comment">#此处可添加使有其证书的其它服务</span></span><br><span class="line"><span class="comment">#systemctl restart XXXX.service</span></span><br><span class="line"><span class="comment">#echo &quot;XXX Restarted&quot;</span></span><br></pre></td></tr></table></figure>

<p>保存后，添加可执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chomd +x letsencryptUpdate.sh</span><br></pre></td></tr></table></figure>

<p>设置自动任务<code>crontab -e</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 1 1 * * bash 路径/letsencryptUpdate.sh</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>cert</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux防火墙</title>
    <url>/2022/11/04/Linux%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<h2 id="Oracle-Cloud-VPS开放所有端口并关闭Ubuntu防火墙"><a href="#Oracle-Cloud-VPS开放所有端口并关闭Ubuntu防火墙" class="headerlink" title="Oracle Cloud VPS开放所有端口并关闭Ubuntu防火墙"></a>Oracle Cloud VPS开放所有端口并关闭Ubuntu防火墙</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开放所有端口</span></span><br><span class="line">iptables -P INPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -F</span><br><span class="line"><span class="comment">#删除防火墙</span></span><br><span class="line">apt purge netfilter-persistent &amp;&amp; reboot</span><br><span class="line">或 <span class="built_in">rm</span> -rf /etc/iptables &amp;&amp; reboot</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac双系统时间不同步的问题解决</title>
    <url>/2017/11/06/Mac-Win-time/</url>
    <content><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在安装了Mac与Windws双系统后，发现两套系统的时间不一致两者相差8小时，这是为什么呢？这是因为Windows与Mac系统对于CMOS记录的时钟采取了不同的定义。Windows将CMOS时钟作为本地时间来看待，而Mac系统将CMOS时钟作为UTC标准时间来看待，也就是格林威志时间。</p>
<h3 id="解决方法：（修改Windows注册表）"><a href="#解决方法：（修改Windows注册表）" class="headerlink" title="解决方法：（修改Windows注册表）"></a>解决方法：（修改Windows注册表）</h3><p>将Windows的缺省对待CMOS的方式改成UTC，也就是和MacOSX一致</p>
<p>修改Windows的注册表，定位到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\</span><br></pre></td></tr></table></figure>
<p>添加一个名为”RealTimeIsUniversal”的DWORD项，把值设为1。<br>这样你在Windows和Mac OSX下将本地时区都设到北京时间，不论是Windows还是MacOSX同步过时间后，都不会影响到另一边。</p>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Mac OS</tag>
        <tag>排错</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS brew国内源</title>
    <url>/2022/03/26/MacOSbrew%E5%9B%BD%E5%86%85%E6%BA%90/</url>
    <content><![CDATA[<p>MacOS中更改为国内源</p>
<ul>
<li>清华大学源</li>
<li>中科大源</li>
<li>阿里云</li>
<li>腾讯源</li>
</ul>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">brew</td>
<td align="center">Homebew源代码仓库</td>
</tr>
<tr>
<td align="center">home-brew-core</td>
<td align="center">Homebrew核心软件仓库</td>
</tr>
<tr>
<td align="center">homebrew-bottles</td>
<td align="center">Homebre预编译二进制软件包</td>
</tr>
<tr>
<td align="center">homebrew-cask</td>
<td align="center">提供macOS应用和大型二进制文件</td>
</tr>
</tbody></table>
<h1 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 替换各个源</span><br><span class="line">$ git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span><br><span class="line">$ git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br><span class="line">$ git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git</span><br><span class="line"></span><br><span class="line"># zsh 替换 brew bintray 镜像</span><br><span class="line">$ echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line">$ source ~/.zshrc</span><br><span class="line"></span><br><span class="line"># bash 替换 brew bintray 镜像</span><br><span class="line">$ echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">$ source ~/.bash_profile</span><br><span class="line"></span><br><span class="line"># 刷新源</span><br><span class="line">$ brew update</span><br></pre></td></tr></table></figure>

<h1 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a>中科大源</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 替换各个源</span><br><span class="line">$ git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line">$ git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line">$ git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line"></span><br><span class="line"># zsh 替换 brew bintray 镜像</span><br><span class="line">$ echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line">$ source ~/.zshrc</span><br><span class="line"></span><br><span class="line"># bash 替换 brew bintray 镜像</span><br><span class="line">$ echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">$ source ~/.bash_profile</span><br><span class="line"></span><br><span class="line"># 刷新源</span><br><span class="line">$ brew update</span><br></pre></td></tr></table></figure>



<h1 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a>阿里源</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看 brew.git 当前源</span><br><span class="line">$ cd &quot;$(brew --repo)&quot; &amp;&amp; git remote -v</span><br><span class="line">origin    https://github.com/Homebrew/brew.git (fetch)</span><br><span class="line">origin    https://github.com/Homebrew/brew.git (push)</span><br><span class="line"></span><br><span class="line"># 查看 homebrew-core.git 当前源</span><br><span class="line">$ cd &quot;$(brew --repo homebrew/core)&quot; &amp;&amp; git remote -v</span><br><span class="line">origin    https://github.com/Homebrew/homebrew-core.git (fetch)</span><br><span class="line">origin    https://github.com/Homebrew/homebrew-core.git (push)</span><br><span class="line"></span><br><span class="line"># 修改 brew.git 为阿里源</span><br><span class="line">$ git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"># 修改 homebrew-core.git 为阿里源</span><br><span class="line">$ git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"># zsh 替换 brew bintray 镜像</span><br><span class="line">$ echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line">$ source ~/.zshrc</span><br><span class="line"></span><br><span class="line"># bash 替换 brew bintray 镜像</span><br><span class="line">$ echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">$ source ~/.bash_profile</span><br><span class="line"></span><br><span class="line"># 刷新源</span><br><span class="line">$ brew update</span><br></pre></td></tr></table></figure>

<h1 id="腾讯源"><a href="#腾讯源" class="headerlink" title="腾讯源"></a>腾讯源</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">替换brew.git:</span><br><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://mirrors.cloud.tencent.com/homebrew/brew.git</span><br><span class="line"></span><br><span class="line">替换homebrew-core.git:</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://mirrors.cloud.tencent.com/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"># 刷新源</span><br><span class="line">brew update</span><br></pre></td></tr></table></figure>



<h1 id="Homebrew-Bottles源"><a href="#Homebrew-Bottles源" class="headerlink" title="Homebrew Bottles源"></a>Homebrew Bottles源</h1><p>Homebrew预编译二进制软件包</p>
<h2 id="临时替换"><a href="#临时替换" class="headerlink" title="临时替换"></a>临时替换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HOMEBREW_BOTTLE_DOMAIN=&quot;https://mirrors.ustc.edu.cn/homebrew-bottles&quot;</span><br></pre></td></tr></table></figure>

<h2 id="永久替换"><a href="#永久替换" class="headerlink" title="永久替换"></a>永久替换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 对于 bash 用户</span><br><span class="line">echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=&quot;https://mirrors.ustc.edu.cn/homebrew-bottles&quot;&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line"></span><br><span class="line"># 对于 zsh 用户</span><br><span class="line">echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=&quot;https://mirrors.ustc.edu.cn/homebrew-bottles&quot;&#x27; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>



<h1 id="Homebrew-Cask源"><a href="#Homebrew-Cask源" class="headerlink" title="Homebrew Cask源"></a>Homebrew Cask源</h1><p> Homebrew cask软件仓库，提供MacOS应用和大型二进制文件，请先运行<code>brew update</code>将<code>brew</code>更新至3.2.17或以上版本</p>
<h2 id="重置为官方地址"><a href="#重置为官方地址" class="headerlink" title="重置为官方地址"></a>重置为官方地址</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew tap --custom-remote --force-auto-update homebrew/cask https://github.com/Homebrew/homebrew-cask</span><br></pre></td></tr></table></figure>



<h1 id="重置为官方源"><a href="#重置为官方源" class="headerlink" title="重置为官方源"></a>重置为官方源</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 重置 brew.git 为官方源</span><br><span class="line">$ git -C &quot;$(brew --repo)&quot; remote set-url origin https://github.com/Homebrew/brew.git</span><br><span class="line"></span><br><span class="line"># 重置 homebrew-core.git 为官方源</span><br><span class="line">$ git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"># 重置 homebrew-cask.git 为官方源</span><br><span class="line">$ git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask</span><br><span class="line"></span><br><span class="line"># zsh 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置</span><br><span class="line">$ vi ~/.zshrc</span><br><span class="line"># export HOMEBREW_BOTTLE_DOMAIN=xxxxxxxxx</span><br><span class="line"></span><br><span class="line"># bash 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置</span><br><span class="line">$ vi ~/.bash_profile</span><br><span class="line"># export HOMEBREW_BOTTLE_DOMAIN=xxxxxxxxx</span><br><span class="line"></span><br><span class="line"># 刷新源</span><br><span class="line">$ brew update</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenWrt搭建OpenConnect VPN</title>
    <url>/2017/08/31/Openvpn-OpenConnect/</url>
    <content><![CDATA[<h1 id="1、安装Ocserv"><a href="#1、安装Ocserv" class="headerlink" title="1、安装Ocserv"></a>1、安装Ocserv</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install ocserv luci-app-ocserv</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>安装完成，重启之后luci的服务界面就会出现“OpenConnect VPN”选项</p>
<span id="more"></span>
<h1 id="2、配置Server端"><a href="#2、配置Server端" class="headerlink" title="2、配置Server端"></a>2、配置Server端</h1><p>可以通过luci界面配置，比较直观和容易。<br>&amp;emsp;&amp;emsp;通过“服务”–“OpenConnect VPN”，进到“服务器设置”的“常规设置”，相关参数如下：</p>
<ol>
<li>Enable Server: 打钩表示启动服务</li>
<li>User Authentication: 用户认证方式，选择plain，表示使用OpenWrt路由器上面定义的用户名和密码登录VPN</li>
<li>Firewall Zone： 选择lan</li>
<li>端口：默认是443，可以修改为其他端口</li>
<li>最大连接数：默认为8，这里的值是设定有多少个VPN可以连进来</li>
<li>Max same Clients：默认为2，这里的值会限定同一个账号能够登录几次</li>
<li>Enable compression：打勾表示启用压缩</li>
<li>Enable UDP：打勾表示启用UDP协议</li>
<li>AnyConnect client compatibility：打勾表示允许Cisco的AnyConnect client作为VPN客户端软件连接。</li>
<li>VPN IPv4-Network-Address：这里定义的是VPN客户端连到内网之后，获得的IP地址的网段范围。</li>
<li>VPN-IPv4-Netmask：这里定义的是VPN客户端连到内网之后子网掩码范围</li>
</ol>
<p>客户端获取IP地址，有两种设置方法：</p>
<ul>
<li>VPN网段和OpenWrt所在的网段不同，用这种方法要在OpenWrt路由表里面添加2个路由网段。<br/>例如：OpenWrt的路由器IP地址为：192.168.111.1 子网掩码：255.255.255.0<br/>VPN的地址可以设置为：192.168.112.0 子网掩码：255.255.255.0</li>
<li>VPN网段和OpenWrt所在的网段一样（使用其中某一段子网IP地址），这种情况下路由表里的路由只需要添加一个，但是启用所有接口上的ARP代理功能<br/>例如：OpenWrt的路由器IP地址为192.168.111.1 子网掩码255.255.255.0 <br/>VPN的地址可以设置为：192.168.111.16 子网掩码255.255.255.240<br/>（这里192.168.111.16&#x2F;28其实是一个网络号，VPN服务器将会使用第一个地址，即192.168.111.17&#x2F;29，VPN客户端将使用剩余的其中一个地址18-30，这里的参都配置可以供13个客户端使用。OpenWrt所在的网络的DHCP分配的地址要排除这段里面的IP不配给客户端16-31，防止IP地址冲突）</li>
</ul>
<h1 id="3、配置DNS-SERVER"><a href="#3、配置DNS-SERVER" class="headerlink" title="3、配置DNS SERVER"></a>3、配置DNS SERVER</h1><p>VPN线路连接成功之后，因为默认的模式“分离隧道”，所以客户羰的DNS SERVER将会被这里的配置所覆盖。一般情况下，家的的OpenWrt路由器也承担DNS功能，所以这里设置为OpenWrt的路由器地址即可。</p>
<h1 id="4、配置路由表"><a href="#4、配置路由表" class="headerlink" title="4、配置路由表"></a>4、配置路由表</h1><p>这里的设置的路由表，将会分配给VPN客户端，告知VPN客户端，通过VPN线路访问这里定义的路由。一般情况下，这里只需要添加“VPN的IP网段”和“OpenWrt所在的网段”。</p>
<p>&amp;emsp;&amp;emsp;具体说明，参看上面配雷超VPN IPv4-Network-Address和VPN IPv4-Netmask的两种情况，分别定义的路由表为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一对应的路由表为</span></span><br><span class="line">192.168.111.0 255.255.255.0</span><br><span class="line">192.168.112.0 255.255.255.0</span><br><span class="line"><span class="comment"># 方法二对应的路由表为</span></span><br><span class="line">192.168.111.0 255.255.255.0</span><br></pre></td></tr></table></figure>
<div class="note success"><ul>
<li>如果这里不填写任意网段，VPN Client将使用Tunnel all Traffice模式，即设置客户端所有的流量发往OpenWrt，即新增一条默认路由到OpenWrt访问所有网络。</li>
<li>如果填写网段，VPN Client将使用split tunnel的分离隧道模式，只有指定的网段流量才通过VPN防问流向OpenWrt</li>
</ul>
</div>

<h1 id="5、配置拨号用户"><a href="#5、配置拨号用户" class="headerlink" title="5、配置拨号用户"></a>5、配置拨号用户</h1><p>当配置了用户认证方法为“plain”，并启用了OpenConnect服务之后，就可以新建用户了。新建用户很简单，只需要义用户名和密码即可。<br>&amp;emsp;&amp;emsp;在“服务”–“OpenConnect VPN”–“用户设置”–“Available users”<br><img src='1-1.PNG' style="margin : auto;" width="50%" height="50%" title="配置用户" /></p>
<h1 id="6、配置防火墙，允许从WAN访问VPN端口"><a href="#6、配置防火墙，允许从WAN访问VPN端口" class="headerlink" title="6、配置防火墙，允许从WAN访问VPN端口"></a>6、配置防火墙，允许从WAN访问VPN端口</h1><p>前面定义的端口为4433，并且允许tcp和udp两种模式，所以这两个端口都需要允许。可以通过如下命令和luci进行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config rule</span><br><span class="line">option enabled &#x27;1&#x27;</span><br><span class="line">option target &#x27;ACCEPT&#x27;</span><br><span class="line">option name &#x27;Allow SSL vpn in&#x27;</span><br><span class="line">option family &#x27;ipv4&#x27;</span><br><span class="line">option dest_port &#x27;4443&#x27;</span><br><span class="line">option src &#x27;wan&#x27;</span><br></pre></td></tr></table></figure>
<p>luci的配置为：网络–防火墙–通信规则：<br><img src='1-2.PNG' style="margin : auto;" title="配置用户" /><br>此时，VPN可以正常连接进来了，如果只需要连进来配置OpenWrt路由器，到这里已经可以了。但是如果要访问其他的内网资源，就需要以下配置。</p>
<h1 id="7、配置自定义防火墙，允许VPN的流量访问内网资源"><a href="#7、配置自定义防火墙，允许VPN的流量访问内网资源" class="headerlink" title="7、配置自定义防火墙，允许VPN的流量访问内网资源"></a>7、配置自定义防火墙，允许VPN的流量访问内网资源</h1><p>通过命令行，编辑&#x2F;etc&#x2F;firewall.user，添加如下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iptables -A input_rule -i vpns+ -j ACCEPT</span><br><span class="line">iptables -A forwarding_rule -i vpns+ -j ACCEPT</span><br><span class="line">iptables -A forwarding_rule -o vpns+ -j ACCEPT</span><br><span class="line">iptables -A output_rule -o vpns+ -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>配置完毕之后需要重启防火墙生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/firewall restart</span><br></pre></td></tr></table></figure>

<h1 id="8、启用代理ARP"><a href="#8、启用代理ARP" class="headerlink" title="8、启用代理ARP"></a>8、启用代理ARP</h1><p>如果VPN网段和OpenWrt网段处于不同的IP网段，无需开启代理ARP。但是VPN网段和OpenWrt设置为同一网段IP的情况下，虽然我们从IP的角度看，我们客户端的VPN IP网段和资源网段处于同一网段，应该可以直接访问。但实际下面，有一个虚拟的VPN接口，这两个是不则的网段，所以路由其实是不可达的。所以必须启用代理ARP功能，以供VPN IP网段和资源网段可以进行互通。通过ssh登陆OpenWrt路由器，用vi编辑器<code>/etc/sysctl.conf</code>新增如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net.ipv4.conf.all.proxy_arp=1</span><br></pre></td></tr></table></figure>
<p>然后重新加载配置，用下述命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>代理ARP是有诸多风险，建议大家还是用不同的网段配置VPN IP与openwrt网段</p>
</div>
<p>这样，open Connect VPN的服务器端就已经配置成功了。</p>
<h1 id="9、Windows-PC连接VPN方法"><a href="#9、Windows-PC连接VPN方法" class="headerlink" title="9、Windows PC连接VPN方法"></a>9、Windows PC连接VPN方法</h1><p>客户端使用Cisco AnyConnect<br><img src="1-3.jpg" title="Cisco AnyConnect客户端" width="50%" height="50%" style="margin : auto;"/><br>安装完毕之后，因为我们的域名或是IP是不是CA信任的，所以必须要取消客户端对不信任的服务器的连接。点击械下角的齿轮，按照下图提示，取消打勾<br><img src="1-4.jpg" title="Cisco AnyConnect 配置" width="50%" height="50%" style="margin : auto;"/><br>然后就可以输入IP加端口进行连接了，连接成功之后，有个不信任的提示，点击“Connect Anyway”继续；输入用户名和密码，有了banner提示点击“Accept”接收，最后再一次弹出不信任服务器的是示，点击“Connect Anyway”，即可连接成功。</p>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>OpenConnect</tag>
        <tag>OpenWrt</tag>
      </tags>
  </entry>
  <entry>
    <title>PVE虚拟机直通USB</title>
    <url>/2022/03/17/PVE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B4%E9%80%9AUSB/</url>
    <content><![CDATA[<p>在Proxmox VE(PVE)系统开启IOMMU功能实现硬件直通之前，我们要确认CPU是否支持VT-D技术;开启直通的必要条件 Intel CPU支持VT-D，同时主板要开启VT-D支持。</p>
<p>使用USB直通的主要原因是能够将几个具有相同ID的USB设备连接到不同的虚拟机上（device-1 to VM1, device-2 to VM2, etc）</p>
<span id="more"></span> 

<h2 id="USB硬件设备映射"><a href="#USB硬件设备映射" class="headerlink" title="USB硬件设备映射"></a>USB硬件设备映射</h2><h3 id="从主机上查找"><a href="#从主机上查找" class="headerlink" title="从主机上查找"></a>从主机上查找</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsusb -t</span><br><span class="line">/: Bus 05.Port 1: Dev 1, Class=root_hub, Driver=uhci_hcd/2p, 12M</span><br><span class="line">/: Bus 04.Port 1: Dev 1, Class=root_hub, Driver=uhci_hcd/2p, 12M</span><br><span class="line">/: Bus 03.Port 1: Dev 1, Class=root_hub, Driver=uhci_hcd/2p, 12M</span><br><span class="line">    |__ Port 1: Dev 4, If 0, Class=vend., Driver=usbfs, 1.5M</span><br><span class="line">    |__ Port 2: Dev 5, If 0, Class=vend., Driver=usbfs, 1.5M</span><br><span class="line">/: Bus 02.Port 1: Dev 1, Class=root_hub, Driver=uhci_hcd/2p, 12M</span><br><span class="line">/: Bus 01.Port 1: Dev 1, Class=root_hub, Driver=ehci_hcd/2p, 480M</span><br><span class="line">    |__ Port 1: Dev 2, If 0, Class=hub, Driver=hub/4p, 480M</span><br><span class="line">        |__ Port 3: Dev 5, If 0, Class=<span class="built_in">comm</span>., Driver=usbfs, 480M</span><br><span class="line">        |__ Port 3: Dev 5, If 1, Class=data, Driver=usbfs, 480M</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Example 1: Bus 3, Port 1 &#x3D;&gt; 3-1</li>
<li>Example 2: Bus 1, Port 1, Port 3 &#x3D;&gt; 1-1.3</li>
</ul>
<h2 id="将设备添加到虚拟机中"><a href="#将设备添加到虚拟机中" class="headerlink" title="将设备添加到虚拟机中"></a>将设备添加到虚拟机中</h2><h3 id="Proxmox-2-x及以后版本"><a href="#Proxmox-2-x及以后版本" class="headerlink" title="Proxmox 2.x及以后版本"></a>Proxmox 2.x及以后版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/pve/qemu-server/&lt;VM_ID&gt;.conf</span><br></pre></td></tr></table></figure>

<p>配置文件中添加语句（如上例中总线与端口）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usb0: host=3-1</span><br><span class="line">usb1: host=1-1.3</span><br></pre></td></tr></table></figure>

<h3 id="Proxmox-1-x"><a href="#Proxmox-1-x" class="headerlink" title="Proxmox 1.x"></a>Proxmox 1.x</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">args: -device usb-host,hostbus=3,hostport=1</span><br><span class="line">args: -device usb-host,hostbus=1,hostport=1.3</span><br></pre></td></tr></table></figure>



<h2 id="停止并重新启动虚拟机"><a href="#停止并重新启动虚拟机" class="headerlink" title="停止并重新启动虚拟机"></a>停止并重新启动虚拟机</h2><p>需要停止虚拟机并启动，检查USB设备是否被虚拟机看到</p>
<h3 id="通过Qemu-x2F-KVM工具检验虚拟机的USB设备"><a href="#通过Qemu-x2F-KVM工具检验虚拟机的USB设备" class="headerlink" title="通过Qemu&#x2F;KVM工具检验虚拟机的USB设备"></a>通过Qemu&#x2F;KVM工具检验虚拟机的USB设备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qm monitor &lt;VM_ID&gt;</span><br><span class="line">qm&gt; info usbhost</span><br><span class="line"> Bus 3, Addr 2, Port 1.2, Speed 1.5 Mb/s</span><br><span class="line">   Vendor Specific: USB device 0529:0001, HASP 2.17</span><br><span class="line"> Bus 5, Addr 3, Port 2, Speed 12 Mb/s</span><br><span class="line">   Class 00: USB device 0624:0248, USB Composite Device-0</span><br><span class="line">qm&gt; info usb</span><br><span class="line"> Device 0.2, Port 1, Speed 12 Mb/s, Product QEMU USB Tablet</span><br><span class="line"> Device 0.3, Port 2, Speed 12 Mb/s, Product QEMU USB Hub</span><br><span class="line"> Device 1.1, Port 1, Speed 1.5 Mb/s, Product HASP 2.17</span><br><span class="line"> Device 1.0, Port 2, Speed 480 Mb/s, Product USB Host Device</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>PVE</tag>
      </tags>
  </entry>
  <entry>
    <title>PorxyChains</title>
    <url>/2022/03/26/PorxyChains/</url>
    <content><![CDATA[<p>MacOS系统下使用Proxychains-ng进行命令行下代理</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install proxychains-ng</span><br></pre></td></tr></table></figure>

<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/rofl0r/proxychains-ng</span><br><span class="line">cd proxychains-ng</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">sudo make install-config  # 安装proxychains.conf配置文件</span><br></pre></td></tr></table></figure>

<p>使用普通用户make install需要改变configure文件再进行编译安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd configure </span><br><span class="line">vi config.mak</span><br><span class="line">将：</span><br><span class="line">bindir = /usr/bin</span><br><span class="line">libdir = /usr/lib</span><br><span class="line">修改为：</span><br><span class="line">bindir=/usr/local/bin</span><br><span class="line">libdir=/usr/local/lib</span><br></pre></td></tr></table></figure>

<span id="more"></span> 分隔符不要忘了！！！！！！！！！

<h2 id="关闭SIP"><a href="#关闭SIP" class="headerlink" title="关闭SIP"></a>关闭SIP</h2><p>macOS 10.11 后下由于开启了 SIP（System Integrity Protection） 会导致命令行下 proxychains-ng 代理的模式失效，如果使用 proxychains-ng 这种简单的方法，就需要先关闭 SIP。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/etc/proxychains.conf</span><br><span class="line">vi proxychains.conf</span><br></pre></td></tr></table></figure>

<p>在[ProxyList]下添加socks5代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 代理端口一定要和shadowsocks中的保持一致</span><br><span class="line"># 如果有不明白的可以查看93～110</span><br><span class="line">[ProxyList]</span><br><span class="line">socks5 127.0.0.1 1080</span><br><span class="line"># http 127.0.0.1 1235 (me)</span><br><span class="line"># add proxy here ...</span><br><span class="line"># meanwile</span><br><span class="line"># defaults set to &quot;tor&quot;</span><br><span class="line"># socks4        127.0.0.1 9050</span><br></pre></td></tr></table></figure>

<h1 id="Proxychains-ng使用"><a href="#Proxychains-ng使用" class="headerlink" title="Proxychains-ng使用"></a>Proxychains-ng使用</h1><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 curl cip.cc</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>例如，Homebrew更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 brew update</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Python脚本后台运行的几种方式</title>
    <url>/2018/05/17/Python%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="python后台运行方式"><a href="#python后台运行方式" class="headerlink" title="python后台运行方式"></a>python后台运行方式</h1><p>在linux中执行python程序的时候，我们通常会用python xx.py命令来执行，但这样执行的程序在关闭linux的控制台后，执行的程序就会退出，要让程序关闭后继续执行该怎么办？<br>要让python程序在关闭控制台后继续执行，我们需要使用nohub命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">nohup</span> python -u xx.py &gt; log.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>1 <code>1</code>是标准输出（STDOUT）的文件描述符，<code>2</code>是标准错误（STDERR）的文件描述符<code>1&gt;log.out</code>简化为<code>&gt;log.out</code>，表示把标准输出重定向到log.out这个文件<br>2 <code>2&gt;&amp;1</code>表示把标准错误重定向到标准输出，这里<code>&amp;1</code>表示标准输出，为什么需要将标准错误重向到标准输出？这是因为标准错误没有缓冲区，而STOUT有，这就会导致log.out文件被两次打开，而STDOUT和STDERR将会竞争覆盖。</p>
<span id="more"></span>
<h1 id="方法一：脚本后加-amp"><a href="#方法一：脚本后加-amp" class="headerlink" title="方法一：脚本后加&amp;"></a>方法一：脚本后加&amp;</h1><p>加了&amp;以后可以使脚本在后台运行，这样的话你就可以继续工作了，但是有一个问题就是你关闭终端连接后，脚本就会停止运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python updatetest &amp;</span><br></pre></td></tr></table></figure>
<h1 id="方法二：使用nohup在后台执行命令"><a href="#方法二：使用nohup在后台执行命令" class="headerlink" title="方法二：使用nohup在后台执行命令"></a>方法二：使用nohup在后台执行命令</h1><p>使用&amp;符号在后台执行命令或脚本后，如果你退出登录，这个命令就会被自动终止掉。要避免这种情况，你可以使用nohup命令，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">nohup</span> ./my-shell-script.sh &amp;</span><br></pre></td></tr></table></figure>
<h1 id="方法三：使用screen执行命令"><a href="#方法三：使用screen执行命令" class="headerlink" title="方法三：使用screen执行命令"></a>方法三：使用screen执行命令</h1><p>通过nohup和&amp;符号在后台执行命令后，即使你退出登录，这个命令也会一直执行。但是，你无法重新连接到这个会话，要想重新连接到这个会话，你可以使用screen命令。<br>linux和screen命令提供了分离和重新连接一个会话的功能。当你重新连接这个会话的时候，你的终端和你分离的时候一模一样。</p>
<h1 id="方法四：使用at将一个命令作为批处理执行"><a href="#方法四：使用at将一个命令作为批处理执行" class="headerlink" title="方法四：使用at将一个命令作为批处理执行"></a>方法四：使用at将一个命令作为批处理执行</h1><p>使用at命令，你可让一个命令在指定的日期和时间运行，使用要在明天上午10点在后台执行备份脚本，执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ at -f backup.sh 10 am tomorrow</span><br></pre></td></tr></table></figure>
<h1 id="方法五：使用watch连续地执行一个命令"><a href="#方法五：使用watch连续地执行一个命令" class="headerlink" title="方法五：使用watch连续地执行一个命令"></a>方法五：使用watch连续地执行一个命令</h1><p>要想按一个固定的间隔不停地执行一个命令，可以使用watch命令，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ watch <span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure>
<p>另外查看进程确认脚本是否在继续运行的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps -ef | grep 脚本名</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Samba配置</title>
    <url>/2020/05/14/Samba%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="1-Samba服务器"><a href="#1-Samba服务器" class="headerlink" title="1. Samba服务器"></a>1. Samba服务器</h1><h2 id="1-1-创建samba用户"><a href="#1-1-创建samba用户" class="headerlink" title="1.1 创建samba用户"></a>1.1 创建samba用户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">$ sudo smbpasswd -a smbuser</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="1-2-重启samba服务"><a href="#1-2-重启samba服务" class="headerlink" title="1.2. 重启samba服务"></a>1.2. 重启samba服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl restart smbd # 提供文件和打印服务、授权与被授权服务</span><br><span class="line">$ sudo systemctl restart nmbd # 提供名字解析、浏览服务</span><br></pre></td></tr></table></figure>

<h2 id="1-3-客户端访问测试"><a href="#1-3-客户端访问测试" class="headerlink" title="1.3. 客户端访问测试"></a>1.3. 客户端访问测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ smbclient -L //localhose/share</span><br></pre></td></tr></table></figure>

<h2 id="1-4-远程挂载共享目录"><a href="#1-4-远程挂载共享目录" class="headerlink" title="1.4 远程挂载共享目录"></a>1.4 远程挂载共享目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mount.cifs //server-ip/sharename ./mnt/filename -o username=XXX,password=XXX,vers=1.0</span><br><span class="line"></span><br><span class="line">$ sudo umount /mnt/filename   # 取消挂载</span><br><span class="line">$ sudo tail -f /var/log/kern.log # 查看错误日志</span><br></pre></td></tr></table></figure>



<h1 id="2-‘smb-conf’配置文件"><a href="#2-‘smb-conf’配置文件" class="headerlink" title="2. ‘smb.conf’配置文件"></a>2. ‘smb.conf’配置文件</h1><h2 id="2-1-共享文件夹举例"><a href="#2-1-共享文件夹举例" class="headerlink" title="2.1 共享文件夹举例"></a>2.1 共享文件夹举例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[home] <span class="comment"># 这个使用者资源共享部分：也就是用户家目录</span></span><br><span class="line"></span><br><span class="line">[share]</span><br><span class="line">    path=/home/share <span class="comment"># 共享路径</span></span><br><span class="line">    browseable = <span class="built_in">yes</span> <span class="comment"># 设置该共享目录是否可显示</span></span><br><span class="line">    writable = <span class="built_in">yes</span>|no  <span class="comment"># 指定了这个目录缺省是否可写，也可以用readonly=no来设置可写</span></span><br><span class="line">    comment = smb share <span class="built_in">test</span> <span class="comment"># 该共享的备注</span></span><br><span class="line">    allow hosts = host(subnet) <span class="comment"># 设置该Samba服务器允许的工作组或者域</span></span><br><span class="line">    deny hosts = host(subnet) <span class="comment"># 设置该Sambe服务器拒绝的工作组或者域</span></span><br><span class="line">    available = <span class="built_in">yes</span>|no <span class="comment"># 设置该共享目录是否可用</span></span><br><span class="line">    public = <span class="built_in">yes</span>|no <span class="comment"># 指明该共享资源是否能给游客账号访问, guest ok = yes其实和public = yes是一样的</span></span><br><span class="line">    user = user, @group <span class="comment"># user设置所有可能使用该共享资源的用户，也可以用@group代表group这个组的所有成员，不同的项目之间用空格或者逗号隔开</span></span><br><span class="line">    valid user = user, @group <span class="comment"># 指定能够使用该共享资源的用户和组</span></span><br><span class="line">    invalid user = user, @group <span class="comment"># 指定不能够使用该共享资源的用户和组</span></span><br><span class="line">    <span class="built_in">read</span> list = user, @group <span class="comment"># 指定只能读取该共享资源的用户和组</span></span><br><span class="line">    write list = user, @group <span class="comment"># 指定能读取和写该共享资源的用户和组</span></span><br><span class="line">    admin list = user, @group <span class="comment"># 指定能管理该共享资源（包括读写和权限赋予等）的用户和组</span></span><br><span class="line">    hide dot files = <span class="built_in">yes</span>|no <span class="comment"># 指明是否像UNIX那样隐藏以“.”号开头的文件</span></span><br><span class="line">    create mode = 0755 <span class="comment"># 指明新建立的文件属性，一般是0755</span></span><br><span class="line">    directory mode = 0755 <span class="comment"># 指明新建立目录的属性，一般是0755</span></span><br><span class="line">    <span class="built_in">sync</span> always = <span class="built_in">yes</span>|no <span class="comment"># 指明对该共享资源进行写操作后是否进行同步操作，Samba默认为异步写入。smbd写入内存缓冲区，稍后将缓冲区刷新到磁盘。</span></span><br><span class="line">    short preserve <span class="keyword">case</span> = <span class="built_in">yes</span>|no <span class="comment"># 指明是否区分文件名大小写</span></span><br><span class="line">    preserve <span class="keyword">case</span> = <span class="built_in">yes</span>|no <span class="comment"># 指明是否保持大小写</span></span><br><span class="line">    <span class="keyword">case</span> sensitive = <span class="built_in">yes</span>|no <span class="comment"># 指明是否对大小写敏感，一般选no，不然可能引起错误</span></span><br><span class="line">    mangle <span class="keyword">case</span> = <span class="built_in">yes</span>|no <span class="comment"># 指明混合大小写</span></span><br><span class="line">    default <span class="keyword">case</span> = upper|lower <span class="comment"># 指明缺省文件名是全部大写还是小写</span></span><br><span class="line">    force user = testuser <span class="comment"># 强制把建立文件的属主是谁。如果我有一个目录，让guest可以写那么它就可以删除，如果我用force user=testuser强制建立文件的属主是testuser,同时限制create mask = 0755，这样guest就不能删除了</span></span><br><span class="line">    wide links = <span class="built_in">yes</span>|no <span class="comment"># 指明是否允许共享外符号连接</span></span><br><span class="line">    max connections = 100 <span class="comment"># 设定最大同时连接数</span></span><br><span class="line">    delete <span class="built_in">readonly</span> <span class="comment"># 指明能否删除共享资源里面已经被定义为只读的文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>%S &#x3D; 当前服务名（如果有的话）<br>%P &#x3D; 当前服务的根目录（如果有的话）<br>%u &#x3D; 当前服务的用户名（如果有的话）<br>%g &#x3D; 当前用户说在的主工作组<br>%U &#x3D; 当前对话的用户名<br>%G &#x3D; 当前对话的用户的主工作组<br>%H &#x3D; 当前服务的用户的Home目录<br>%v &#x3D; Samba服务的版本号。<br>%h &#x3D; 运行Samba服务机器的主机名<br>%m &#x3D; 客户机的NETBIOS名称<br>%L &#x3D; 服务器的NETBIOS名称<br>%M &#x3D; 客户机的主机名<br>%N &#x3D; NIS服务器名<br>%p &#x3D; NIS服务的Home目录<br>%R &#x3D; 说采用的协议等级(值可以是CORE, COREPLUS, LANMAN1, LANMAN2，NT1)<br>%d &#x3D; 当前服务进程的ID<br>%a &#x3D; 客户机的结构（只能识别几项：Samba，WfWg，WinNT，Win95）<br>%I &#x3D; 客户机的IP<br>%T &#x3D; 当前日期和时间<br>hosts allow &#x3D; 网络或者主机</p>
<h1 id="3-针对指定有权限的可用可见目录"><a href="#3-针对指定有权限的可用可见目录" class="headerlink" title="3. 针对指定有权限的可用可见目录"></a>3. 针对指定有权限的可用可见目录</h1><p>引用子配置文件，在引用子配置文件有二种方法：</p>
<ul>
<li>在[global]标签下加入参数：config file&#x3D;&#x2F;etc&#x2F;samba&#x2F;smb.conf.%U</li>
<li>在[include]标签下加入参数：include&#x3D;&#x2F;etc&#x2F;samba&#x2F;smb.conf.%U</li>
</ul>
<p>他们的区别是：使用config file时，当以aa身份访问samba服务器，只能看到aa，其他在smb.conf中定义的共享资源都无法看到；使用include时，当以aa身份访问samba服务器，除了可以看到aa，其它在sam.conf中定义的共享也可以看到。</p>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue学习笔记</title>
    <url>/2023/01/05/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="指令：是带有v-前缀的特殊属性"><a href="#指令：是带有v-前缀的特殊属性" class="headerlink" title="指令：是带有v-前缀的特殊属性"></a>指令：是带有v-前缀的特殊属性</h1><ul>
<li><p>v-bind动态绑定属性</p>
</li>
<li><p>v-if动态创建与删除</p>
</li>
<li><p>v-show动态显示隐藏</p>
</li>
<li><p>v-on:click绑定事件</p>
</li>
<li><p>v-for遍历</p>
</li>
<li><p>v-model双向绑定表单</p>
</li>
</ul>
<h1 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h1><p>v-bind:src –&gt; :src</p>
<p>v-bind:click–&gt;@click</p>
<span id="more"></span>



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>通过阿里云实现DDNS解析</title>
    <url>/2017/09/01/aliyunddns/</url>
    <content><![CDATA[<h1 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h1><ul>
<li>Python 2.7</li>
<li>curl</li>
<li>Access Key ID</li>
<li>Access Key Secret</li>
<li>账号ID</li>
<li>windows环境需要iconv<span id="more"></span></li>
</ul>
<h2 id="1-1、python安装"><a href="#1-1、python安装" class="headerlink" title="1.1、python安装"></a>1.1、python安装</h2><p>由于阿里云python SDK使用Python2.7编写。所以环境请准备Python2.7.X，使用Python3.0将会报错</p>
<h3 id="1-1-1、Windows"><a href="#1-1-1、Windows" class="headerlink" title="1.1.1、Windows"></a>1.1.1、Windows</h3><p>至官网下载Python2.7.x版本<a href="https://www.python.org/ftp/python/2.7.13/python-2.7.13.amd64.msi" title="" target="">下载</a>安装即可。</p>
<h2 id="1-2、阿里云SDK安装"><a href="#1-2、阿里云SDK安装" class="headerlink" title="1.2、阿里云SDK安装"></a>1.2、阿里云SDK安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install aliyun-python-sdk-alidns</span><br></pre></td></tr></table></figure>
<h2 id="1-3、Windows环境下curl安装"><a href="#1-3、Windows环境下curl安装" class="headerlink" title="1.3、Windows环境下curl安装"></a>1.3、Windows环境下curl安装</h2><p>curl官网下载，windows版本<a href="https://curl.haxx.se/download/curl-7.55.1.zip" title="" target="">下载地址</a></p>
<h3 id="1-3-1、解决Windows环境下curl乱码的问题"><a href="#1-3-1、解决Windows环境下curl乱码的问题" class="headerlink" title="1.3.1、解决Windows环境下curl乱码的问题"></a>1.3.1、解决Windows环境下curl乱码的问题</h3><p>如题，在Windows环境下控制台输出是乱码，解决方法是下载iconv<a href="http://gnuwin32.sourceforge.net/packages/libiconv.htm" title="" target="">下载地址</a><br><img src="1-1.PNG"  title='iconv for windows' ><br>接下来，需要安装并设置环境变量，最后输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cur -s ip.cn | iconv -f utf-8 -t gbk</span><br></pre></td></tr></table></figure>
<h1 id="2、关键信息"><a href="#2、关键信息" class="headerlink" title="2、关键信息"></a>2、关键信息</h1><p>通过脚本更新DNS记录需要向个关键的信息，如下：</p>
<ol>
<li>一级域名（你的域名）</li>
<li>主机记录（二级域名）</li>
<li>记录类型 （你的本地IP地址）</li>
<li>记录ID （这个解析记录的ID）</li>
<li>记录TTL （记录有效生存时间）</li>
</ol>
<h2 id="2-1、完整脚本"><a href="#2-1、完整脚本" class="headerlink" title="2.1、完整脚本"></a>2.1、完整脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aliyunsdkalidns.request.v20150109 <span class="keyword">import</span> UpdateDomainRecordRequest, DescribeDomainRecordsRequest, \</span><br><span class="line">    DescribeDomainRecordInfoRequest</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"></span><br><span class="line"><span class="comment">#请填写你的Access Key ID，阿里云控制台获取</span></span><br><span class="line">access_key_id = <span class="string">&quot;XXXXXXXXXXXX&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#请填写你的Access Key Secret，阿里云控制台获取</span></span><br><span class="line">access_Key_secret = <span class="string">&quot;XXXXXXXXXXXX&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#请填写你的账号ID，阿里云控制台获取</span></span><br><span class="line">account_id = <span class="string">&quot;XXXXXXXX&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果选择yes，则运行程序后仅现实域名信息，并不会更新记录，用于获取解析记录ID。</span></span><br><span class="line"><span class="comment">#如果选择NO，则运行程序后不显示域名信息，仅更新记录</span></span><br><span class="line">i_dont_know_record_id = <span class="string">&#x27;no&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#请填写你的一级域名</span></span><br><span class="line">rc_domain = <span class="string">&#x27;XXXXXX.XXXXX&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#请填写你的主机记录</span></span><br><span class="line">rc_rr = <span class="string">&#x27;XXXXXXX&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#请填写你的记录类型，DDNS请填写A，表示A记录</span></span><br><span class="line">rc_type = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#请填写主机记录ID，需要通过解析记录来获取，也就是check_records返回值</span></span><br><span class="line">rc_record_id = <span class="string">&#x27;XXXXXXXXXX&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#请填写解析有效生存时间TTL，单位：秒。</span></span><br><span class="line">rc_ttl = <span class="string">&#x27;600&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#请填写返还内容格式，json，xml</span></span><br><span class="line">rc_format = <span class="string">&#x27;json&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_ip</span>():</span><br><span class="line">    get_ip_method = os.popen(<span class="string">&#x27;curl -s ip.cn | iconv -f utf-8 -t gbk&#x27;</span>)</span><br><span class="line">    get_ip_responses = get_ip_method.readlines()[<span class="number">0</span>]</span><br><span class="line">    get_ip_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+\.\d+\.\d+\.\d+&#x27;</span>)</span><br><span class="line">    get_ip_value = get_ip_pattern.findall(get_ip_responses)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> get_ip_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_records</span>(<span class="params">dns_domain</span>):</span><br><span class="line">    clt = client.AcsClient(access_key_id, access_Key_secret, <span class="string">&#x27;cn-hangzhou&#x27;</span>)</span><br><span class="line">    request = DescribeDomainRecordsRequest.DescribeDomainRecordsRequest()</span><br><span class="line">    request.set_DomainName(dns_domain)</span><br><span class="line">    request.set_accept_format(rc_format)</span><br><span class="line">    result = clt.do_action(request)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">old_ip</span>():</span><br><span class="line">    clt = client.AcsClient(access_key_id, access_Key_secret, <span class="string">&#x27;cn-hangzhou&#x27;</span>)</span><br><span class="line">    request = DescribeDomainRecordInfoRequest.DescribeDomainRecordInfoRequest()</span><br><span class="line">    request.set_RecordId(rc_record_id)</span><br><span class="line">    request.set_accept_format(rc_format)</span><br><span class="line">    result = clt.do_action(request)</span><br><span class="line">    result = json.JSONDecoder().decode(result)</span><br><span class="line">    result = result[<span class="string">&#x27;Value&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_dns</span>(<span class="params">dns_rr, dns_type, dns_value, dns_record_id, dns_ttl, dns_format</span>):</span><br><span class="line">    clt = client.AcsClient(access_key_id, access_Key_secret, <span class="string">&#x27;cn-hangzhou&#x27;</span>)</span><br><span class="line">    request = UpdateDomainRecordRequest.UpdateDomainRecordRequest()</span><br><span class="line">    request.set_RR(dns_rr)</span><br><span class="line">    request.set_Type(dns_type)</span><br><span class="line">    request.set_Value(dns_value)</span><br><span class="line">    request.set_RecordId(dns_record_id)</span><br><span class="line">    request.set_TTL(dns_ttl)</span><br><span class="line">    request.set_accept_format(dns_format)</span><br><span class="line">    result = clt.do_action(request)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_to_file</span>():</span><br><span class="line">    time_now = datetime.now().strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">    current_script_path = sys.path[<span class="number">7</span>]</span><br><span class="line">    <span class="built_in">print</span> current_script_path</span><br><span class="line">    log_file = current_script_path + <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;aliyun_ddns_log.txt&#x27;</span></span><br><span class="line">    write = <span class="built_in">open</span>(log_file, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    write.write(time_now + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(rc_value_old) + <span class="string">&#x27;------&gt;&#x27;</span>  + <span class="built_in">str</span>(rc_value) + <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    write.close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i_dont_know_record_id == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> check_records(rc_domain)</span><br><span class="line"><span class="keyword">elif</span> i_dont_know_record_id == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">    rc_value = my_ip()</span><br><span class="line">    rc_value_old = old_ip()</span><br><span class="line">    <span class="keyword">if</span> rc_value_old == rc_value:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;The specified value of parameter Value is the same as old&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> update_dns(rc_rr, rc_type, rc_value, rc_record_id, rc_ttl, rc_format)</span><br><span class="line">        write_to_file()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>AppleTV伪装证书</title>
    <url>/2018/09/26/appletv-cert/</url>
    <content><![CDATA[<h2 id="1-AppleTV伪装预告片证书"><a href="#1-AppleTV伪装预告片证书" class="headerlink" title="1. AppleTV伪装预告片证书"></a>1. AppleTV伪装预告片证书</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ openssl req -new -nodes -newkey rsa:2048 -out ~/Desktop/trailers.pem -keyout ~/Desktop/trailers.key -x509 -days 7300 -subj &quot;/C=US/CN=trailers.apple.com&quot;</span><br></pre></td></tr></table></figure>
<p>这将在桌面上创建两个文件：trailers.key和trailers.pem。下一步运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ openssl x509 -in ~/Desktop/trailers.pem -outform der -out ~/Desktop/trailers.cer &amp;&amp; cat ~/Desktop/trailers.key &gt;&gt; ~/Desktop/trailers.pem</span><br></pre></td></tr></table></figure>
<p>执行完上面的命令，您将得到3个证书文件</p>
<span id="more"></span>

<h2 id="2-使用Apple-Configuration创建项目"><a href="#2-使用Apple-Configuration创建项目" class="headerlink" title="2. 使用Apple Configuration创建项目"></a>2. 使用Apple Configuration创建项目</h2><p><img src="/1.png" alt="Alt text" title="Optional title"><br><img src="/2.png" alt="Alt text" title="Optional title"></p>
]]></content>
      <tags>
        <tag>AppleTV</tag>
      </tags>
  </entry>
  <entry>
    <title>clover</title>
    <url>/2017/11/06/clover/</url>
    <content><![CDATA[<h2 id="Clover中隐藏“Boot-Windows-From-EFI”启动项"><a href="#Clover中隐藏“Boot-Windows-From-EFI”启动项" class="headerlink" title="Clover中隐藏“Boot Windows From EFI”启动项"></a>Clover中隐藏“Boot Windows From EFI”启动项</h2><p>用Clover时经常能碰到Boot Windows From EFI或者Boot Grub From EFI等启动项，又启动不起来Windows或者Ubuntu。<br>经过小小的研究，修改Clover的config.plist文件，将GUI-&gt;Scan下的Legacy选项设为false即可隐藏。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;Scan&lt;/key&gt;  </span><br><span class="line">&lt;dict&gt;  </span><br><span class="line">    &lt;key&gt;Entries&lt;/key&gt;  </span><br><span class="line">        &lt;true/&gt;  </span><br><span class="line">    &lt;key&gt;Legacy&lt;/key&gt;  </span><br><span class="line">        &lt;false/&gt;  </span><br><span class="line">    &lt;key&gt;Tool&lt;/key&gt;  </span><br><span class="line">        &lt;true/&gt;  </span><br><span class="line">&lt;/dict&gt;  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Mac OS</tag>
        <tag>排错</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7系统CUPS+SAMBA打印服务安装与配置</title>
    <url>/2017/09/12/centos-cups/</url>
    <content><![CDATA[<p>Samba除了提供文件共享之外，也可以像windows下的共享一样提供打印机共享。CUPS是Linux系统下管理打印的服务应用程序，其支持IPP、LPD、SMB和JetDirect接口。CUPS服务本身也可以实现打印共享，不过在windows下增加cups共享打印机的步骤相对麻烦，可以利用Samba先连接本地CUPS服务，再由Samba提供打印共享服务。</p>
<span id="more"></span>

<h2 id="1、CUPS服务配置"><a href="#1、CUPS服务配置" class="headerlink" title="1、CUPS服务配置"></a>1、CUPS服务配置</h2><h3 id="1-1、安装CUPS相关软件包"><a href="#1-1、安装CUPS相关软件包" class="headerlink" title="1.1、安装CUPS相关软件包"></a>1.1、安装CUPS相关软件包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install cups</span><br></pre></td></tr></table></figure>
<h3 id="1-2、cups配置文件"><a href="#1-2、cups配置文件" class="headerlink" title="1.2、cups配置文件"></a>1.2、cups配置文件</h3><p>编辑cups配置文件<code>vi /etc/cups/cupsd.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将Listen localhost:631修改为</span></span><br><span class="line"></span><br><span class="line">Listen 0.0.0.0:631           //监听所有IP</span><br><span class="line"></span><br><span class="line"><span class="comment">#默认是不允许远程主机浏览器打开访问的，这里将allow、deny顺序对调下，或者后面加allow from *</span></span><br><span class="line"></span><br><span class="line">&lt;Location /&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#Order allow,deny   //默认配置部分</span></span><br><span class="line"></span><br><span class="line">  Order deny,allow     //修改后的内容</span><br><span class="line"></span><br><span class="line">&lt;/Location&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置admin项只允许某台主机或某段主机访问</span></span><br><span class="line"></span><br><span class="line">&lt;Location /admin&gt;</span><br><span class="line"></span><br><span class="line">  Order deny,allow</span><br><span class="line"></span><br><span class="line">  deny from all</span><br><span class="line"></span><br><span class="line">  allow from  192.168.1.*</span><br><span class="line"></span><br><span class="line">&lt;/Location&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-3、防火墙设置"><a href="#1-3、防火墙设置" class="headerlink" title="1.3、防火墙设置"></a>1.3、防火墙设置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=631/tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<h3 id="1-4、浏览配置新增打印机"><a href="#1-4、浏览配置新增打印机" class="headerlink" title="1.4、浏览配置新增打印机"></a>1.4、浏览配置新增打印机</h3><p>可以通过lpadmin命令新增打印机，也可以通过浏览器输入<code>http://IP:631</code> 后访问，如下图：<br>通过add printer增加打印机后（增加时会让输入主机的root用户名和密码），可以通过最上面的prints项，查看当前打列机列表：</p>
<h2 id="2、Samba服务配置"><a href="#2、Samba服务配置" class="headerlink" title="2、Samba服务配置"></a>2、Samba服务配置</h2><p>Samba除了可以分享文件系统外，也可以分享打印机。Samba这个文件系统是架构在NetBIOS这个通讯协议上面所开发出来的。既然如此，我们先了解一下NetBIOS</p>
<h2 id="2-1-NetBIOS通讯协议"><a href="#2-1-NetBIOS通讯协议" class="headerlink" title="2.1 NetBIOS通讯协议"></a>2.1 NetBIOS通讯协议</h2><p>最早IBM发展出NetBIOS的目的仅是要让局域网络内少数计算机进行网络链接的一个通讯协议而已，所以考虑的角度并不是针对大型网络，因此，这个NetBIOS是无法跨路由的。这个NetBIOS在局域网络内实在是很好用，所以微软的网络架构就使用了它进行沟通。而Samba最早发展的时候，其实是想要让Linux系统可以加入Windows的系统当中来分享使用彼此的档案数据的，所以当然Samba就架构在NetBIOS发展出来。<br>&amp;emsp;&amp;emsp;不过NetBIOS是无法跨路由的，因此使用NetBIOS发展起来的服务器理论上也是无法跨越路由的。那么该服务器的使用范围就受限很多，好在出现了所谓的NetBIOS over TCP&#x2F;IP技术。它是个什么样的技术呢？举个例子，我们知道TCP&#x2F;IP是目前网络连接的基本协议，现在我们将NetBIOS想成是一封明信片，这个明信片只能让自己欣赏而已，如果今天我们要将这个明信片送到远方的朋友那边时！就需要透过邮件系统（例如邮局、快递等）来传送了！这个TCP&#x2F;IP就可以视为邮件传递系统了！透过NetBIOS over TCP&#x2F;IP的技术，我们就可以跨路由使用Samba服务器所提供的功能了！</p>
<div class="note success"><p>提示：或许你会发现在Windows网络设定里面常常看到NetBEUI这个协议，那是什么呢？那是个NetBIOS Extened User Interface的简写，也是IBM在NetBIOS发展出来之后的改良版本。</p>
</div>
<h2 id="2-2-Samba使用的daemons（守护进程）"><a href="#2-2-Samba使用的daemons（守护进程）" class="headerlink" title="2.2 Samba使用的daemons（守护进程）"></a>2.2 Samba使用的daemons（守护进程）</h2><p>NetBIOS当初发展时就着眼在局域网络内的快速数据交流，而因为是定义在局域网络内，因此他并没有使用类似TCP&#x2F;IP之类的传输协议，也就不需要IP的设定。如此一来数据如何在两部主机之间交流呢？其实主机在NetBIOS协议中使用NetBIOS Name，每一部主机必须要有不同的NetBIOS Name才行，而档案数据就是在不同的NetBIOS Name之间沟通。<br>&amp;emsp;&amp;emsp;Windows环境下，如何实现两台计算机相互通信通常要做到两步：（1） Windows的工作组要一致，并且两台计算机的主机名不一致，因为它是架构在NetBIOS协议上的，我们可以简单的称呼他为NetBIOS Name。(2) 利用对方给予的权限存取可用资源<br>&amp;emsp;&amp;emsp;在Linux环境下Samba则是透过两支服务来控制这两个步骤，分别是：（1）<b>nmbd</b>，这个daemon是用来管理工作组、NetBIOS name等等解析的。主要利用UDP协议开启port 137、138来负责名称解析的任务；（2）<b>smbd</b>，这个daemon的主要功能就是用来管理samba主机分享的目录、档案与打印机等等。主要是利用可靠的TCP协议来传输数据，开放的端口为139及445。<br>&amp;emsp;&amp;emsp;所以，Samba每次启动至少都需要这两个daemon，这两个daemon启动时会启用137、138两个UDP端口和139一个TCP端口。后面设定防火墙的时候会用到这三个端口。</p>
<h2 id="2-3-Samba所需软件及其软件结构"><a href="#2-3-Samba所需软件及其软件结构" class="headerlink" title="2.3 Samba所需软件及其软件结构"></a>2.3 Samba所需软件及其软件结构</h2><ul>
<li>samba：这个软件主要提供了SMB服务器所需的各项服务程序（smbd和nmbd）等</li>
<li>samba-client：这个软件则提供了当Linux做为Samba Client端时，所需要的工具指令，例如挂载SAMBA文件格式的mount.cifs、取得类似windows网络邻居树形图的smbtree等</li>
<li>samba-common：这个软件堤供的则是服务器与客户端都会使用到的数据，包括SAMBA的主要配置文件（sab.conf）、语法检验指令（testparm）等</li>
</ul>
<p>相关配置文件有如下：</p>
<ul>
<li><code>/etc/samba/smb.conf</code>：这个Samba的主要配置文件</li>
<li><code>/etc/samba/lmhosts</code>：早期的NetBIOS Name发额外设定，因此需要这个lmhosts的NetBIOS name对应IP地址。事实上它有点像是<code>/etc/hosts</code>的功能。目前Samba预设会去使用你的本机名称（hostname）作为你的NetBIOS name，因此这个档案不设定也无所谓</li>
<li><code>/etc/sysconfig/samba</code>：提供启动smbd、nmbd时，你还想要加入的相关服务参数。</li>
<li><code>/etc/samba/smbusers</code>：由于Windows与Linux在管理员与访客的账号名称不一致，例如：administrator(windows)及root(linux)，为了对应这两者这间的关系，可使用这个档案来设定</li>
<li><code>/var/lib/samba/private/&#123;passdb.tdb,secrets.tdb&#125;</code>：管理Samba的用户账号与密码时，会用到的数据库档案</li>
<li><code>/usr/share/doc/samba&lt;版本&gt;</code>：这个目录包含了SAMBA的所有相关的技术手册</li>
</ul>
<p>至于常用的脚本文件案方面，若分为服务器与客户端功能，则主要有底下几个数据：</p>
<ul>
<li><code>/usr/sbin/&#123;smbd,nmbd&#125;</code>：服务器功能，就是最重要的权限管理（smbd）以及NetBIOS Name查询（nmbd）两个重要的服务程序；</li>
<li><code>/usr/bin/&#123;tdbdump,tdbtool&#125;</code>：服务器功能，在Samba 3.0以后的版本中，用户的账号与密码参数已经转为使用数据库了，Samba使用的数据库名称为TDB（Trivial Database）。tdbdump可以查看数据库的内容，tdbtool则可以进入数据库操作接口直接手动修改账密参数。不过，你得安装tdb-tool这个软件才可以。</li>
<li><code>/usr/bin/smbstatus</code>：服务器功能，可以列出目前Samba的联机状况，包括每一条Samba联机的PID，分享资源，使用的用户来源等等，让你轻轮台管理Samba</li>
<li><code>/usr/bin/&#123;smbpasswd,pdbedit&#125;</code>：服务器功能，在管理Samba的用户账号密码时，早期是使用smbpasswd这个指令，不过因为后来使用了TDB数据库了，因此建议使用新的pdbedit指令来管理用户数据</li>
<li><code>/usr/bin/testparm</code>：服务器功能，这个指令主要在检验配置文件sam.conf的语法正确与否，当你编辑过smb.conf时，请务必使用这个指令来检查一次，避免因为打字错引起困扰！</li>
<li><code>/sbin/mount.cifs</code>：客哀悼端功能，在 Windows 上面我们可以设定『网络驱动器机』来连接<br>到自己的主机上面。在 Linux 上面，我们则是透过 mount (mount.cifs) 来将远程主机分享<br>的档案与目录挂载到自己的 Linux 主机上面哪！</li>
<li><code>/usr/bin/smbclient</code>：客户端功能，当你的 Linux 主机想要藉由『网络邻居』的功能来<br>查看别台计算机所分享出来的目录与装置时，就可以使用 smbclient 来查看啦！这个指令<br>也可以使用在自己的 SAMBA 主机上面，用来查看是否设定成功哩！</li>
<li><code>/usr/bin/nmblookup</code>：客户端功能，有点类似nslookup，重点在查出NetBIOS name</li>
<li><code>/usr/bin/smbtree</code>：客户端功能，能够查到工作组与计算机名称的树状目录分布图</li>
</ul>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>cups</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg码率控制</title>
    <url>/2021/11/25/ffmpeg%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="什么是码率控制？"><a href="#什么是码率控制？" class="headerlink" title="什么是码率控制？"></a>什么是码率控制？</h1><p><b>它是编码器决定为每帧视频分配多少比特的工具</b></p>
<span id="more"></span> 

<h2 id="码率控制有多种方式"><a href="#码率控制有多种方式" class="headerlink" title="码率控制有多种方式"></a>码率控制有多种方式</h2><p>接下来会对“1-pass”、“2-pass”、“CBR”、“VBR”、“VBV Encoding”和“CRF”做相应的介绍</p>
<h2 id="可变码率"><a href="#可变码率" class="headerlink" title="可变码率"></a>可变码率</h2><p>可变码率是在固定码率的基础上发展出来的，可变码率（Variable Bitate, VBR）可以确保在给定限制下使用最少的比特的情况下保持最高质量。也就是说在难编码的地方花费更多的比特，在简单的地方花费更少的比特。</p>
<h1 id="码率的控制模式"><a href="#码率的控制模式" class="headerlink" title="码率的控制模式"></a>码率的控制模式</h1><p>以下基于ffmpeg中的x264、x265和libvpx编码器，介绍码率的控制方式</p>
<h2 id="固定QP（Constant-QP-CQP）"><a href="#固定QP（Constant-QP-CQP）" class="headerlink" title="固定QP（Constant QP, CQP）"></a>固定QP（Constant QP, CQP）</h2><p>QP控制着文件压缩的大小，H.264与H.265中QP值在0-51之间的整数范围内，QP值越大压缩率越高同时质量越低，但有的编码器并没有QP值例如：libvpx编码器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &lt;input&gt; -c:v libx264 -qp 20 &lt;output&gt;</span><br><span class="line">ffmpeg -i &lt;input&gt; -c:v libx265 -x265-params qp=20 &lt;output&gt;</span><br></pre></td></tr></table></figure>

<div class="note danger"><p>非必要不要使用QP模式，采用QP模式会导致根据场景复杂度不同比特率的波动很大，你无法控制实际的比特率 </p>
</div>

<h2 id="平均比特率（Average-Bitrate-ABR）"><a href="#平均比特率（Average-Bitrate-ABR）" class="headerlink" title="平均比特率（Average Bitrate, ABR）"></a>平均比特率（Average Bitrate, ABR）</h2><p>给定编码器一个目标的码率，编码器计算如可达到这个码率：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &lt;input&gt; -c:v libx264 -b:v 1M &lt;output&gt;</span><br><span class="line">ffmpeg -i &lt;input&gt; -c:v libx265 -b:v 1M &lt;output&gt;</span><br><span class="line">ffmpeg -i &lt;input&gt; -c:v libvpx-vp9 -b:v 1M &lt;output&gt;</span><br></pre></td></tr></table></figure>

<div class="note danger"><p>ABR不是一种恒定码率模式，而是一种可变的码率模式。所以避免使用这个模式，因为它会在短时间内质量波动比较大 </p>
</div>

<h2 id="恒定码率（Constant-Bitrate-CBR）"><a href="#恒定码率（Constant-Bitrate-CBR）" class="headerlink" title="恒定码率（Constant Bitrate, CBR）"></a>恒定码率（Constant Bitrate, CBR）</h2><p>可以通过设置nal-hrd使编码器强制在特定码率</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &lt;input&gt; -c:v libx264 x264-params <span class="string">&quot;nal-hrd=cbr:force-cfr=1&quot;</span> -b:v 1M </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg用法</title>
    <url>/2018/09/13/ffmpeg/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>是一个非常快的视频和音频转换器，它可以抓取音频&#x2F;视频源。它还可以在任意采样率之间转换，并利用高质量多相滤波器实时调整视频大小。</p>
<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>FFmpeg项目由以下几部分组成：</p>
<ul>
<li>FFmpeg视频文件转换命令行工具,也支持经过实时电视卡抓取和编码成视频文件；</li>
<li>ffserver基于HTTP、RTSP用于实时广播的多媒体服务器.也支持时间平移；</li>
<li>ffplay用 SDL和FFmpeg库开发的一个简单的媒体播放器；</li>
<li>libavcodec一个包含了所有FFmpeg音视频编解码器的库。为了保证最优性能和高可复用性，大多数编解码器从头开发的；</li>
<li>libavformat一个包含了所有的普通音视格式的解析器和产生器的库。</li>
</ul>
<span id="more"></span>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><h2 id="MKV转MP4，音频部分只提取第2路音轨"><a href="#MKV转MP4，音频部分只提取第2路音轨" class="headerlink" title="MKV转MP4，音频部分只提取第2路音轨"></a>MKV转MP4，音频部分只提取第2路音轨</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mkv -map 0:v -vcodec copy -map 0:a:1 -acodec copy -strict -2 output.mp4</span><br></pre></td></tr></table></figure>
<ul>
<li>0:v：代表提取所有视频流</li>
<li>0:a:1：代表如果有多路音轨，只提取第2路音轨</li>
<li>-strict -2：使用ffmpeg自带的aac音频编码</li>
</ul>
<h2 id="MKV转MP4，转换多路ac3音轨"><a href="#MKV转MP4，转换多路ac3音轨" class="headerlink" title="MKV转MP4，转换多路ac3音轨"></a>MKV转MP4，转换多路ac3音轨</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mkv -map 0:0 -map 0:1 -map 0:2 -vcodec copy -acodec ac3 -disposition:a:0 default -y output.mp4</span><br></pre></td></tr></table></figure>
<ul>
<li>-disposition:a:0 default：默认第一音轨</li>
</ul>
<h2 id="视频切割"><a href="#视频切割" class="headerlink" title="视频切割"></a>视频切割</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 剪切的同时，格式不变，音视频参数不变：</span></span><br><span class="line">ffmpeg -y -i input.mp4 -ss 00:00:00.0 -t 00:01:00.0 -acodec copy -vcodec copy -async 1 output.mp4</span><br><span class="line"><span class="comment"># 剪切的同时，音视频参数不变，只转换格式：</span></span><br><span class="line">ffmpeg -y -i input.mp4 -ss 00:00:00.0 -t 00:01:00.0 -acodec copy -vcodec copy -async 1 output.flv</span><br><span class="line"><span class="comment"># 剪切的同时，格式不变，只转换音视频参数：</span></span><br><span class="line">ffmpeg -y -i input.mp4 -ss 00:00:00.0 -t 00:01:00.0 -ab 56k -ar 44100 -b:v 2200k -r 29.97 -s 640*360 output.mp4</span><br><span class="line"><span class="comment"># 剪切的同时，既转换格式又转换音视频参数：</span></span><br><span class="line">ffmpeg -y -i input.mp4 -ss 00:00:00.0 -t 00:01:00.0 -ab 56k -ar 44100 -b:v 2200k -r 29.97 -s 640*360 output.flv</span><br></pre></td></tr></table></figure>
<ul>
<li>-y：表示覆盖输出文件</li>
<li>-ab：设置音频码率</li>
<li>-ar：设置音频采样率</li>
<li>-b:v：设置视频比特率为2200千比特&#x2F;秒</li>
<li>-r：设置帧频 缺省25</li>
<li>-s：设置帧大小 格式为WXH 缺省160X128.下面的简写也可以直接使用：Sqcif 128X96 qcif 176X144 cif 252X288 4cif 704X576</li>
<li>-ss：表示起始时间，格式为“小时:分钟:秒”</li>
<li>-t：表示时长，格式为“小时：分钟：秒”</li>
</ul>
<h2 id="视频增加黑边"><a href="#视频增加黑边" class="headerlink" title="视频增加黑边"></a>视频增加黑边</h2><p>使用FFmpeg给视频增加黑边需要用到 pad 这个滤镜，具体用法如下：<br><code>-vf pad=1280:720:0:93:black</code><br>按照从左到右的顺序依次为:<br>​“宽”、“高”、“X坐标”和“Y坐标”，宽和高指的是输入视频尺寸（包含加黑边的尺寸），XY指的是视频所在位置。<br>​<br>比如一个输入视频尺寸是1280x534的源，想要加上黑边变成1280x720，那么用上边的语法可以实现，93是这样得来的，（720-534）&#x2F;2。<br>​<br>如果视频原始1920x800的话，完整的语法应该是：<br>   -vf ‘scale&#x3D;1280:534,pad&#x3D;1280:720:0:93:black’</p>
<p>先将视频缩小到1280x534，然后在加入黑边变成1280x720，将1280x534的视频放置在x&#x3D;0，y&#x3D;93的地方，<br>​FFmpeg会自动在上下增加93像素的黑边。<br>注：black可以不写，默认是黑色</p>
<h2 id="字幕"><a href="#字幕" class="headerlink" title="字幕"></a>字幕</h2><p>字幕流跟其他媒体流一样，有各种编码，常见的编码有SubRip（作为独立文件时后缀名为.srt）和ASS（作为独立文件时后缀名为.ass）</p>
<p>因为字幕流也是媒体流，也有各种编码，所以，我们可以通过-scodec或-c:s选项来指定字幕流的编码。</p>
<p>例：提出字幕流<br><code>ffmpeg -i output.mkv -an -vn -scodec copy sub3.ass</code></p>
<p>例：转换字幕格式<br><code>ffmpeg -i subtitle.srt subtitle.ass</code></p>
<p>例：而将字幕流转换为 ass 编码：<br><code>ffmpeg -i Tor_Animation_en.mp4 -i Tor_animation.zh-CN.srt -c:v copy -c:a copy -c:s ass Tor_Animation_subtitled.mkv</code></p>
<p>例：将srt字幕编入视频流<br><code>ffmpeg -i Tor_Animation_en.mp4 -vf subtitles=Tor_animation.zh-CN.srt -c:a copy Tor_Animation_subtitled.mp4</code></p>
<p>例：将ass字幕编入视频流<br><code>ffmpeg -i Tor_Animation_en.mp4 -vf &quot;ass=subtitle.ass&quot; -c:a copy Tor_Animation_subtitled.mp4</code></p>
<h2 id="字幕参数设置"><a href="#字幕参数设置" class="headerlink" title="字幕参数设置"></a>字幕参数设置</h2><h3 id="srt字幕流"><a href="#srt字幕流" class="headerlink" title="srt字幕流"></a>srt字幕流</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -i **.mp4 -vf <span class="string">&quot;subtitles=**.src:force_style=&#x27;FontSize=20,Alignment=6&#x27;&quot;</span> output.mp4</span><br><span class="line"><span class="comment">#Alignment参数</span></span><br><span class="line">1： Bottom left</span><br><span class="line">2:  Bottom center</span><br><span class="line">3:  Bottom right</span><br><span class="line">5:  Top left</span><br><span class="line">6:  Top center</span><br><span class="line">7:  Top right</span><br><span class="line">9:  Middle left</span><br><span class="line">10: Middle center</span><br><span class="line">11: Middle right</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ass字幕流"><a href="#ass字幕流" class="headerlink" title="ass字幕流"></a>ass字幕流</h3><p>最新版本的 ffmpeg 使用 ASS中的V4+ Styles</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[V4+ Styles]\r\n&quot;</span><br><span class="line">/* ASSv4 header */</span><br><span class="line">&quot;Format: Name, &quot;</span><br><span class="line">&quot;Fontname, Fontsize, &quot;</span><br><span class="line">&quot;PrimaryColour, SecondaryColour, OutlineColour, BackColour, &quot;</span><br><span class="line">&quot;Bold, Italic, Underline, StrikeOut, &quot;</span><br><span class="line">&quot;ScaleX, ScaleY, &quot;</span><br><span class="line">&quot;Spacing, Angle, &quot;</span><br><span class="line">&quot;BorderStyle, Outline, Shadow, &quot;</span><br><span class="line">&quot;Alignment, MarginL, MarginR, MarginV, &quot;</span><br><span class="line">&quot;Encoding\r\n&quot;</span><br><span class="line"></span><br><span class="line">01.Name             风格(Style)的名称. 区分大小写. 不能包含逗号.</span><br><span class="line">02.Fontname         使用的字体名称, 区分大小写.</span><br><span class="line">03.Fontsize         字体的字号</span><br><span class="line">04.PrimaryColour    设置主要颜色, 为蓝-绿-红三色的十六进制代码相排列, BBGGRR. 为字幕填充颜色</span><br><span class="line">05.SecondaryColour  设置次要颜色, 为蓝-绿-红三色的十六进制代码相排列, BBGGRR. 在卡拉OK效果中由次要颜色变为主要颜色.</span><br><span class="line">06.OutlineColour    设置轮廓颜色, 为蓝-绿-红三色的十六进制代码相排列, BBGGRR.</span><br><span class="line">07.BackColour       设置阴影颜色, 为蓝-绿-红三色的十六进制代码相排列, BBGGRR. ASS的这些字段还包含了alpha通道信息. (AABBGGRR), 注ASS的颜色代码要在前面加上&amp;H</span><br><span class="line">08.Bold             -1为粗体, 0为常规</span><br><span class="line">09.Italic           -1为斜体, 0为常规</span><br><span class="line">10.Underline       [-1 或者 0] 下划线</span><br><span class="line">11.Strikeout       [-1 或者 0] 中划线/删除线</span><br><span class="line">12.ScaleX          修改文字的宽度. 为百分数</span><br><span class="line">13.ScaleY          修改文字的高度. 为百分数</span><br><span class="line">14.Spacing         文字间的额外间隙. 为像素数</span><br><span class="line">15.Angle           按Z轴进行旋转的度数, 原点由alignment进行了定义. 可以为小数</span><br><span class="line">16.BorderStyle     1=边框+阴影, 3=纯色背景. 当值为3时, 文字下方为轮廓颜色的背景, 最下方为阴影颜色背景.</span><br><span class="line">17.Outline         当BorderStyle为1时, 该值定义文字轮廓宽度, 为像素数, 常见有0, 1, 2, 3, 4.</span><br><span class="line">18.Shadow          当BorderStyle为1时, 该值定义阴影的深度, 为像素数, 常见有0, 1, 2, 3, 4.</span><br><span class="line">19.Alignment       定义字幕的位置. 字幕在下方时, 1=左对齐, 2=居中, 3=右对齐. 1, 2, 3加上4后字幕出现在屏幕上方. 1, 2, 3加上8后字幕出现在屏幕中间. 例: 11=屏幕中间右对齐. Alignment对于ASS字幕而言, 字幕的位置与小键盘数字对应的位置相同.</span><br><span class="line">20.MarginL         字幕可出现区域与左边缘的距离, 为像素数</span><br><span class="line">21.MarginR         字幕可出现区域与右边缘的距离, 为像素数</span><br><span class="line">22.MarginV         垂直距离</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>git管理</title>
    <url>/2017/09/11/git/</url>
    <content><![CDATA[<h1 id="1、版本库"><a href="#1、版本库" class="headerlink" title="1、版本库"></a>1、版本库</h1><p>可以理解为一个目录，这个目录里的所有文件都被git管理起来，每个文件的修改删除都能跟踪，以便任何时候可以追踪历史或将来某个时候可以还原。创建版本库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> aaaa</span><br><span class="line"><span class="built_in">cd</span> aaaa</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>创建完成后，目录下会多出“.git”隐藏目录。这个目录是Git来跟踪管理版本库的。版本控制系统只能跟踪用纯文本方式编写的文件。使用UTF-8编码</p>
<span id="more"></span>
<h2 id="1-1、命令解析"><a href="#1-1、命令解析" class="headerlink" title="1.1、命令解析"></a>1.1、命令解析</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git初始化</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 把文件添加至暂存区</span></span><br><span class="line">git add 文件名</span><br><span class="line"><span class="comment"># 把暂存区的所有内容提交到分支</span></span><br><span class="line">git commit -m <span class="string">&quot;说明改动&quot;</span>  <span class="comment">#因为在做仓库初始化的时候，git自动创建了一个master分支,所以git commit都提交到了master分支</span></span><br><span class="line"><span class="comment"># 查看当前仓库的状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 查看仓库修改的内容</span></span><br><span class="line">git diff</span><br><span class="line"><span class="comment"># 显示仓库从近至远的提交日志</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 显示仓库从近至远的提交日志，简化版本</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line"><span class="comment"># 回退至某一个版本</span></span><br><span class="line">git reset --hard HEAD^      <span class="comment">#git中HEAD表示当前版本，^表示上一版本，^^表示上两个版本,</span></span><br><span class="line">git reset --hard XXXXXXXX   <span class="comment">#XXXXXXXX为ID号</span></span><br><span class="line"><span class="comment"># 记录第一个命令</span></span><br><span class="line">git reflog</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="2、Git服务器搭建"><a href="#2、Git服务器搭建" class="headerlink" title="2、Git服务器搭建"></a>2、Git服务器搭建</h1><h2 id="2-1、安装Git"><a href="#2-1、安装Git" class="headerlink" title="2.1、安装Git"></a>2.1、安装Git</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br><span class="line">$ yum install git</span><br></pre></td></tr></table></figure>
<p>接下来我们创建一个git用户组和用户，用来运行git服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ groupadd git</span><br><span class="line">$ adduser git -g git</span><br></pre></td></tr></table></figure>
<h2 id="2-2、创建证书登录"><a href="#2-2、创建证书登录" class="headerlink" title="2.2、创建证书登录"></a>2.2、创建证书登录</h2><p>收集所有需要登录的用户和公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys文件里，一行一个，如果没有创建它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 被登录的机器.ssh目录是700，authorized_keys权限600或644</span></span><br><span class="line"><span class="built_in">cd</span> /home/git</span><br><span class="line"><span class="built_in">mkdir</span> .ssh</span><br><span class="line"><span class="built_in">chmod</span> 700 .ssh</span><br><span class="line"><span class="built_in">touch</span> .ssh/authorized_keys</span><br><span class="line"><span class="built_in">chmod</span> 600 .ssh/autchorized_keys</span><br><span class="line"><span class="comment"># 将公钥传递给被登陆的机器</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub git@XXXX.XXXX.XXXX.XXXX</span><br></pre></td></tr></table></figure>
<h2 id="2-3、初始化Git仓库"><a href="#2-3、初始化Git仓库" class="headerlink" title="2.3、初始化Git仓库"></a>2.3、初始化Git仓库</h2><p>首先我们选定一个目录作为Git仓库，假定是&#x2F;home&#x2F;gitrepo&#x2F;runoob.git，在&#x2F;home&#x2F;gitrepo目录输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home</span><br><span class="line">$ <span class="built_in">mkdir</span> gitrepo</span><br><span class="line">$ <span class="built_in">chown</span> git:git gitrepo/</span><br><span class="line">$ <span class="built_in">cd</span> gitrepo</span><br><span class="line">$ git init --bare runoob.git</span><br></pre></td></tr></table></figure>
<p>以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chown</span> -R git:git runoob.git</span><br></pre></td></tr></table></figure>
<h2 id="2-4、克隆Git仓库"><a href="#2-4、克隆Git仓库" class="headerlink" title="2.4、克隆Git仓库"></a>2.4、克隆Git仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@192.168.45.4:/home/gitrepo/runoob.git</span><br><span class="line">Cloning into <span class="string">&#x27;runoob&#x27;</span>...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>
<p>192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。<br>这样我们的 Git 服务器安装就完成了，接下来我们可以禁用 git 用户通过shell登录，可以通过编辑&#x2F;etc&#x2F;passwd文件完成。找到类似下面的一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git:x:503:503::/home/git:/bin/bash</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git:x:503:503::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure>

<h2 id="2-5、Git远程操作详解"><a href="#2-5、Git远程操作详解" class="headerlink" title="2.5、Git远程操作详解"></a>2.5、Git远程操作详解</h2><p>Git有很多优势，其中之一就是远程操作非常方便，下面就逐一介绍以下5个Git命令<br><img src="1.jpg" style="margin : auto;"></p>
<h3 id="2-5-1、git-clone"><a href="#2-5-1、git-clone" class="headerlink" title="2.5.1、git clone"></a>2.5.1、git clone</h3><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;版本库的网址&gt;</span><br></pre></td></tr></table></figure>
<p>比如，克隆jQuery的版本库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure>
<p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为<code>git clone</code>命令的第二个参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure>
<p><code>git clone</code>支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协义等，下面是一些例子。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> http[s]://example.com/path/to/repo.git/</span><br><span class="line">$ git <span class="built_in">clone</span> ssh://example.com/path/to/repo.git/</span><br><span class="line">$ git <span class="built_in">clone</span> git://example.com/path/to/repo.git/</span><br><span class="line">$ git <span class="built_in">clone</span> /opt/git/project.git</span><br><span class="line">$ git <span class="built_in">clone</span> file:///opt/git/project.git</span><br><span class="line">$ git <span class="built_in">clone</span> ftp[s]://example.com/path/to/repo.git/</span><br><span class="line">$ git <span class="built_in">clone</span> rsync://example.com/path/to/repo.git/</span><br></pre></td></tr></table></figure>
<p>SSH协议还有另一种写法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> [user@]example.com:path/to/repo.git/</span><br></pre></td></tr></table></figure>
<p>通常来说，git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考<a href="http://git-scm.com/book/en/Git-on-the-Server-The-Protocols">官方文档</a></p>
<h3 id="2-5-2、git-remote"><a href="#2-5-2、git-remote" class="headerlink" title="2.5.2、git remote"></a>2.5.2、git remote</h3><p>为了便于管理，Git要求第个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。不带选项的时候，<code>git remote</code> 命令列出所有远程主机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p>使用<code>-v</code>选项，可以查看远程主机的网址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin git@github.com:jquery/jquery.git(fetch)</span><br><span class="line">origin git@github.com:jquery/jquery.git(push)</span><br></pre></td></tr></table></figure>
<p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。<br>克隆版本库的时候，所使用的远程主机自动被Git命名为<code>origin</code>。如果想用其它的主机名，需要用<code>git clone</code>命令的<code>-o</code>选项指定。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -o jQuery https://github.com/jquery/jquery.git</span><br><span class="line">$ git remote</span><br><span class="line">jQuery</span><br></pre></td></tr></table></figure>
<p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。<code>hit remote show</code>命令加上主机名，可以查看该主机的详细信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote show &lt;主机名&gt;</span><br></pre></td></tr></table></figure>
<p><code>git remote add</code>命令用于添加远程主机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add &lt;主机名&gt;&lt;网址&gt;</span><br></pre></td></tr></table></figure>
<p><code>git remote rm</code>命令用于删除远程主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="built_in">rm</span> &lt;主机名&gt;</span><br></pre></td></tr></table></figure>
<p><code>git remote rename</code>命令用于远程主机改名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote rename &lt;原主机名&gt;&lt;新主机名&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-3-git-fetch"><a href="#2-5-3-git-fetch" class="headerlink" title="2.5.3 git fetch"></a>2.5.3 git fetch</h3><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用要<code>git fetch</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure>
<p>上面命令将某个远程主机的更新，全部取回本地。<br><code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<p>比如，取回<code>origin</code>主机的<code>master</code>分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch origin master</span><br></pre></td></tr></table></figure>
<p>所取回的更新，在本地主机上要用“远程主机名&#x2F;分支名“的形式读取。比如<code>origin</code>主机的<code>master</code>，就要用<code>origin/master</code>读取。<br><code>git branch</code>的命令<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">origin/master</span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">remotes/origin/master</span><br></pre></td></tr></table></figure>
<p>上面命令表示，本地主机的当前分支是<code>master</code>，远程分支是<code>origin/master</code>。取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure>
<p>上面命令表示，在<code>origin/msater</code>的基础上，创建一个新分支。此外，也可以使用<code>git merge</code>命令或者<code>git rebase</code>命令，在本地分支上合并远程分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ git rebase origin/master</span><br></pre></td></tr></table></figure>
<p>上面命令表示在当前分支上，合并<code>origin/master</code>。</p>
<h3 id="2-5-4-git-pull"><a href="#2-5-4-git-pull" class="headerlink" title="2.5.4 git pull"></a>2.5.4 git pull</h3><p><code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>
<p>比如，取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并，需要写成下面这样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull origin next:master</span><br></pre></td></tr></table></figure>
<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull origin next</span><br></pre></td></tr></table></figure>
<p>上面命令表示，取回<code>origin/next</code>分支，再与当前分支合并。实质上，这等同于先做<code>git fetch</code>，再做<code>git merge</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">$ git merge origin/next</span><br></pre></td></tr></table></figure>
<p>在某些场合，git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地默认与远程主机的同名分支，建立追踪关系，也就是说本地的<code>master</code>分支自动“追踪”<code>origin/master</code>分支。<br>git也允许手动建立追踪关系。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream master origin/next</span><br></pre></td></tr></table></figure>
<p>上面命令指定<code>master</code>分支追踪<code>origin/next</code>分支。如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull origin</span><br></pre></td></tr></table></figure>
<p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机“追踪分支”（remote-tracking branch）进行合并。如果当前分支只有一个追踪分支，连远程主机都可以省略。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
<p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用rebase模式，可以使用<code>--rebase</code>选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>
<p>如果远程主机删除了某个分支，默认情况下，<code>git pull</code>不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。<br>但是，你可以改变这个行为，加上参数<code>-p</code>就会在本地删除远程已经删除的分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull -p</span><br><span class="line"><span class="comment"># 等同于下面的命令</span></span><br><span class="line">$ git fetch --prune origin</span><br><span class="line">$ git fetch -p</span><br></pre></td></tr></table></figure>
<h3 id="2-5-5-git-push"><a href="#2-5-5-git-push" class="headerlink" title="2.5.5 git push"></a>2.5.5 git push</h3><p><code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与<code>git pull</code>命令相仿。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push &lt;远程主机名&gt;　&lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>
<p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以<code>git pull</code>是&lt;远程分支&gt;:&lt;本地分支&gt;，而<code>git push</code>是&lt;本地分支&gt;:&lt;远程分支&gt;。如果省略远程分支名，则表示将本地分支推送与这存在“追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>上面命令表示，将本地的<code>master</code>分支推送到<code>origin</code>主机的<code>master</code>分支。如果后者不存在，则会被新建。如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin :master</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ git push origin --delete master</span><br></pre></td></tr></table></figure>
<p>上同命令表示删除<code>origin</code>主机的<code>master</code>分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure>
<p>如果当前分支与多个主机存在追踪关系，则可以使用<code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<p>上面命令将本地的<code>master</code>分支推送到<code>origin</code>主机，同时指定origin为默认主机，后面就可以不加任何参数使用<code>git push</code>了。<br>不带任何参数的<code>git push</code>，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用<code>git config</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global push.default matching</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ git config --global push.default simple</span><br></pre></td></tr></table></figure>
<p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push --all origin</span><br></pre></td></tr></table></figure>
<p>上面命令表示，将所有本地分支都推送到<code>origin</code>主机。<br>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用<code>--force</code>选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push --force origin</span><br></pre></td></tr></table></figure>
<p>上面命令使用<code>--force</code>选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用<code>--force</code>选项。<br>最后，<code>git push</code>不会推送标签（tag），除非使用–tags选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建HEXO平台+Next主题的相关问题汇总</title>
    <url>/2017/08/16/hexo/</url>
    <content><![CDATA[<h1 id="1、HEXO平台"><a href="#1、HEXO平台" class="headerlink" title="1、HEXO平台"></a>1、HEXO平台</h1><h2 id="1-1、目录结构及含义"><a href="#1-1、目录结构及含义" class="headerlink" title="1.1、目录结构及含义"></a>1.1、目录结构及含义</h2><ul>
<li><code>scaffolds</code>是模板文件夹，它用于预先定义创建新文单所用的布局</li>
<li><code>source</code>文件夹内<code>_drafts</code>文件夹用于放置草稿，使用<code>hexo --draft</code>可查看草稿文章</li>
<li>资源文件夹：资源（Asset）代表<code>source</code>文件夹除了文章以外的所有文件，例如图片、CSS、JS文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source&#x2F;images 文件夹中。然后通过类似于 <code>![](/images/image.jpg) </code>的方法访问它们。</li>
<li>文章资源文件夹: 将站点配置文件<code>config.yml</code>中的<code>post_asset_folder</code>选择设为true，这样当使用&#96;hexo new命令生成新文章时，会自动添加一个资源文件夹。</li>
</ul>
<h2 id="1-2、相对路径引用的标签插件"><a href="#1-2、相对路径引用的标签插件" class="headerlink" title="1.2、相对路径引用的标签插件"></a>1.2、相对路径引用的标签插件</h2><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br><span class="line">#举例</span><br><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="2、Next主题"><a href="#2、Next主题" class="headerlink" title="2、Next主题"></a>2、Next主题</h1><h2 id="2-1、文字首行缩进"><a href="#2-1、文字首行缩进" class="headerlink" title="2.1、文字首行缩进"></a>2.1、文字首行缩进</h2><p>修改next主题目录下的<code>source/css/_custom/custom.styl</code>文件，新增</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> &#123; <span class="attribute">text-indent</span>: <span class="number">2em</span>; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2、如何设置-阅读全文"><a href="#2-2、如何设置-阅读全文" class="headerlink" title="2.2、如何设置[阅读全文]"></a>2.2、如何设置[阅读全文]</h2><p>在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。Next提供三种方式来控制文章在首页的显示方式。也就是说，在首页显示文章的摘录并显示<b>阅读全文</b>按钮，可以通过以下方式：</p>
<ul>
<li>在文章中使用<code>&lt;!-- more --&gt;</code>手动进行截断，Hexo提供的方式</li>
<li>在文章的<code>front-matter</code>中添加<code>description</code>，并提供文章摘录</li>
<li>自动形成摘要，在主题配置文件中添加：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-3、如何更改字体？"><a href="#2-3、如何更改字体？" class="headerlink" title="2.3、如何更改字体？"></a>2.3、如何更改字体？</h2><p>NexT从5.0.1版开始提供了一个字体定制特性，请先查看此特性是否能满足你的需求。以下的修改将覆盖字体定制的特性。编辑主题 下的<code>source/css/_variables/custom.styl</code>，新增两个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 标题，修改成你期望的字体族</span><br><span class="line">$font-family-headings = Georgia, sans</span><br><span class="line"></span><br><span class="line">// 修改成你期望的字体族</span><br><span class="line">$font-family-base = &quot;Microsoft YaHei&quot;, Verdana, sans-serif</span><br><span class="line"></span><br><span class="line">// 代码字体</span><br><span class="line">$code-font-family = &quot;Input Mono&quot;, &quot;PT Mono&quot;, Consolas, Monaco, Menlo, monospace</span><br><span class="line"></span><br><span class="line">// 正文字体的大小</span><br><span class="line">$font-size-base = 16px</span><br><span class="line"></span><br><span class="line">// 代码字体的大小</span><br><span class="line">$code-font-size = 13px</span><br></pre></td></tr></table></figure>
<h2 id="2-4、Bootstrap-Callout"><a href="#2-4、Bootstrap-Callout" class="headerlink" title="2.4、Bootstrap Callout"></a>2.4、Bootstrap Callout</h2><p>使用方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note class_name %&#125;Content(md partial supported)&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>其中，class_name可以是以下列表中的一个值：</p>
<ul>
<li>dafault</li>
<li>primary</li>
<li>success</li>
<li>info</li>
<li>warning</li>
<li>danger<br>效果如下<details class="note "><summary><p>dafault</p>
</summary>
<p>class_name值为default</p>

</details>
<div class="note primary"><p>class_name值为primary</p>
</div>
<div class="note success"><p>class_name值为success</p>
</div>
<div class="note info"><p>class_name值为info</p>
</div>
<div class="note warning"><p>class_name值为warning</p>
</div>
<div class="note danger"><p>class_name值为danger</p>
</div></li>
</ul>
<h2 id="2-5、文本居中的引用"><a href="#2-5、文本居中的引用" class="headerlink" title="2.5、文本居中的引用"></a>2.5、文本居中的引用</h2><p>此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。文本居中时，多行文本若长度不等，视觉上显得不对称，因此建义在引用单行文本的场景下使用。例如作为文单开篇引用或者结束语之前的总结引用。<br>使用方式：</p>
<ul>
<li>HTML方式：使用这种方式时，给img添加属性<code>class=&quot;blockquote-center&quot;</code>即可</li>
<li>标签方式：使用<code>centerquote</code>或者简写<code>cq</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% centerquote %&#125;大象无形，大音希声&#123;% endcenterquote %&#125;</span><br></pre></td></tr></table></figure>
效果如下：<div class="note "><blockquote class="blockquote-center">
<p>大象无形，大音希声<p><b>出自《道德经》</b></p></p>

</blockquote>
出自道德经“大方无隅，大器晚成。大音希声，大象无形。”这是由老子提出的中国古代文学理论中的一种美学观念，意在推崇自然的、而非人为的美。
白话翻译：越好的音乐越悠远潜低，越好的形象越飘渺宏远，越是大气度的往往越包容万物。</div></li>
</ul>
<h2 id="2-6、禁止文章目录自动编号"><a href="#2-6、禁止文章目录自动编号" class="headerlink" title="2.6、禁止文章目录自动编号"></a>2.6、禁止文章目录自动编号</h2><p>打开文章后，默认next主题右侧是文章目录列表且列表是自动编号的，往往我们在写文章的时候需要在文章中标明第几章第几节，所以我们需要自己手动指定编号，需要修改主题的配置文件<code>themes\next\_config.yml</code>，找到<code>toc:</code>修改<code>number:false</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment"># 侧栏中的目录是否启用</span></span><br><span class="line">  number: <span class="literal">false</span> <span class="comment"># 侧栏中的目录自动编号是否启用</span></span><br><span class="line">  wrap: <span class="literal">true</span> <span class="comment">#侧栏中的目录是否允许折行显示</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python核心编程(第3版)</title>
    <url>/2018/09/17/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-3/</url>
    <content><![CDATA[<h1 id="第1章-正则表达式"><a href="#第1章-正则表达式" class="headerlink" title="第1章 正则表达式"></a>第1章 正则表达式</h1><h2 id="1-1-简介-x2F-动机"><a href="#1-1-简介-x2F-动机" class="headerlink" title="1.1 简介&#x2F;动机"></a>1.1 简介&#x2F;动机</h2><p>操作文本或者数据可是件大事。如果不相信，就仔细看看如今的计算机在做些什么工作：文字处理、网页表单的填写、来自数据库转储信息流、股票报价信息、新闻源，而且这个清单还会不断增长。因为我们可能还不知道需要用计算机编程来处理的文本或数据的具体内容，所以能将这些文本或者数据以某种可被计算机识别和处理模式表达出来是非常有用的。</p>
<p>如何通过编程使计算机具有在文本中检索某种模式的能力。正则表达式为高级的文本模式匹配、抽取、与&#x2F;或文本形式的搜索和替换功能提供了基础。简单地说，正则表达式（简称regex）是一些由字符和特殊符号组成的字符串。它们描述了模式的重复或者表述多个字符，于是正则表达式能按照某种模式匹配一系列有相似特征的字符串。换句话来说，它们能够匹配多个字符串。</p>
<span id="more"></span>
<p>Python通过标准库中的re模块来支持正则表达式。本节将做一个简短扼要的介绍。<br><br><span style="font-size: 14pt; font-weight: bolder;">你的第一个正则表达式</span></p>
<p>前面讲到，正则表达式是包含文本和特殊字符的字符串，该字符串描述一个可以识别种种字符串的模式。现在，让我们看看正则表达式的大部分基本内容，虽然正则表达式通常被视为“高级主题”，但是它们其实也非常简单。把标准字母表用于通用文本，我们展示了一些简单的正则表达式能及这些模式所表述的字符串。下面所介绍的正则表达式都是最基本、最普通的。它们仅仅用一个简单的字符串构造成一个匹配字符串的模式：该字符串由正则表达式定义。下面所示为几个正则表达式和它们所匹配的字符串。</p>
<table>
<thead>
<tr>
<th>正则表达式模式</th>
<th>匹配字符串</th>
</tr>
</thead>
<tbody><tr>
<td>$foo$</td>
<td>$foo$</td>
</tr>
<tr>
<td>$Python$</td>
<td>$Python$</td>
</tr>
<tr>
<td>$abc123$</td>
<td>$abc123$</td>
</tr>
</tbody></table>
<p>上面的第一个正则表达式模式是“foo”。该模式没有使用任何特殊符号去匹配其他符号，而只匹配所描述的内容，所以，能够匹配这个模式的只有包含“foo”的字符串。同理，对于字符串”Python”和“abc123”也一样。正则表达式的强大之处在于引入特殊字符来定义字行集、匹配子组和重复模式。正是由于这些特殊符号，使得正则表达式可以匹配字符串集合，而不仅仅只是某个单个字符串。</p>
<h2 id="1-2-特殊符号和字符"><a href="#1-2-特殊符号和字符" class="headerlink" title="1.2 特殊符号和字符"></a>1.2 特殊符号和字符</h2><p>本节将介绍最常见的特殊符号和字符，即所谓的元字符，正是它给予正则表达式强大的功能和灵活性。表1-1列出了这些最常见的符号和字符。<br><center><span style="font-size: 11px;font-weight: bolder;">表1-1 常见正则表达式符号和特殊字符</span></center></p>
<table>
<thead>
<tr>
<th>表 示 法</th>
<th>描        述</th>
<th>正则有达式示例</th>
</tr>
</thead>
<tbody><tr>
<td><b>符号</b></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$literal$</td>
<td>匹配文本字符串的字面值literal</td>
<td>$foo$</td>
</tr>
<tr>
<td>$re1 &amp;#124; re2$</td>
<td>匹配正则表达式re1或者re2</td>
<td>$foo &amp;#124; bar$</td>
</tr>
<tr>
<td>$.$</td>
<td>匹配任何字符（除了\n之外）</td>
<td>$b.b$</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串起始部分</td>
<td>^$Dear$</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串终止部分</td>
<td>&#x2F;$bin&#x2F;*sh$$</td>
</tr>
<tr>
<td>*</td>
<td>匹配0次或者多次前面出现的正则表达式</td>
<td>[A-Za-z0-9]*</td>
</tr>
<tr>
<td>+</td>
<td>匹配1次或者多次前面出现的正则表达式</td>
<td>[a-z]+.com</td>
</tr>
<tr>
<td>?</td>
<td>匹配0次或者1次前面出现的正则表达式</td>
<td>goo?</td>
</tr>
<tr>
<td>{N}</td>
<td>匹配N次前面出现的正则表达式</td>
<td>[0-9]{3}</td>
</tr>
<tr>
<td>{M,N}</td>
<td>匹配M~N次前面出现的正则表达式</td>
<td>[0-9]{5,9}</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配来自字符集的任意单一字符</td>
<td>[aeiou]</td>
</tr>
<tr>
<td>[…x-y..]</td>
<td>匹配x~y范围中的任意单一字符</td>
<td>[0-9] , [A-Za-z]</td>
</tr>
<tr>
<td>[^…]</td>
<td>不匹配此字符集中出现的任何一个字符，包括某一范围的字符（如果在此字符集中出现）</td>
<td>[^aeiou] , [^A-Za-z0-9]</td>
</tr>
<tr>
<td>(* &amp;#124; + &amp;#124; ? &amp;#124;{})?</td>
<td>用于匹配上面频繁出现&#x2F;重复出现符号的非贪婪版本（*、+、？、{}）</td>
<td>.*?[a-z]</td>
</tr>
<tr>
<td>(…)</td>
<td>匹配封闭的正则表达式，然后另存为子组</td>
<td>([0-9]{3})?,f(oo &amp;#124; u)bar</td>
</tr>
<tr>
<td><b>特殊字符</b></td>
<td></td>
<td></td>
</tr>
<tr>
<td>\d</td>
<td>匹配任何十进制数字，与[0-9]一致（\D与\d相反，不匹配任何非数值型的数字）</td>
<td>data\d+.txt</td>
</tr>
<tr>
<td>\w</td>
<td>匹配任何字母数字字符，与[A-Za-z0-9_]相同（\W与之相反）</td>
<td>[A-Za-z_]\w+</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空格字符，与[\n\t\r\v\f]相同（\S与之相反）</td>
<td>of\sthe</td>
</tr>
<tr>
<td>\b</td>
<td>匹配任何单词连界（\B与之相反）</td>
<td>\bThe\b</td>
</tr>
<tr>
<td>\N</td>
<td>匹配已保存的子组N(参见上面的(…))</td>
<td>price:\16</td>
</tr>
<tr>
<td>\c</td>
<td>逐字匹配任何特殊字符c（即，仅按照字面意义匹配，不匹配特殊含义）</td>
<td>.,\,*</td>
</tr>
<tr>
<td>\A(\Z)</td>
<td>匹配字符串的起始（结束）（另见上面介绍的^与$&#96;</td>
<td>\ADear</td>
</tr>
<tr>
<td><b>扩展表示法</b></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?iLmsux)</td>
<td>在正则表达式中嵌入一个或者多个特殊“标记”参数（或者通过函数&#x2F;方法）</td>
<td>(?x),(? im)</td>
</tr>
<tr>
<td>(?:…)</td>
<td>表示一个匹配不用保存的分组</td>
<td>(?:\w+.)*</td>
</tr>
<tr>
<td>(?P<name>…)</td>
<td>像一个仅由name标识而不是数字ID标识的正则分组匹配</td>
<td>&#96;?P<data>)</td>
</tr>
<tr>
<td>(?p&#x3D;name)</td>
<td>在同一字符串中匹配由<code>(?P&lt;name）</code>分组的之前文本</td>
<td>(?P&#x3D;data)</td>
</tr>
<tr>
<td>(?#…)</td>
<td>表示注释，所有内容都被忽略</td>
<td>(?#comment)</td>
</tr>
<tr>
<td>(?&#x3D;…)</td>
<td>匹配条件是如果…出现在之后的位置，而不使用输入字符串；称作正向前视断言</td>
<td>(?&#x3D;.com)</td>
</tr>
<tr>
<td>(?!…)</td>
<td>匹配条件是如果…不出现在之后的位置，而不使用输入字符串：称作负向前视断言</td>
<td>(?!net)</td>
</tr>
<tr>
<td>(?&lt;&#x3D;…)</td>
<td>匹配条件是如果…出现在之前的位置，而不使用输入字符串：称作正向后视断言</td>
<td>(?&lt;&#x3D;800-)</td>
</tr>
<tr>
<td><code>(?&lt;!...)</code></td>
<td>匹配条件是如果…不出现在之前的位置，而不使用输入字符串：称作负向后视断言</td>
<td>(?&lt;~192.168.)</td>
</tr>
<tr>
<td>(?(id&#x2F;name)Y&#x2F;N)</td>
<td>如果分组所提供的id或者name存在，就返回正则表达式的条件匹配Y,如果不存在，就返回N</td>
<td>(?(1)y &amp;#124; x )1</td>
</tr>
</tbody></table>
<h3 id="1-2-1-使用择一匹配符号匹配多个正则表达式模式"><a href="#1-2-1-使用择一匹配符号匹配多个正则表达式模式" class="headerlink" title="1.2.1 使用择一匹配符号匹配多个正则表达式模式"></a>1.2.1 使用择一匹配符号匹配多个正则表达式模式</h3><p>表示择一匹配的管道符号（&amp;#124;），也就是键盘上的坚线，表示一个“从多个模式中选择其一”的操作。它用于分割不同的正则表达式。例如，在下面的表格中，左边是一些运用择一匹配的模式，右边是左边相应的模式所能够匹配的字符。</p>
<table>
<thead>
<tr>
<th>正则表达式模式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody><tr>
<td>at &amp;#124; home</td>
<td>at、home</td>
</tr>
<tr>
<td>r2d2 &amp;#124; c3po</td>
<td>r2d2、c3po</td>
</tr>
<tr>
<td>bat &amp;#124; bet &amp;#124; bit</td>
<td>bat、bet、bit</td>
</tr>
</tbody></table>
<p>有了这个符号，就能够增强正则表达式的灵活性，使得正则表达式能够匹配多个字符串，而不仅仅只是一个字符串。择一匹配有时候也称作并（union）或者逻辑或（logical OR）。</p>
<h3 id="1-2-2-匹配任意单个字符"><a href="#1-2-2-匹配任意单个字符" class="headerlink" title="1.2.2 匹配任意单个字符"></a>1.2.2 匹配任意单个字符</h3><p>点号或者句点（.）符号匹配除了换行符<code>\n</code>以外的任何字符（Python正则表达式有一个编译标记[S或者DOTALL]，该标记能够推翻这个限制，使点号能够匹配换行符）。无论字母、数字、空格（并不包括<code>\n</code>换行符）、可打印字符、不可打印字符，还是一个符号，使用点号都能够匹配它们。</p>
<table>
<thead>
<tr>
<th>正则表达式模式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody><tr>
<td>f.o</td>
<td>匹配在字母“f”和“o”</td>
</tr>
<tr>
<td>..</td>
<td>任意两个字符</td>
</tr>
<tr>
<td>.end</td>
<td>匹配在字符串end之前的任意一个字符</td>
</tr>
</tbody></table>
<p><br><span style="font-weight: bolder;">问：</span>怎样才能匹配句点（dot）或者句号（period）字符？<br><span sytle="font-weight: bolder;">答：</span>要显式匹配一个句点符号本身，必须使用反斜线转义句点符号的功能，例如<code>\.</code>。</p>
<h3 id="1-2-3-从字符串起始或者结尾或者单词边界匹配"><a href="#1-2-3-从字符串起始或者结尾或者单词边界匹配" class="headerlink" title="1.2.3 从字符串起始或者结尾或者单词边界匹配"></a>1.2.3 从字符串起始或者结尾或者单词边界匹配</h3><p>还有些符号和相关的特殊字符用于在字符串的起始和结尾部分指定用于搜索的模式。如果要匹配字符串的开始位置，就必须使用脱字符（^）或者特殊字符<code>\A</code>(反斜线和大写字母A)。后者主要用于那些没有脱字符的键盘（例如，某些国际键盘）。同样，美元符号（$）或者<code>\Z</code>将用于匹配字符串的末尾位置。</p>
<p>使用这些符号的模式与本章描述的其他大多数模式是不同的，因为这些模式指定了位置或方位。之前的“核心提示”记录了匹配（试图在字符串的开始位置进行匹配）和搜索（试图从字符串的任何位置开始匹配）之间的差别。正因如此，下面是一些表示“边界绑定”的正则表达式搜索模式的示例。</p>
<table>
<thead>
<tr>
<th>正则表达式模式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody><tr>
<td><code>^From</code></td>
<td>任何以From作为起始的字符串</td>
</tr>
<tr>
<td><code>/bin/tcsh$</code></td>
<td>任何以<code>/bin/tcsh</code>作为结尾的字符串</td>
</tr>
<tr>
<td><code>^Subject:hi$</code></td>
<td>任何由单独的字符串<code>Subject:hi</code>构成的字符串</td>
</tr>
</tbody></table>
<p>再次说明，如果想要逐字匹配这些字符中的任何一个（或者全部），就必须使用反斜线进行转义。例如，如果你想要匹配任何以美元符号结尾的字符串，一个可行的正则表达式方案就是使用模式<code>.*\$$</code>。</p>
<p>特殊字符<code>\b</code>和<code>\B</code>可以用来匹配字符边界。而两者的区别在于<code>\b</code>将用于匹配一个单词的边界，这意味着如果一个模式必须位于单词的起始部分，就不管该单词前面（单词位于字符串中间）是否有任何字符（单词位于行首）。同样，<code>\B</code>将匹配出现在一个单词中间的模式（即，不是单词边界）。下面为一些示例。</p>
<table>
<thead>
<tr>
<th>正则表达式模式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody><tr>
<td><code>the</code></td>
<td>任何包含the的字符串</td>
</tr>
<tr>
<td><code>\bthe</code></td>
<td>任何以the开始的字符串</td>
</tr>
<tr>
<td><code>\bthe\b</code></td>
<td>仅仅匹配单词the</td>
</tr>
<tr>
<td><code>\Bthe</code></td>
<td>任何包含但并不以the作为起始的字符串</td>
</tr>
</tbody></table>
<h3 id="1-2-4-创建字符集"><a href="#1-2-4-创建字符集" class="headerlink" title="1.2.4 创建字符集"></a>1.2.4 创建字符集</h3><p>尽管句点可以用于匹配任意符号，但某些时候，可能想要匹配某些特定字符。正因如此，发明了方括号。该正则表达式能够匹配一对方括号中包含的任何字符。下面为一些示例。</p>
<table>
<thead>
<tr>
<th>正则表达式模式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody><tr>
<td><code>b[aeiu]t</code></td>
<td>bat、bet、bit、but</td>
</tr>
<tr>
<td><code>[cr][23][dp][o2]</code></td>
<td>一个包含四个字符的字符串，第一个字符是“c”或“r”，然后是”2”或“3”，后面是“d”或“p”，最后要么是”o”，要么是“2”。例如，c2do、r3p2、r2d2、c3po等</td>
</tr>
</tbody></table>
<p>关于<code>[cr][23][dp][o2]</code>这个正则表达式有一点需要说明：如果仅允许“r2de”或者“c3po”作为有效字符串，就需要更严格限定的正则表达式。因为方括号仅仅表示逻辑或的功能，所以使用方括号并不能实现这一限定要求。唯一的方案就是使用择一匹配，例如，r2d2 &amp;#124; c3po</p>
<p>然而，对于单个字符的正则表达式，使用择一匹配和字符集是等效的。例如，我们以正则表达式“ab”作为开始，该正则表达式只匹配包含字母“a”且后面跟着字母“b”的字符串，如果我们想要匹配一个字母的字符串，例如，要么匹配“a”，要么匹配“b”，就可以使用正则表达式[ab]，因为此时字母“a”和字母“b”是相互独立的字符串。我们也可以选择正则表达式a &amp;#124; b。然而，如果我们想要匹配满足模式“ab”后面跟着“cd”的字符串，我们就不能使用方括号，因为字符集的方法只适用于单字符的情况。这种情况下，唯一的方法就是使用ab &amp;#124; cd，这与刚才提到的r2d2&#x2F;c3po问题是相同的。</p>
<h3 id="1-2-5-限定范围和否定"><a href="#1-2-5-限定范围和否定" class="headerlink" title="1.2.5 限定范围和否定"></a>1.2.5 限定范围和否定</h3><p>除了单字符以外，字符集还支持匹配指定的字符范围。方括号中两个符号中间用连字符（｀-｀）连接，用于指定一个字符的范围：例如，A－Z、a-z或者0－9分别用于表示大写字母、小写字母和数值数字。这是一个按照字母顺序的范围，所以不能将它们仅仅限定用于字母和十进制数字上。另外，如果脱字符（<code>^</code>）紧跟在左方括号后面，这个符号就表示不匹配给定字符集中的任何一个字符。</p>
<table>
<thead>
<tr>
<th>正则表达式模式</th>
<th>匹配的字符</th>
</tr>
</thead>
<tbody><tr>
<td><code>z.[0-9]</code></td>
<td>字母z后面跟着任何一个字符，然后跟着一个数字</td>
</tr>
<tr>
<td><code>[r-u][env-y][us]</code></td>
<td>字母r、s、t或者u后面跟着e、n、v、w、x或者y，然后跟着u或者s</td>
</tr>
<tr>
<td><code>[^aeiou]</code></td>
<td>一个非元音字符（练习：为什么我们说“非元音”而不是“辅音”）</td>
</tr>
<tr>
<td><code>[^\t\n]</code></td>
<td>不匹配制表符或者<code>\n</code></td>
</tr>
<tr>
<td><code>[&quot;-a]</code></td>
<td>在一个ASCII系统中，所有字符都位于””和“a”之间，即34－97之间</td>
</tr>
</tbody></table>
<h3 id="1-2-6-使用闭包操作符实现存在性和频数匹配"><a href="#1-2-6-使用闭包操作符实现存在性和频数匹配" class="headerlink" title="1.2.6 使用闭包操作符实现存在性和频数匹配"></a>1.2.6 使用闭包操作符实现存在性和频数匹配</h3><p>本节介绍最常用的正则表达式符号，即特殊符号<code>*、+、?</code>，所有这些都可以用于匹配一个、多个或者没有出现的字符串模式。星号或者星号操作符（*）将匹配其左边的正则表达式出现零次或者多次的情况（在计算机编程语言和编译原理中，该操作称为Kleene闭包）。加号（+）操作符将匹配一次或者多次出现正则表达式（也叫做正闭包操作符），问号（？）操作符将匹配零次或者一次出现的正则表达式。</p>
<p>还有大括号操作符（｛｝），里面或者是单个值或者是一对由逗号分隔的值。这将最终精确地匹配前面的正则表达式N次（如果是｛N｝）或者一定范围的次数；例如，｛M，N｝将匹配M～N次出现。这些符号能够由反斜线符号转义；<code>\*</code>匹配星号，等等。</p>
<p>注意，在这前的表格中曾经多闪使用问号（重载），这意味着要么匹配0次，要么匹配1次，或者其他含义：如果问号紧跟在任何使用闭合操作符的匹配后面，它将直接要求正则表达式引擎匹配尽可能少的次数。</p>
<p>“尽可能少的次数”是什么意思？当模式匹配使用分组操作符时，正则表达式引擎将试图“吸收”匹配该模式的尽可能多的字符。这通常被叫做贪婪匹配。问号要求正则表达式引擎去“偷懒”，如果可能，就在当前的正则表达式中尽可能少地匹配字符，留下尽可能多的字符给后面的模式（如果存在）。本章末尾将用一个典型的示例来说明非贪婪匹配是很有必要的。现在继续查看闭包操作符。</p>
<table>
<thead>
<tr>
<th>正则表达式模式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody><tr>
<td><code>[dn]ot?</code></td>
<td>字母d或者n，后面跟着一个o，然后是最多一个t，例如,do、no、dot、not</td>
</tr>
<tr>
<td><code>0?[1-9]</code></td>
<td>任何数值数字，它可能前置一个0，例如，匹配一系统数（表示从1～9月的数值），不管是一个还是两个数字</td>
</tr>
<tr>
<td><code>[0-9]&#123;15,16&#125;</code></td>
<td>匹配15或者16个数字（例如信用卡号码）</td>
</tr>
<tr>
<td><code>&lt;/[^&gt;]+&gt;</code></td>
<td>匹配全部有效的（和无效的）HTML标签</td>
</tr>
<tr>
<td><code>[KQRBNP][a-h][1-8]-[a-h][1-8]</code></td>
<td>在“长代数”标记法中，表示国际象棋合法的棋盘移动（仅移动，不包括吃子和将军）。即”K”、”Q”、”R”、”B”、“N”或“P”等字母后面加上“a1”~”h8”之间的棋盘坐标。前面的坐标表示从哪里开始走棋，后面的坐标代表走到哪个位置（棋格）上</td>
</tr>
</tbody></table>
<h3 id="1-2-7-表示字符集的特殊字符"><a href="#1-2-7-表示字符集的特殊字符" class="headerlink" title="1.2.7 表示字符集的特殊字符"></a>1.2.7 表示字符集的特殊字符</h3><p>我们还提到有一些特殊字符能够表示字符集。与使用“0－9”这个范围表示十进制数相比，可以简单地使用d表示匹配任何十进制数字。另一个特殊字符（\w）能够用一于表示全部字母数字的字符集，相当于<code>[A-Za-z0-9]</code>的缩写形式，\s可以用来表示空格字符。这些特殊字符的大写版本表示不匹配；例如，\D表示任何非十进制数（与[^0-9]相同），等等。<br>使用这些缩写，可以表示如下一些更复杂的示例。</p>
<table>
<thead>
<tr>
<th>正则表达式模式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody><tr>
<td><code>\w+-\d+</code></td>
<td>一个由字母数字组成的字符串和一串由一个连字符分隔的数字</td>
</tr>
<tr>
<td><code>[A-Za-z]\w</code></td>
<td>第一个字符是字母；其余字符（如果存在）可以是字母或者数字（几乎等价于Python中的有效标识行［参见练习］）</td>
</tr>
<tr>
<td><code>\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;</code></td>
<td>美国电话号码的格式，前面是区号前缀，例如800-555-1212</td>
</tr>
<tr>
<td><code>\w+@\w+\.com</code></td>
<td>以<a href="mailto:&#88;&#x58;&#88;&#64;&#x79;&#121;&#121;&#x2e;&#x63;&#x6f;&#109;">&#88;&#x58;&#88;&#64;&#x79;&#121;&#121;&#x2e;&#x63;&#x6f;&#109;</a>格式表示的简单电子邮件地址</td>
</tr>
</tbody></table>
<h3 id="1-2-8-使用圆括号指定分组"><a href="#1-2-8-使用圆括号指定分组" class="headerlink" title="1.2.8 使用圆括号指定分组"></a>1.2.8 使用圆括号指定分组</h3><p>现在，我们已经可以实现匹配某个字符串以及丢弃不匹配的字符串，但有些时候，我们可能会对之前匹配成功的数据更感兴趣。我们不仅想要知道整个字符串是否匹配我们的标准，而且想要知道能否提取任何已经成功匹配的特定字符串或者子字符串。答案是可以，要实现这个目标，只要用一对圆括号包裹任何正则表达式。</p>
<p>当使用正则表达式时，一对圆括号可以实现以下任意一个（或者两个）功能：<br>×　对正则表达式进行分组<br>×　匹配子组</p>
<p>关于为何想要对正则表达式进行分组的一个很好的示例是：当有两个不同的正则表达式而且想用它们来比较同一个字符串时。另一个原因是对正则表达式进行分组可以在整个正则表达式中使用重复操作符（而不是一个单独的字符或者字符集）。</p>
<p>使用圆括号进行分组的一个副作用就是，匹配模式的子字符串可以保存起来供后续使用。这些子组能够被同一次的匹配或者搜索重复调用，或者提取出来用于后续处理。1.3.9节的结尾将给出一些提取子组的示例。</p>
<p>为什么匹配子组这么重要呢？主要原因是在很多时候除了进行匹配操作以外，我们还想要提取所匹配的模式。例如，如果决定匹配模式<code>\w+-\d+</code>，但是想要分别保存第一部分的字母和第二部分的数字，该如何实现？我们可能想要这样做的原因是，对于任何成功的匹配，我们可能想要看到这些匹配正则表达式模式的字符串究竟是什么。</p>
<p>如果为两个子模式都加上圆括号，例如<code>(\w+)-(\d+)</code>，然后就能够分别访问每一个匹配子组。我们更倾向于使用子组，这是因为择一匹配通过编写代码来判断是否匹配，然后执行另一个单独的程序（该程序也需要另行创建）来解析整个匹配仅仅用于提取两个部分。为什么不让Python自己实现呢？这是re模块支持的一个特性，所以为什么非要重蹈覆辙呢？</p>
<table>
<thead>
<tr>
<th>正则表达式模式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody><tr>
<td><code>\d+(\.\d*)</code></td>
<td>表示简单浮点数的字符串；也就是说，任何十进制数字，后面可以接一个小数点和零个或者多个十进制数字，例如“0.004”、“2”、“75.”等</td>
</tr>
<tr>
<td><code>(Mr?s?\.)?[A-Z][a-z]*[A-Za-z-]+</code></td>
<td>名字和姓氏，以及对名字的限制（如果有，首字母必须大写，后续字母小写），全名前可以有可选的“Mr.”、“Mrs.”、”Ms.”、或者“M.”作为称谓，以及灵活可选的姓氏，可以有多个单词、横线以及大写字母</td>
</tr>
</tbody></table>
<h3 id="1-2-9-扩展表示法"><a href="#1-2-9-扩展表示法" class="headerlink" title="1.2.9 扩展表示法"></a>1.2.9 扩展表示法</h3><p>我们还没介绍过的正则表达式的最后一个方面是扩展表示法，它们是以问号开始（?…）。我们不会为此花费太多时间，因为它们通常用于在判断匹配之前提供标记，实现一个前视（或者后视）匹配，或者条件检查。尽管圆括号使用这些符号，但是只有(?P<name>)表述一个分组匹配。所有其他的都没有创建一个分组。然而，你仍然需要知道它们是什么，因为它们可能最适合于你所需要完成的任务。</p>
<table>
<thead>
<tr>
<th>正则表达式模式</th>
<th>匹配的字符串</th>
</tr>
</thead>
<tbody><tr>
<td><code>(?:\w+\.)*</code></td>
<td>以句点作为结尾的字符串，例如“google.”、“twitter.”、“facebook.”，但是这些匹配不会保存下来供后续的使用和数据检索</td>
</tr>
<tr>
<td><code>(?#comment)</code></td>
<td>此处并不做匹配，只是作为注释</td>
</tr>
<tr>
<td><code>(?=.com)</code></td>
<td>如果一个字符串后面跟着“.com”才做匹配操作，并不使用任何目标字符串</td>
</tr>
<tr>
<td><code>(?!.net)</code></td>
<td>如果一个字符串后面不是跟着<code>.net</code>才做匹配操作</td>
</tr>
<tr>
<td><code>(?&lt;=800-)</code></td>
<td>如果字符串之前为<code>800-</code>才做匹配，假定为电话号码，同样，并不使用任何输入字符串</td>
</tr>
<tr>
<td><code>?&lt;!192\.168\.)</code></td>
<td>如果一个字符串之前不是“192.168.” 才做匹配操作，假定用于过滤掉一组C类IP地址</td>
</tr>
<tr>
<td>(?(1)y &amp;#124; x)</td>
<td>如果一个匹配组1（\1）存在，就与y匹配；否则，就与x匹配。</td>
</tr>
</tbody></table>
<h2 id="1-3-正则表达式和Python语言"><a href="#1-3-正则表达式和Python语言" class="headerlink" title="1.3 正则表达式和Python语言"></a>1.3 正则表达式和Python语言</h2><p>在了解了关于正则表达式的全部知识后，开始查看Python当前如何通过使用re模块来支持正则表达式，re模块在古老的Python1.5版中引入，用于替换那些已过时的regex模块和regsub模块－这两个模块在Python2.5版本中移除，而且此后导入这两个模块中的任意一个都会触发ImportError异常。</p>
<p>re模块支持更强大而且更通用的Perl风格（Perl 5风格）的正则表达式，该模块允许多个线路共享同一个已编译的正则表达式对象，也支持命名子组。</p>
<h3 id="1-3-1-re模块：核心函数和方法"><a href="#1-3-1-re模块：核心函数和方法" class="headerlink" title="1.3.1　re模块：核心函数和方法"></a>1.3.1　re模块：核心函数和方法</h3><p>表1－2列出了来自re模块的更多常见函数和方法。它们中的大多数函数也与已经编译的正则表达式对象（regex object）和正则匹配对象（regex match object）的方法同名并且具有相同的功能。本节将介绍两主主要的函数&#x2F;方法－－match()和search()，以及compile()函数。下一节将介绍更多的函数，但如果想进一步了解将要介绍或者没有介如的更多相关信息，请查阅Python的相关文档。<br><br><center><span style="font-size: 12px; font-weight: bolder;">表1－2 常见的正则表达式属性</span></center></p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>描　　　　述</th>
</tr>
</thead>
<tbody><tr>
<td>仅仅是re模块函数</td>
<td></td>
</tr>
<tr>
<td>$compile(pattern, flags&#x3D;0)$</td>
<td>使用任何可选的标记来编译正则表达式的模式，然后返回一个正则表达式对象</td>
</tr>
<tr>
<td>re模块函数和正则表达式对象的方法</td>
<td></td>
</tr>
<tr>
<td>$match(pattern, string, flags&#x3D;0)$</td>
<td>尝试使用带有可选的标记的正则表达式的模式来匹配字符串。如果匹配成功，就返回匹配对象；如果失败，就返回None</td>
</tr>
<tr>
<td>$search(pattern, string, flags&#x3D;0)$</td>
<td>使用可选标记搜索字符串中第一次出现的正则表达式模式。如果匹配成功，则返回匹配对象；如果失败就返回None</td>
</tr>
<tr>
<td>$findall(pattern, string[,flags])^➀$</td>
<td>查找字符串中所有（非重复）出现的正则表达式模式，并返回一个匹配列表</td>
</tr>
<tr>
<td>$finditer(patern, string[,flags])^➁$</td>
<td>与findall()函数相同，但返回的不是一个列表，而是一个迭代器，对于每一次匹配，迭代器都返回一个匹配对象</td>
</tr>
<tr>
<td>$split(pattern, string, max&#x3D;0)^➂$</td>
<td>根据正则表达式的模式分隔符，split函数将字符串分割为列表，然后返回成功匹配的列表，分隔最多操作max次（默认分割所有匹配成功的位置）</td>
</tr>
<tr>
<td>re模块函数和正则表达式对象方法</td>
<td></td>
</tr>
<tr>
<td>$sub(pattern, repl, string, count&#x3D;0)^➂$</td>
<td>使用repl替换所有正则表达式的模式在字符串中出现的位置，除非定义count，否则就将替换所有出现的位置（另见subn()函数，该函数返回替换操作的数目）</td>
</tr>
<tr>
<td>$purge()$</td>
<td>清除隐式编译的正则表达式模式</td>
</tr>
<tr>
<td>常用的匹配对象方法（查看文档以获取更多信息）</td>
<td></td>
</tr>
<tr>
<td>$group(num&#x3D;0)$</td>
<td>返回整个匹配对象，或者编号为num的特定子组</td>
</tr>
<tr>
<td>$groups(default&#x3D;None)$</td>
<td>返回一个包含所有匹配子组的元组（如果没有成功匹配，则返回一个空元组）</td>
</tr>
<tr>
<td>$groupdict(default&#x3D;None)$</td>
<td>返回一个包含所有匹配的命名子组的字典，所有的子组名称作为字典的键（如果没有成功匹配，则返回一个空字典）</td>
</tr>
<tr>
<td>re.I、re.IGNORECASE</td>
<td>不区分大小写的匹配</td>
</tr>
<tr>
<td>re.L、re.LOCALE</td>
<td>根据所使用的本地语言环境通过\w、\W、\b、\B、\s、\S实现匹配</td>
</tr>
<tr>
<td>re.M、re.MULTILINE</td>
<td>^和$分别匹配目标字符串中行的起始和结尾，而不是严格匹配整个字符串本身的起始和结尾</td>
</tr>
<tr>
<td>re.S、rer.DOTALL</td>
<td>“.”（点号）通常匹配除了\n（换行符）之外的所有单个字符；该标记表示“.”（点号）能够匹配全部字符</td>
</tr>
<tr>
<td>re.X、re.VERBOSE</td>
<td>通过反斜线转义，否则的有空格加上＃（以及在该行中所有后续文字）都被忽略，除非在一个字符类中或者允许注释并且提高可读性。</td>
</tr>
<tr>
<td><span style="font-size: 10pt;"></td>
<td></td>
</tr>
<tr>
<td>➀　Python　1.5.2版本中新增；2.4版本中增加flags参数</td>
<td></td>
</tr>
<tr>
<td>➁　Python　2.2版中新增；2.4版中增加flags参数。</td>
<td></td>
</tr>
<tr>
<td>➂　Python　2.7和3.1版中增加flags参数。</td>
<td></td>
</tr>
<tr>
<td></span></td>
<td></td>
</tr>
</tbody></table>
<div class="note primary"><p>核心提示：编译正则表达式（编译还是不编译？）<br>在Core Python Programming或者即将出版的Core Python Language Fundamentals的执行环境章节中，介绍了Python代码最终如何被编译成字节码，然后在解释器上执行。特别是我们指定eval()或者exec（在2.X版本中或者在3.x版本的exec()中）调用一个代码对象而不是一个字符串，性能上会有明显提升。这是由于对于前者而言，编译过程不会重复执行。换句话说，使用预编译的代码对象比直接使用字符串要快，因为解释器在执行字符串形式的代码前都必须把字符串编译成代码对象。</p>
<p>同样的概念也适用于正则表达式－－在模式匹配发生之前，正则表达式模式必须编译成正则表达式对象。由于正则表达式在执行过程中将进行多次比较操作，因此强烈建议使用预编译。而且，既然正则表达式的编译是必需的，那么使用预编译来提升执行性能无疑是明智之举。re.compile()能够提供此功能。</p>
<p>其实模块函数会对已编译的对象进行缓存，所以不是所有使用相同正则表达式模式的search()和match()都需要编译。即使这样，你也节省了缓存查询时间，并且不必对于相同的字符串反复进行函数调用。在不同的Python版本中，缓存中已经编译过的正则表达式对象的数目可能不同，而且没有文档记录。purge()函数能够用于清除这些缓存。</p>
</div>

<h3 id="1-3-2-使用compile-函数编译正则表达式"><a href="#1-3-2-使用compile-函数编译正则表达式" class="headerlink" title="1.3.2 使用compile()函数编译正则表达式"></a>1.3.2 使用compile()函数编译正则表达式</h3><p>后续将扼要介绍的几乎所有的re模块函数都可以作为regex对象的方法。注意，尽管推荐预编译，但它并不是必需的。如果需要编译，就使用编译过的方法；如果不需要编译，就使用函数。幸运的是，不管使用函数还是方法，它们的名字都是相同的（也许你需对此感到好奇，这就是模块函数和方法的名字相同的原因，例如，search()、match()等）。因这这在大多数示例中省去一个小步骤，所以我们将使用字符串替代。我们仍将会遇到几个预编译代码的对象，这样就可以知道它的过程是怎么回事。</p>
<p>对于一些特别的正则表达式编译，可选的标记可能以参数的形式给出，这些标记允许不区分大小写的匹配，使用系统的本地化设置来匹配字母数字，等等。请参考表1－2中的条目以及在正式的官方文档中查询关于这些标记（re.IGNORECASE、re.MULTILINE、re.DOTALL、re.VERROSE等）的更多信息。它们可以通过按位或操作符（&amp;#124;）合并。</p>
<p>这些标记也可以作为参数适用于大多数re模块函数。如果想要在方法中使用这些标记，它们必须已经集成到已编译的正则表达式对象之中，或者需要使用直接嵌入到正则表达式本身的(?F)标记，其中F是一个或者多个i（用于re.I&#x2F;IGNORECASE）、m（用于re.M&#x2F;MULTILINE）、s（用于re.S&#x2F;DOTALL）等。如果想要同时使用多个，就把它们放在一起而不是使用按位或操作，例如，（?im）可以用于同时表示re.IGNORECASE和re.MULTILINE.</p>
<h3 id="1-3-3-匹配对象以及group-和groups-方法"><a href="#1-3-3-匹配对象以及group-和groups-方法" class="headerlink" title="1.3.3 匹配对象以及group()和groups()方法"></a>1.3.3 匹配对象以及group()和groups()方法</h3><p>当处理正则表达式时，除了正则表达式对象之外，还有另一个对象类型：匹配对象。这些是成功调用match()或者search()返回的对象。匹配对象有两个主要的方法：group()和groups()。</p>
<p>groups()要么返回整个匹配对象，要么根据要求返回特定子组。groups()则仅返回一个包含唯一或者全部子组的元组。如果没有子组的要求，那么当group()仍然返回整个匹配时，groups()返回一个空元组。</p>
<p>Python正则表达式也允许命名匹配，这部分内容超出了本节的范围。建议读者查阅完整的re模块文档，里面有这里省略掉的关于这些高级主题的详细内容。</p>
<h3 id="1-3-4-使用match-方法匹配字符串"><a href="#1-3-4-使用match-方法匹配字符串" class="headerlink" title="1.3.4 使用match()方法匹配字符串"></a>1.3.4 使用match()方法匹配字符串</h3><p>match()是将要介绍的第一个re模块函数和正则表达式对象（regex object）方法。match()函数试图从字符串的起始部分对模式进行匹配。如果匹配成功，就返回一个匹配对象：如果匹配失败，就返回None，匹配对象的group()方法能够用于显示那个成功的匹配。下面是如何运用match()（以及group()）的一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>模式<code>foo</code>完全匹配字符串“foo”，我们也能够确认m是交互式解释器中匹配对象的示例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m        <span class="comment"># 确认返回的匹配对象</span></span><br><span class="line">&lt;re.MatchObject instance at 80ebf48&gt;</span><br></pre></td></tr></table></figure>
<p>如下为一个失败的匹配示例，它返回None。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)    <span class="comment">#　模式并不能匹配字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()   <span class="comment"># (单行版本的if语句)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>因为上面的匹配失败，所以m被赋值为None，而且以此方法构建的if语句没有指明任何操作。对于剩余的示例，如果可以，为了简洁起见，将省去if语句块，但在实际操作中，最好不要省去以避免AttributeError异常（None是返回的错误值，该值并没有group()属性［方法］）。</p>
<p>只要模式从字符串的起始部分开始匹配，即使字符串比模式长，匹配也仍然能够成功。例如，模式“foo”将在字符串“foo on the table”中找到一个匹配，因为它是从字符串的起始部分进行匹配的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;food on the table&#x27;</span>)  <span class="comment">#匹配成功</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group()</span><br><span class="line">`foo`</span><br></pre></td></tr></table></figure>
<p>可以看到，尽管字符串比模式要长，但从字符串起始部分开始匹配就会成功。子串“foo”是从那个比较长的字符串中抽取出来的匹配部分。</p>
<p>甚至可以充分利用Python原生的面向对象的特性，忽略保存中间过程产生的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.<span class="keyword">match</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;food on the table&#x27;</span>).group()</span><br><span class="line"><span class="string">&#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意，在上面的一些示例中，如果匹配失败，将会抛出AttributeError异常。</p>
<h3 id="1-3-5-使用search-在一个字符串中查找模式（搜索与匹配的对比）"><a href="#1-3-5-使用search-在一个字符串中查找模式（搜索与匹配的对比）" class="headerlink" title="1.3.5 使用search()在一个字符串中查找模式（搜索与匹配的对比）"></a>1.3.5 使用search()在一个字符串中查找模式（搜索与匹配的对比）</h3><p>其实，想要搜索的模式出现在一个字符串中间部分的概率，远大于出现在字符串起始部分的概率。这也就是search()派上用场的时候了。search()的工作方式与match()完全一致，不同之外在于search()会用它的字符串参数，在任意位置对给定正则表达式模式搜索第一次出现的匹配情况。如果搜索到成功的匹配，就会返回一个匹配对象；否则，返回None。</p>
<p>我们将再次举例说明match(）和search()之间的差别。以匹配一个更长的字符串为例，这次使用字符串”foo”去匹配“seafood”:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;seafood&#x27;</span>)    <span class="comment">#匹配失败</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br></pre></td></tr></table></figure>
<p>可以看到，此处匹配失败。match()试图从字符串的起始部分开始匹配模式；也就是说，模式中的“f”将匹配到字符串的首字母“s”上，这样的匹配肯定是失败的。然而，字符串“foo”确实出现在“seafood”之中（某个位置），所以，我们该如何让Python得出肯定的结果呢？答案是使用search()函数，而不是尝试匹配。search()函数不但会搜索模式在字符串中第一次出现的位置。而且严格地对字符串从左到右搜索。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m= re.search(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;seafood&#x27;</span>)    <span class="comment"># 使用search()代替</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;foo&#x27;</span>       <span class="comment"># 搜索成功，但进匹配失败</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>此外，match()和search()都使用在<code>1.3.2</code>节中介绍的可选的标记参数。最后，要要注意的是，等价的正则表达式对象方法使用可选的<code>pos</code>和<code>endpos</code>参数来指定目标字符串的搜索范围。</p>
<p>本节后面将使用match()和search()正则表达式对象方法以及group()和groups()匹配对象方法，通过展示大量的实例来说明Python中正则表达式的使用方法。我们将使用正则表达式的语法几乎全部的特殊字符和符号。</p>
<h3 id="1-3-6-匹配多个字符串"><a href="#1-3-6-匹配多个字符串" class="headerlink" title="1.3.6 匹配多个字符串"></a>1.3.6 匹配多个字符串</h3><p>在1.2节中，我们在正则表达式<code>bat|bet|bit</code>中使用了择一匹配（&amp;#124;）符号。如下为在Python中使用正则表达式的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bt = <span class="string">&#x27;bat|bet|bit&#x27;</span>    <span class="comment"># 正则表达式模式：bat、bet、bit</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(bt, <span class="string">&#x27;bat&#x27;</span>)    <span class="comment"># bat是一个匹配</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group() </span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;bat&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(bt, <span class="string">&#x27;blt&#x27;</span>)    <span class="comment"># 对于blt没有匹配</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(bt, <span class="string">&#x27;He bit me!&#x27;</span>)    <span class="comment"># 不能匹配字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.rearch(bt, ‘He bit me!’)    <span class="comment"># 通过搜索查找bit</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;bit&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-7-匹配任何单个字符"><a href="#1-3-7-匹配任何单个字符" class="headerlink" title="1.3.7　匹配任何单个字符"></a>1.3.7　匹配任何单个字符</h3><p>在后续的示例中，我们展示了点号（.）不能匹配一个换行符<code>\n</code>或者非字符，也就是说，一个空这符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>anyend = <span class="string">&#x27;.end&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(anyend, <span class="string">&#x27;bend&#x27;</span>)    <span class="comment"># 点号匹配&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;bend&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(anyend, <span class="string">&#x27;end&#x27;</span>)    <span class="comment"># 不匹配任何字符</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(anyend, <span class="string">&#x27;\nend&#x27;</span>)    <span class="comment"># 除了\n之外的任何字符</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">&#x27;.end&#x27;</span>, <span class="string">&#x27;The end.&#x27;</span>)    <span class="comment"># 在搜索中匹配‘　’</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27; end&#x27;</span></span><br></pre></td></tr></table></figure>
<p>下面的示例在正则表达式中搜索一个真正的句点（小数点），而我们通过使用一个反斜线对句点的功能进行转义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patt314 = <span class="string">&#x27;3.14&#x27;</span>  <span class="comment"># 表示正则表达式的点号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi_patt = <span class="string">&#x27;3\.14&#x27;</span>　<span class="comment"># 表示字面量的点号（dec. point）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(pi_patt, <span class="string">&#x27;3.14&#x27;</span>)  <span class="comment"># 精确匹配</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;3.14&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(patt314, <span class="string">&#x27;3014&#x27;</span>) <span class="comment"># 点号匹配‘0’</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;3014&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(patt314, <span class="string">&#x27;3.14&#x27;</span>) <span class="comment"># 点号匹配&#x27;.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;3.14&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-8-创建字符集（［-］）"><a href="#1-3-8-创建字符集（［-］）" class="headerlink" title="1.3.8 创建字符集（［　］）"></a>1.3.8 创建字符集（［　］）</h3><p>前面详细讨论了<code>[cr][23][dp][o2]</code>，以及它们与<code>r2d2|c3po</code>之前的差别。下面的示例将说明对于<code>r2d2|c3po</code>的限制将比&#96;&#96;更为严格。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;[cr][23][dp][o2]&#x27;</span>, <span class="string">&#x27;c3po&#x27;</span>)    <span class="comment"># 匹配‘c3po’</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;c3po&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;[cr][23][dp][o2]&#x27;</span>, <span class="string">&#x27;c2do&#x27;</span>)  <span class="comment"># 匹配&#x27;c2do&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;c2do&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;r2d2|c3po&#x27;</span>, <span class="string">&#x27;c2do&#x27;</span>)  <span class="comment"># 不匹配&#x27;c2do&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;r2d2|c3po&#x27;</span>,<span class="string">&#x27;r2d2&#x27;</span>)  <span class="comment"># 匹配‘r2d2’</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;r2d2&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-9-重复、特殊字符以及分组"><a href="#1-3-9-重复、特殊字符以及分组" class="headerlink" title="1.3.9 重复、特殊字符以及分组"></a>1.3.9 重复、特殊字符以及分组</h3><p>正则表达式中最常见的情况包括特殊字符的使用、正则表达式模式的重复出现，以及使用圆括号对匹配模式的各部分进行分组和提取操作。我们曾看到过一个关于简单电子邮件地址。正则表达式（<code>\w+@\w+\.com</code>）。或许我们想要匹配比这个正则表达式所允许的的更多邮件地址。为了在域名前添加主机名称支持，例如<a href="http://www.xxx.com，仅仅允许xxx.com作为整个域名，必须修改现有的正则表达式。为了表示主机名是可选的，需要创建一个模式来匹配主机名（后面跟着一个句点），使用“？”操作符来表示该模式出现零次或者一次，然后按照如下所示的方式，插入可选的正则表达式到之彰的正则表达式中：`\w+@(\w+\.)?\w+\.com`。从下面的示例中可见，该表达式允许.com前面有一个或者两个名称：">www.xxx.com，仅仅允许xxx.com作为整个域名，必须修改现有的正则表达式。为了表示主机名是可选的，需要创建一个模式来匹配主机名（后面跟着一个句点），使用“？”操作符来表示该模式出现零次或者一次，然后按照如下所示的方式，插入可选的正则表达式到之彰的正则表达式中：`\w+@(\w+\.)?\w+\.com`。从下面的示例中可见，该表达式允许.com前面有一个或者两个名称：</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patt = <span class="string">&#x27;\w+@(\w+\.)?\w+\.com&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.<span class="keyword">match</span>(patt, <span class="string">&#x27;nobody@xxx.com&#x27;</span>).group()</span><br><span class="line"><span class="string">&#x27;nobody@xxx.com&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.<span class="keyword">match</span>(patt, <span class="string">&#x27;nobody@www.xxx.com&#x27;</span>).group()</span><br><span class="line"><span class="string">&#x27;nobody@www.xxx.com&#x27;</span></span><br></pre></td></tr></table></figure>
<p>接下来，用以下模式来进一步扩展该示例，允许任意数量的中间子域名存在。请特别注意细节的变化，将“？”改为“*.:\w+@(\w+.)*\w+.com”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patt = <span class="string">&#x27;\w+@(\w+\.)*\w+\.com&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.<span class="keyword">match</span>(patt, <span class="string">&#x27;nobody@www.xxx.yyy.zzz.com&#x27;</span>).group()</span><br><span class="line"><span class="string">&#x27;nobody@www.xxx.yyy.zzz.com&#x27;</span></span><br></pre></td></tr></table></figure>
<p>但是，我们必须要添加一个“免责声明”，即仅仅使用字母数字字符并不能匹配组成电子邮件地址的全部可能字符。上述正则表达式不能匹配诸如xxx-yyy.com的域名或者使用非单词\w字符组成的域名。</p>
<p>之前讨论过使用圆括号来匹配和保存子组，以便于后续处理，而不是确定一个正则表达式匹配之后，在一个单独的子程序里面手动编码来解析字符串。此前还特别讨论过一个简单的正则表达式模式<code>\w+-\d+</code>，它由连字符号分隔的字母数字字符串和数字组成，还讨论了如何添加一个子组来构造一个新的正则表达式<code>(\w+)-(\d+)</code>来完成这项工作。下面是初始版本的正则表达式的执行情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;\w\w\w-\d\d\d&#x27;</span>, <span class="string">&#x27;abc-123&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;abc_123&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;\w\w\w-\d\d\d&#x27;</span>, <span class="string">&#x27;abc-xyz&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，创建了一个正则表达式来识别包含3个字母数字字符且后面跟着3个数字的字符串。使用abc-123测试该正则表达式，将得于正确的结果，但是使用abc-xyz则不能。现在，将修改之前讨论过的正则表达式，使该正则表达式能够提取字母数字字符串和数字。如下所示，请注意如何使用group()方法访问每个独立的子组以及groups()方法以获取一个包含所有匹配子组的元组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;(\w\w\w)-(\d\d\d)&#x27;</span>, <span class="string">&#x27;abc-123&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group()                        <span class="comment"># 完整匹配</span></span><br><span class="line">‘abc-<span class="number">123</span>’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)                       <span class="comment"># 子组1</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)                       <span class="comment"># 子组2</span></span><br><span class="line"><span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()                       <span class="comment"># 全部子组</span></span><br><span class="line">(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>由以上脚本内容可见，group()通常用于以普通方式显示所有的匹配部分，但也能用于获取各个匹配的子组。可以使用groups()方法来获取一个包含所有匹配子字符串的元组。</p>
<p>如下为一个简单的示例，该示例展示了不同的分组排列，这将使整个事情变得更加清晰。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>)          <span class="comment"># 没有子组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group()                         <span class="comment"># 完整匹配</span></span><br><span class="line"><span class="string">&#x27;ab&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()                        <span class="comment"># 所有子组</span></span><br><span class="line">()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;(ab)&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>)        <span class="comment"># 一个子组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group()                         <span class="comment"># 完整匹配</span></span><br><span class="line"><span class="string">&#x27;ab&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)                        <span class="comment"># 子组1</span></span><br><span class="line"><span class="string">&#x27;ab&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()                        <span class="comment"># 全部子组</span></span><br><span class="line">(<span class="string">&#x27;ab&#x27;</span>,)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;(a)(b)&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>)      <span class="comment"># 两个子组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group()                         <span class="comment"># 完整匹配</span></span><br><span class="line"><span class="string">&#x27;ab&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)                        <span class="comment"># 子组1</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)                        <span class="comment"># 子组2</span></span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()                        <span class="comment"># 所有子组</span></span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(<span class="string">&#x27;(a(b))&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>)      <span class="comment"># 两个子组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group()                         <span class="comment"># 完整匹配</span></span><br><span class="line"><span class="string">&#x27;ab&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)                        <span class="comment"># 子组1</span></span><br><span class="line"><span class="string">&#x27;ab&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)                        <span class="comment"># 子组2</span></span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()                        <span class="comment"># 所有子组</span></span><br><span class="line">(<span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-3-10-匹配字符串的起始和结尾以及单词边界"><a href="#1-3-10-匹配字符串的起始和结尾以及单词边界" class="headerlink" title="1.3.10 匹配字符串的起始和结尾以及单词边界"></a>1.3.10 匹配字符串的起始和结尾以及单词边界</h3><p>如下示例突出显示表示位置的正则表达式操作符。该操作符更多用于表示搜索而不是匹配，因为match()总是从字符串开始位置进行匹配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">&#x27;^The&#x27;</span>, <span class="string">&#x27;The end.&#x27;</span>)         <span class="comment">#　匹配</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;The&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">&#x27;^The&#x27;</span>, <span class="string">&#x27;end. The&#x27;</span>)         <span class="comment"># 不作为起始</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">r&#x27;\bthe&#x27;</span>, <span class="string">&#x27;bite the dog&#x27;</span>)   <span class="comment"># 在边界</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;the&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">r&#x27;\bthe&#x27;</span>, <span class="string">&#x27;bitethe dog&#x27;</span>)    <span class="comment"># 有边界</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">r&#x27;\Bthe&#x27;</span>, <span class="string">&#x27;bitethe dog&#x27;</span>)    <span class="comment"># 没有边界</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;the&#x27;</span></span><br></pre></td></tr></table></figure>
<p>读者将注意到此处出现的原始字符串。你可能想要查看本章末尾部分的核心提示“Python中原始字符串的用法”（Using Python raw strings），里面提到了在此处使用它们的原因。通常情况下，在正则表达式中使用原始字符串是个好主意。</p>
<p>读者还应当注意其他4个re模块函数和正则表达式对象方法：findall()、sub()、subn()和split()。</p>
<h3 id="13-11-使用findall-和finditer-查找每一次出现的位置"><a href="#13-11-使用findall-和finditer-查找每一次出现的位置" class="headerlink" title="13.11 使用findall()和finditer()查找每一次出现的位置"></a>13.11 使用findall()和finditer()查找每一次出现的位置</h3><p>findall()查询字符串中某个正则表达式模式全部的非重复出现情况。这与search()在执行字符串搜索时类似，但与match()和search()的不同之处在于，findall()总是返回一个列表。如果findall()没有找到匹配的部分，就返回一个空列表，但如果匹配成功，列表将包含所有成功的匹配部分（从左向右按出现顺序排列）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;car&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;scary&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;car&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;carry the barcardi to the car&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;car&#x27;</span>,<span class="string">&#x27;car&#x27;</span>,<span class="string">&#x27;car&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>子组在一个更复杂的返回列表中搜索结果，而且这样做是有意义的，因为子组是允许从单个正则表达式中抽取特定模式的一种机制，例如匹配一个完整电话号码中的一部分（例如区号），或者完整电子邮件地址的一部分（例如登录名称）。</p>
<p>对于一个成功的匹配，每个子组匹配是由findall()返回的结果列表中的单一元素；对于多个成功的匹配，每个子组匹配是返回的一个元组中的单一元素，而且每个元组（每个元组都对应一个成功的匹配）是结果列表中的元素。这部分内容可能是第一次听起来令人迷惑，但是如果你尝试练习过一些不同的示例，就将澄清很多知识点。</p>
<p>finditer()函数是在Python2.2版本中添加回来的，这是一个与findall()函数类似但是更节省内存的变体。两者之间以及和共他变体函数之间的差异（很明显不同于返回的是一个迭代器还是列表）在于，和返回的区配字符串相比，finditer()在匹配对象中迭代。如下是在单个字符串中两个不同分组之间的差别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;This and that.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;(th\w+) and (th\w+)&#x27;</span>, s, re.I)</span><br><span class="line">[(<span class="string">&#x27;This&#x27;</span>, <span class="string">&#x27;that&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.finditer(<span class="string">r&#x27;(th\w+) and (th\w+)&#x27;</span>, s, re.I).<span class="built_in">next</span>().groups()</span><br><span class="line">(<span class="string">&#x27;This&#x27;</span>,<span class="string">&#x27;That&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.finditer(<span class="string">r&#x27;(th\w+) and (th\w+)&#x27;</span>, s, re.I).<span class="built_in">next</span>().group(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;This&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.finditer(<span class="string">r&#x27;(th\w+) and (th\w+)&#x27;</span>, s, re.I).<span class="built_in">next</span>().group(<span class="number">2</span>)</span><br><span class="line"><span class="string">&#x27;that&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[g.groups() <span class="keyword">for</span> g <span class="keyword">in</span> re.finditer(<span class="string">r&#x27;(th\w+) and (th\w+)&#x27;</span>, s, re.I)]</span><br><span class="line">[(<span class="string">&#x27;This&#x27;</span>, <span class="string">&#x27;that&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p>在下面的示例中，我们将在单个字符串中执行单个分组的多重匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; re.findall(r&#x27;(th\w+)&#x27;, s, re.I)</span><br><span class="line">[&#x27;This&#x27;, &#x27;that&#x27;]</span><br><span class="line">&gt;&gt;&gt; it = re.finditer(r&#x27;(th\w+)&#x27;, s, re.I)</span><br><span class="line">&gt;&gt;&gt; g = it.next()</span><br><span class="line">&gt;&gt;&gt; g.groups()</span><br><span class="line">(&#x27;This&#x27;,)</span><br><span class="line">&gt;&gt;&gt; g.group(1)</span><br><span class="line">&#x27;This&#x27;</span><br><span class="line">&gt;&gt;&gt; g = it.next()</span><br><span class="line">&gt;&gt;&gt; g.groups()</span><br><span class="line">(&#x27;that&#x27;,)</span><br><span class="line">&gt;&gt;&gt; g.group(1)</span><br><span class="line">&#x27;that&#x27;</span><br><span class="line">&gt;&gt;&gt; [g.group(1) for g in re.finditer(r&#x27;(th\w+)&#x27;, s, re.I)]</span><br><span class="line">[&#x27;This&#x27;, &#x27;that&#x27;]</span><br></pre></td></tr></table></figure>
<p>注意，使用finditer()函数完成的所有额外工作都旨在获取它的输出来匹配findall()的输出。最后，与match()和search()类似，findall()和finditer()方法的版本支持可选的pos和endpos参数，这两个参数用于控制目标字符串的搜索边界，这与本章之前的部分所描述的类似。</p>
<h3 id="1-3-12-使用sub-和subn-搜索与替换"><a href="#1-3-12-使用sub-和subn-搜索与替换" class="headerlink" title="1.3.12 使用sub()和subn()搜索与替换"></a>1.3.12 使用sub()和subn()搜索与替换</h3><p>有两个函数&#x2F;方法用于实现搜索和替换功能：sub()和subn()。两者几乎一样，都是将某字符串中所有匹配正则表达式的部分进行某种形式的替换。用来替换的部分通常是一个字符串，但它也可能是一个函数，该函数返回一个用来替换的字符串。subn()和sub()一样，但subn()还返回一个表示替换的总数，替换后的字符串和表示替换总数的数字一起作为一个拥有两个元素的元组返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Mr. Smith&#x27;</span>, <span class="string">&#x27;attn: X\n\nDear X,\n&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;attn: Mr. Smith\012\012Dear Mr. Smith,\012&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sbun(<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Mr. Smith&#x27;</span>, <span class="string">&#x27;attn: X\n\nDear X,\n&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;attn: Mr. Smith\012\012Dear Mr. Smith,\012&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> re.sub(<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Mr. Smith&#x27;</span>, <span class="string">&#x27;attn: X\n\nDear X,\n&#x27;</span>)</span><br><span class="line">attn: Mr. Smith</span><br><span class="line"></span><br><span class="line">Dear Mr. Smith</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">&#x27;[ae]&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;abcdef&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;XbcdXf&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.subn(<span class="string">&#x27;[ae]&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;abcdef&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;XbcdXf&#x27;</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>前面讲到，使用匹配对象的group()方法除了能够取出匹配分组编号外，还可以使用\N，其中N是在替换字符串中使用的分组编号。下面的代码仅仅只是将美式的日期表示法MM&#x2F;DD&#x2F;YY{,YY}格式转换为其他国家常用格式DD&#x2F;MM&#x2F;YY{,YY}。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r&#x27;(\d&#123;1,2&#125;)/(\d&#123;1,2&#125;)/(\d&#123;2&#125;|\d&#123;4&#125;)&#x27;</span>, <span class="string">r&#x27;\2/\1/\3&#x27;</span>, <span class="string">&#x27;2/20/91&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;20/2/91&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r&#x27;(\d&#123;1,2&#125;)/(\d&#123;1,2&#125;)/(\d&#123;2&#125;|\d&#123;4&#125;)&#x27;</span>, <span class="string">r&#x27;\2/\1/\3&#x27;</span>, <span class="string">&#x27;2/20/1991&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;20/2/1991&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-13-在限定模式上使用split-分隔字符串"><a href="#1-3-13-在限定模式上使用split-分隔字符串" class="headerlink" title="1.3.13 在限定模式上使用split()分隔字符串"></a>1.3.13 在限定模式上使用split()分隔字符串</h3><p>re模块和正则表达式的对象方法split()对于相对应字符串的工作方式是类似的，但是与分割一个固定的字符串相比，它们基于正则表达式的模式分隔字符串，为字符串分隔功能添加一些额外的威力。如果你不想为每次模式的出现都分割字符串，就可以通过为max参数设定一个值（非零）来指定最大分割数。</p>
<p>如果给定分割符不是使用特殊符号来匹配多重模式的正则表达式，那么re.split()与str.split()的工作方式相同，如下所示（基于单引号分割）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;str1:str2:str3&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;str1&#x27;</span>, <span class="string">&#x27;str2&#x27;</span>, <span class="string">&#x27;str3&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>这是一个简单的示例。如果有一个更复杂的示例，例如，一个用于Web站点（类似于Google或者Yahho!Maps）的简单解析器，该如何实现？用户需要输入城市和州名，或者城市名加上ZIP编码，还是三者同时输入？这就需要比仅仅是普通字符串分割更强大的处理方式，具体如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DATA = (</span><br><span class="line"><span class="meta">... </span>     <span class="string">&#x27;Mountain View, CA 94040&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>     <span class="string">&#x27;Sunnyvale, CA&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>     <span class="string">&#x27;Los Altos, 94023&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>     <span class="string">&#x27;Cupertino 95014&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>     <span class="string">&#x27;Palo Alto CA&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> datum <span class="keyword">in</span> DATA:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>     <span class="built_in">print</span> re.split(<span class="string">&#x27;, |(?=(?:\d&#123;5&#125;|[A-Z]&#123;2&#125;))&#x27;</span>, datum)</span><br><span class="line">...</span><br><span class="line">[<span class="string">&#x27;Mountain View&#x27;</span>, <span class="string">&#x27;CA&#x27;</span>, <span class="string">&#x27;94040&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Sunnyvale&#x27;</span>, <span class="string">&#x27;CA&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Los Altos&#x27;</span>, <span class="string">&#x27;94023&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Cupertino&#x27;</span>, <span class="string">&#x27;95014&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Palo Alto&#x27;</span>, <span class="string">&#x27;CA&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>上述正则表达式拥有一个简单的组件：使用split语句基于逗号分割字符串。更难的部分是最后的正则表达式，可以通过该正则表达式预览一些将在下一小节中介绍的扩展符号。在普通的英文中，通常这样说：如果空格紧跟在五个数字（ZIP编码）或者两个大写字母（美国联邦缩写）之后，就用split语句分割该空格。这就允许我们在城市名中放置空格。</p>
<p>通常情况下，这仅仅只是一个简单的正则表达式，可以在用来解析位置信息的应用中作为起点。该正则表达式并不能处理小写的州名或者州名的的全拼、街道地址、州编码、ZIP＋4（9位ZIP编码）、经纬度、多个空格等内容（或者在处理时会失败）。这仅仅意味着使用re.split()能够实现str.split()不能实现的一个简单的演示实例。</p>
<p>我们刚刚已经证实，读者将从正则表达式split语句的强大能力中获益；然而，记得一定在编码过程中选择更合适的工具。如果对字符串使用split方法已经足够好，就不需要引入额外复杂并且影响性能的正则表达式。</p>
<h3 id="1-3-14-扩展符号"><a href="#1-3-14-扩展符号" class="headerlink" title="1.3.14 扩展符号"></a>1.3.14 扩展符号</h3><p>Python的正则表达式支持大量的扩展符号。让我们一起查看它们中的一些内容，然后展示一些有用的示例。</p>
<p>通过使用（?iLmsux）系列选项，用户可以直接在正则表达式里面指定一个或者多个标记，而不是通过compile()或者其他re模块函数。下面为一些使用re.I&#x2F;IGNORECASE的标例，最后一个示例在re.M&#x2F;MULTILINE实现多行混合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;(?!)yes&#x27;</span>, <span class="string">&#x27;yes? Yes. YES!!&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;yes&#x27;</span>, <span class="string">&#x27;Yes&#x27;</span>, <span class="string">&#x27;YES&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;(?!)th\w+&#x27;</span>, <span class="string">&#x27;The quickest way is through this tunnel.&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;The&#x27;</span>, <span class="string">&#x27;through&#x27;</span>, <span class="string">&#x27;this&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;(?im)(^th[\w ]+)&#x27;</span>,<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>This line is the firest,</span></span><br><span class="line"><span class="string"><span class="meta">... </span>another line,</span></span><br><span class="line"><span class="string"><span class="meta">... </span>that line, it&#x27;s the best</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>&quot;&quot;&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;This line is the first&#x27;</span>, <span class="string">&#x27;that line&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>在前两个示例中，显然是不区分大小写的。在最后一个示例中，通过使用“多行”，能够在目标字符串中实现跨行搜索，而不必将整个字符串视为单个实体。注意，此时忽咯了实例‘the’，因为它们并不出现在稳中有降自的行首。</p>
<p>下一组演示使用re.S&#x2F;DOTALL。该标记表明点号（.）能够用来表示\n符号（反之其通常用于表示除了\n之外的全部字符）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;th.+&#x27;</span>, <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>The firest line</span></span><br><span class="line"><span class="string"><span class="meta">... </span>the second line</span></span><br><span class="line"><span class="string"><span class="meta">... </span>the third line</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&#x27;&#x27;&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;the second line&#x27;</span>, <span class="string">&#x27;the third line&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;(?s)th.+&#x27;</span>,<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>The first line</span></span><br><span class="line"><span class="string"><span class="meta">... </span>the second line</span></span><br><span class="line"><span class="string"><span class="meta">... </span>the third line</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&#x27;&#x27;&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;the second line\nthe third line\n&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>re.X&#x2F;VERBOSE标记非常有趣；该标记允许用户通过抑制在正则表达式中使用空白符（除了在字符类中或者在反斜线转义中）来创建更易读的正则表达式。此外，散列、注释和井号也可以用一个注释的起始，只要它们不在一个用反斜线转义的字符类中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">r&#x27;&#x27;&#x27;(?x)</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    \((\d&#123;3&#125;)\)    # 区号</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    [  ]           # 空白符</span></span><br><span class="line"><span class="string">...　　　(\d&#123;3&#125;)        # 前缀</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    -              # 横线</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    (\d&#123;4&#125;)        # 终点数字</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&#x27;&#x27;&#x27;</span>, <span class="string">&#x27;(800) 555-1212&#x27;</span>).groups()</span><br><span class="line">(<span class="string">&#x27;800&#x27;</span>,<span class="string">&#x27;555&#x27;</span>,<span class="string">&#x27;1212&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>(?:…)符号将更流行：通过使用该符号，可以对部分正则表达式进行分组，但是并不会保存该分组用于后续的检索或者应用。当不想保存令后永远不会使用的多余匹配时，这个符号就非常有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;http://(?:\w+\.)*(\w+\.com)&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&#x27;http://google.com http://www.google.com http://code.google.com&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;google.com&#x27;</span>, <span class="string">&#x27;google.com&#x27;</span>, <span class="string">&#x27;google.com&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">r&#x27;\((?P&lt;areacode&gt;\d&#123;3&#125;)\) (?P&lt;prefix&gt;\d&#123;3&#125;)-(?:\d&#123;4&#125;)&#x27;</span>,<span class="string">&#x27;(800)555-1212&#x27;</span>).groupdict()</span><br><span class="line">&#123;<span class="string">&#x27;areacode&#x27;</span>:<span class="string">&#x27;800&#x27;</span>,<span class="string">&#x27;prefix&#x27;</span>:<span class="string">&#x27;555&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>读者可以同时一起使用(?P<name>)和(?P&#x3D;name)符号。前者通过使用一个名称标识符而不是使用从1开始增加到N的增量数字来保存匹配，如果使用数字来保存匹配结果，我们就可以通过使用<code>\1,\2...,\N\</code>来检索。如下所示，可以使用一个类似风格的<code>\g&lt;name&gt;</code>来检索它们。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r&#x27;\((?P&lt;areacode&gt;\d&#123;3&#125;)\) (?P&lt;prefix&gt;\d&#123;3&#125;)-(?:\d&#123;4&#125;)&#x27;</span>,<span class="string">&#x27;(\g&lt;areacode&gt;) \g&lt;prefix&gt;=xxx&#x27;</span>, <span class="string">&#x27;(8000)555-1212&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;(800) 555-xxxx&#x27;</span></span><br></pre></td></tr></table></figure>
<p>使用后者，可以在一个相同的正则表达式中重用模式，而不必稍后再次在（相同）正则表达式中指定相同的模式。例如，在本示例中，假定让读者验证一些电话号码的规范化。如下所示为一个丑陋并且压缩的版本，后面跟着一个正确使用的(?x)，使代码变得稍许易读。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(re.<span class="keyword">match</span>(<span class="string">r&#x27;\((?P&lt;areacode&gt;\d&#123;3&#125;)\) (?P&lt;prefix&gt;\d&#123;3&#125;)-(?P&lt;number&gt;\d&#123;4&#125;) (?P=areacode)-(?P=prefix)-(?P=number) 1(?P=areacode)(?P=prefix)(?P=number)&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;(800) 555-1212 800-555-1212 18005551212&#x27;</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(re.<span class="keyword">match</span>(<span class="string">r&#x27;&#x27;&#x27;(?x)</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    #match (800)555-1212, save areacode, prefix, no.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    \((?P&lt;areacode&gt;\d&#123;3&#125;)\)[](?P&lt;prefix&gt;\d&#123;3&#125;)-(?P&lt;number&gt;\d&#123;4&#125;)</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    # space</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    [　]</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    # match 800-555-1212</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    (?P=areacode)-(?P=prefix)-(?P=number)</span></span><br><span class="line"><span class="string"><span class="meta">... </span></span></span><br><span class="line"><span class="string"><span class="meta">... </span>    # space</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    [ ]</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    # match 18005551212</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    1(?P=areacode)(?P=prefix)(?P=number)</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&#x27;&#x27;&#x27;</span>, <span class="string">&#x27;(800) 555-1212 800-555-1212 18005551212&#x27;</span>)) </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>读者可以使用(?&#x3D;…)和(?!…)符号在目标字符串中实现一个前视匹配，而不必实际上使用这些字符串。前者是正向前视断言，后者是负向前视断言。在后面的示例中，我们仅仅对姓氏为“van Rossum”的人的名字感兴趣，下一个示例中，让我们忽略以“noreply”或者“postmaster”开头的e－mail地址。</p>
<p>第三个代码片段用于演示findall()和finditer()区别；我们使用后者来构建一个使用相同登录名但不同域名的e－mail地址列表（在一个更易于记忆的方法中，通过忽略创建用完即丢弃的中间列表）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;\w+(?= van Rossum)&#x27;</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     Guido van Rossum</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     Tim Peters</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     Alex Martelli</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     Just van Rossum</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     Raymond Hettinger</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&#x27;&#x27;&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;Guido&#x27;</span>, <span class="string">&#x27;Just&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;(?m)^\s+(?!noreply|postmaster)(\w+)&#x27;</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     sales@phptr.com</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     postmaster@phptr.com</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     eng@phptr.com</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     noreply@phptr.com</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     admin@phptr.com</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&#x27;&#x27;&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;sales&#x27;</span>, <span class="string">&#x27;eng&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;%s@aw.com&#x27;</span> % e.group(<span class="number">1</span>) <span class="keyword">for</span> e <span class="keyword">in</span> \ </span><br><span class="line"><span class="meta">... </span>re.finditer(<span class="string">r&#x27;(?m)^\s+(?!noreply|postmaster)(\w+)&#x27;</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     sales@phptr.com</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     postmaster@phptr.com</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     eng@phptr.com</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     noreply@phptr.com</span></span><br><span class="line"><span class="string"><span class="meta">... </span>     admin@phptr.com</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&#x27;&#x27;&#x27;</span>)]</span><br><span class="line">[<span class="string">&#x27;sales@aw.com&#x27;</span>, <span class="string">&#x27;eng@aw.com&#x27;</span>, <span class="string">&#x27;admin@aw.com&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>最后一个示例展示了使用条件正则表达式匹配。假定我们拥有另一个特殊字符，它仅令包含字母“x”和“y”，我们此时仅仅想要这样限定字符串：两字母的字符串必须由一个字母跟着另一个字母。换句话说，你不能同时拥有两个相同的字母：要么由“x”跟着“y”，要么相反。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(re.search(<span class="string">r&#x27;(?:(x)|y)(?(1)y|x)&#x27;</span>,<span class="string">&#x27;xy&#x27;</span>))</span><br><span class="line"><span class="literal">True</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(re.search(<span class="string">r&#x27;(?:(x)|y)(?(1)y|x)&#x27;</span>,<span class="string">&#x27;xx&#x27;</span>))</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-15-杂项"><a href="#1-3-15-杂项" class="headerlink" title="1.3.15 杂项"></a>1.3.15 杂项</h3><p>可能读者会对于正则表达式的特殊字符和特殊ASCII符号之间的差异感到迷惑。我们可以使用\n表示一个换行符，但是我们可以使用\d在正则表达式中表示匹配单个数字。</p>
<p>如果有符号同时用于ASCII和正则表达式，就会发生问题，因此在下面的核心提示中，建议使用Python的原始字符中来避免产生问题。另一个警告是：\w和\W字母数字字符集同时受re.L&#x2F;LOCALE和Unicode(re.U&#x2F;UNICODE)标记所影响。</p>
<div class="note primary"><p><span style="font-size: 14pt;font-weight: bolder;">核心提示：使用Python原始字符串</span><br><br>读者可能在之前的一些示例中见过原始字符串的使用。正则表达式对于探索原始字符串有着强大的动力，原因就在于ASCII字符和正则表达斯式的特殊字符之间存在冲突。作为一个特殊符号，\b表示ASCII字符的退格符，但是\b同时也是一个正则表达式的特殊符号，表示匹配一个单词的边界。对于正则表达式编译器而言，若它把两个\b视为字符串内容而不是单个退格符，就需要在字符串中再使用一个反斜线转义反斜线，就像这样：\b。</p>
<p>这閪显得略微杂乱，特别是如果在字符串中拥有很多特殊字符，就会让人感到更加困惑。我们在Core Python Programming或者Core Python Language Fudamentals的Sequence章节中介绍了原始字符串，而且该原始字符串可以用于（且经常用于）帮助保持正则表达式查找某些可托管的东西。事实上，很多Python程序员总是抱怨这个方法，仅仅用原如字符串来定义正则表达式。</p>
<p>所下所示的一个示例用于说明退格符\b和正则表达式\b之间的差异，它们有的使用、有的不使用原始字符串。</p>
<p>m &#x3D; re.match(‘\bblow’, ‘blow’)  # backspace、　no match<br>if m: m.group()</p>
<p>m &#x3D; re.match(‘\bblow’, ‘blow’) # escaped, now it works<br>if m:  m.group()</p>
<p>‘blow’</p>
<p>m &#x3D; re.match(r’\bblow’, ‘blow’)  # use raw string instead<br>if m: m.group()</p>
<p>‘blow’</p>
<p>读者可能回想起来我们在正则表达式中使用\d而没有使用原始字符串时并未遇到问题，这是因为ASCII中没有相应的特殊字符，所以正则表达式的编译器知道你想要表示十进制数字。</p>
</div>

<h2 id="1-4-一些正则表达式示例"><a href="#1-4-一些正则表达式示例" class="headerlink" title="1.4 一些正则表达式示例"></a>1.4 一些正则表达式示例</h2><p>下面看一些Python正则表达式的示例代码，这将使我们更接近实际应用中的程序。所下所示，以POSIX（UNIX风格操作系统，如Linux、Mac OS X等）的who命令的输出为例，该命令将列出所有登录当前系统中的用户信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">who</span></span><br><span class="line">wesley      console     Jun 20  20:33</span><br><span class="line">wesley      pts/9       Jun 22  01:38   (192.168.0.6)</span><br><span class="line">wesley      pts/1       Jun 20  20:33   (:0.0)</span><br><span class="line">wesley      pts/2       Jun 20  20:33   (:0.0)</span><br><span class="line">wesley      pts/2       Jun 20  20:33   (:0.0)</span><br><span class="line">wesley      pts/2       Jun 20  20:33   (:0.0)</span><br><span class="line">wesley      pts/2       Jun 20  20:33   (:0.0)</span><br><span class="line">wesley      pts/2       Jun 20  20:33   (:0.0)</span><br><span class="line">wesley      pts/2       Jun 20  20:33   (:0.0)</span><br><span class="line">wesley      pts/2       Jun 20  20:33   (:0.0)</span><br></pre></td></tr></table></figure>
<p>可能我们想要保存一些用户登录信息，诸如登录名、用户登录的终端类型、用户登录的时间和地点。在前面的示例中使用str.split()方法并不高效，因为此处的空白符既不稳定也不一致。另一个问题是在登录时间戳中间的月、日和时间之间有空格，我们可能想要保存这些连续的字段。</p>
<p>读者需要一些方法描述诸如“分割两个或者多个空白符”之类的模式。这通过正则表达式很容易完成。很快，我们可以使用正则表达式模式\s\s+，该模式的意思是至少拥有两个以上的空白符。</p>
<p>下面创建一个名为rewho.py的程序，该程序读取who命令的输出，然后假定将得到的输出信息存入一个名为whoadat.txt的文件之中。rewho.py脚本最初如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;whodata.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> eachline <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span> re.split(<span class="string">r&#x27;\s\s+&#x27;</span>, eachline)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>上述代码同样使用原始字符串（将字母“r”或者“R”放置在左引号之前），主要目的是为了避免转义特殊字符串字符，如\n，该字符并不是特殊的正则表达式模式。对于确实拥有反斜线的正则表达式模式，读者可能希望逐字地处理它们：否则，读者必须在前面加上双斜线来保持它们的安全。</p>
<p>现在将执行who命令，保存输出到whodata.txt文件之中，然后调用rewho.py查看结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ who &gt; whodata.txt</span><br><span class="line">$ rewho.py </span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;console&#x27;</span>, <span class="string">&#x27;Jun 20  20:33\012&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;pts/9&#x27;</span>, <span class="string">&#x27;Jun 22  01:38\011(192.168.0.6)\012&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;pts/1&#x27;</span>, <span class="string">&#x27;Jun 20  20:33\011(:0.0)\012&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;pts/2&#x27;</span>, <span class="string">&#x27;Jun 20  20:33\011(:0.0)\012&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;pts/2&#x27;</span>, <span class="string">&#x27;Jun 20  20:33\011(:0.0)\012&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;pts/2&#x27;</span>, <span class="string">&#x27;Jun 20  20:33\011(:0.0)\012&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;pts/2&#x27;</span>, <span class="string">&#x27;Jun 20  20:33\011(:0.0)\012&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;pts/2&#x27;</span>, <span class="string">&#x27;Jun 20  20:33\011(:0.0)\012&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;pts/2&#x27;</span>, <span class="string">&#x27;Jun 20  20:33\011(:0.0)\012&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;pts/2&#x27;</span>, <span class="string">&#x27;Jun 20  20:33\011(:0.0)\012&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>这是非常好的一次尝试。首先，我们不期望单个制表符（ASCII\011）作为输出的一部分（可能看起来像是至少两个空白符），然后可能我们并不真的希望保存\n（ASCII\012）作为每一行的终止符。我们现在将修复这些问题，然后通过一些改进来提高应用的整体质量。</p>
<p>首先，应当在脚本内部运行who命令而不是在外部，然后将输出存入whodata.txt文件，如果手动重复做这件事很快就会感到厌倦。要在该程序中调用其他程序，需要调用os.popen()命令。尽管os.popen()命令现在已经被subprocess模块所替换，但它更容易使用，而且此处的重点是展示re.split()的功能。</p>
<p>去除尾部的\n（使用str.rstrip()），然后添加单个制表符的检查，用于代替re.split()分隔符。示例1－1展示最终的rewho.py脚本在Python 2中的版本。<br><br><span style="font-size: 14pt;font-weight: bolder;background-color: grey;">示例1－1　分割POSIX的who命令输出（rewho.py）</span><br><span style="font-size: 11pt;">该脚本调用who命令，然后通过不同类型的空白字符分割输入的数据解析输入。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">f = os.popen(<span class="string">&#x27;who&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> eachLine <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span> re.split(<span class="string">r&#x27;\s\s+|\t&#x27;</span>, eachLine.rstrip())</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>示例1－2表示rewho3.py，这是Python3版本。和Python2版本的主要差别在于print()函数（或者表达式）。这一整行表明了Python2与3的关键区别。with语句在Python2.5版本中是试验性的，在Python2.6版本中提供了正式支持，该语句用于操作并支持所构建的对象事例。<br><br><span style="font-size: 14pt;font-weight: bolder;background-color: grey;">示例1－2　rewho.py脚本的Python 3版本（rewho3.py）</span><br><span style="font-size: 11pt;">该rewho.py的Python 3版本仅简单地运用print()函数替换了print语句。当使用with语句（从Python2.5版本起可用）时，记住，file（Python2）或者io（Python3）对象的上下文管理器会自动调用f.close()。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> os.popen(<span class="string">&#x27;who&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> eachLine <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(re.split(<span class="string">r&#x27;\s\s+|\t&#x27;</span>, eachLine.strip()))</span><br></pre></td></tr></table></figure>
<p>通过使用with语句，拥有上下文管理器的对象变得更易于使用。关于with语句和上下文管理器的更多信息，请参考Core Python Pragramming或者Core　Python　Language　Fundamentals中的“Errors and Exceptions”章节。记住，两个版本（rewho.py或者rewho3.py）中的who命令仅能在POSIX系统中使用，除非可以在Windows系统的计算机中使用Cygwin。对于运行Microsoft Windows的个人电脑，可以尝试tasklist命令，但读者还需要做一个额外的调整。继续阅读本章后续的章节，查看一个执行that命令的示例。</p>
<p>示例1－3将rewho.py和rewho3.py合并为rewhoU.py，该名称的含义是“通用的rewho”。该程序能够在Python2和3的解释器下运行。我们欺骗并避免使用print或者print()，方法是使用一个在2.X和3.X版本中都存在并且功能并不齐全的函数：distutils.log.warn()。这是一个单字符串输出函数，因此如果输出要复杂一些，就需要合并所有输出到一个字符串中，然后调用。要在该脚本中指明它的使用方式，就将它命名为print()。</p>
<p>我们也在些使用with语句。这就意味着读者需要至少使用Python2.6版本来运行该程序。这还不确切。这前提到过，在2.5版本中with语句是试验性的。这就意味着如果想要在Python2.5中使用，就需要导入额外的语句：from <strong>future</strong> import with_statement。如果读者仍在使用2.4或者更老的版本，就不能使用这个import语句，并且必须按照示例1－1那样运行这段代码。<br><br><span style="font-size: 14pt;font-weight: bolder;background-color: grey;">示例1－3　rewho.py脚本的通用版本（rewhoU.py）</span><br><span style="font-size: 11pt;">该脚本运行在Python2和3下，通过一个很简单的替换来代替print语句和print()函数。该脚本还包含从Python2.5开始引入的with语句。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> distutils.log <span class="keyword">import</span> warn <span class="keyword">as</span> printf </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">whit os.popen(<span class="string">&#x27;who&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f：</span><br><span class="line">    <span class="keyword">for</span> eachLine <span class="keyword">in</span> f:</span><br><span class="line">        printf(re.split(<span class="string">r&#x27;\s\s+|\t&#x27;</span>,eachLine.strip()))</span><br></pre></td></tr></table></figure>
<p>rewhoU.py的创建是一个介绍如何创建通用脚本的示例，这将帮助我们避免为Python2和3同时维护两个版本的相同脚本。</p>
<p>使用合适的解释器执行这些脚本中的任何一个都会得到正确、简洁的输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ rewho.py</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;console&#x27;</span>, <span class="string">&#x27;Feb 22 14:12&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;ttys000&#x27;</span>, <span class="string">&#x27;Feb 22 14:18&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;ttys001&#x27;</span>, <span class="string">&#x27;Feb 22 14:49&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;ttys002&#x27;</span>, <span class="string">&#x27;Feb 25 00:13&#x27;</span>, <span class="string">&#x27;(192.168.0.20)&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;wesley&#x27;</span>, <span class="string">&#x27;ttys003&#x27;</span>, <span class="string">&#x27;Feb 24 23:49&#x27;</span>, <span class="string">&#x27;(192.168.0.20)&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>同样不要忘记，之前的小节介绍过re.split()函数也可以使用可选的flage参数。</p>
<p>在Windows计算机上可以使用tasklist命令替代who来得到类似的结果。让我们查看该命令的输出结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;tasklist</span><br><span class="line"></span><br><span class="line">Image Name                   PID Session Name        Session#    Mem Usage</span><br><span class="line">========================= ====== =================== ======== ============</span><br><span class="line">System Idle Process            0 Console                    0          28K</span><br><span class="line">System                         4 Console                    0         240K</span><br><span class="line">smss.exe                     708 Console                    0         420K</span><br><span class="line">csrss.exe                    764 Console                    0        4876K</span><br><span class="line">winlogon.exe                 788 Console                    0        3268K</span><br><span class="line">services.exe                 836 Console                    0        3932K</span><br></pre></td></tr></table></figure>
<p>可以看到，输出包含不同于who命令的输出信息，但格式是类似的，所以可以考虑之前的方案：在一个或多个空白符上执行re.split()（此处没有制表符的问题）。</p>
<p>问题是命令名称可能有一个空白符，而且我们（应当）更倾向于将整个命令名称连接在一起。对于内存的使用也有这个问题，我们通常得到的是“NNN　K”，其中NNN是内存数量大小，K表示千字节。我们也希望将这些数据连接在一起，因此，最好分隔至少一个空白符，对吧？</p>
<p>不，不能这样做。注意，进程ID（PID）和会话名称列仅仅由一个空白符分隔。这就意味着如果去掉至少一个空白符，PID和会话名称将被合并在一起作为单个结果。如果复制之前的一个脚本，重命名它为retasklist.py，然后将who命令修改为tasklist&#x2F;nh(&#x2F;nh选项将公去除每一列的标题)，并使用一个\s\s+正则表达式，就将得到如下所示的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Z:\corepython\ch1&gt;python retasklist.py</span><br><span class="line">[&#x27;&#x27;]</span><br><span class="line">[&#x27;System Idle Process&#x27;, &#x27;0 Console&#x27;, &#x27;0&#x27;, &#x27;28 K&#x27;]</span><br><span class="line">[&#x27;System&#x27;, &#x27;4 Console&#x27;, &#x27;0&#x27;, &#x27;240 K&#x27;]</span><br><span class="line">[&#x27;smss.exe&#x27;, &#x27;708 Console&#x27;, &#x27;0&#x27;, &#x27;420 K&#x27;]</span><br><span class="line">[&#x27;csrss.exe&#x27;, &#x27;764 Console&#x27;, &#x27;0&#x27;, &#x27;5028 K&#x27;]</span><br><span class="line">[&#x27;winlogon.exe&#x27;, &#x27;788 Console&#x27;, &#x27;0&#x27;, &#x27;3284 K&#x27;]</span><br><span class="line">[&#x27;services.exe&#x27;, &#x27;836 Console&#x27;, &#x27;0&#x27;, &#x27;3924 K&#x27;]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>已经确认，尽管我们将命令名称和内存使用字符串保存在一起，但也不经意地将PID和会话名称放在一起。因此我们不得不放弃使用split函数，而且通过正则表达式匹配实现，我们可以这样实现，然后滤除会话名称和编号，因为两者都会为输出添加数值。示例1－4显示Python2版本下retasklist.py的最终版本。<br><br><span style="font-size: 14pt;font-weight: bolder;background-color: grey;">示例1－4　处理DOS环境下tasklist命令的输出（retasklist.py）</span><br><span style="font-size: 11pt;">这里的脚本使用一个正则表达式和findall()来解析DOS环境下tasklist命令的输出，但是仅仅显示感兴趣的数据。将该脚本移植到Python3时，仅仅需要修改print()函数。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">f = os.popen(<span class="string">&#x27;tasklist /nh&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> eachLine <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span> re.findall(</span><br><span class="line">        <span class="string">r&#x27;([\w.]+(?:[\w.]+)*)\s\s+(\d+)\w+\s\s+\d+\s\s+([\d,]+K)&#x27;</span>,</span><br><span class="line">        eachLine.rstrip())</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>如果运行这个脚本，就能得到期望（已截断）的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Z:\corepython\ch1&gt;python retasklist.py</span><br><span class="line">[]</span><br><span class="line">[(&#x27;System Idle Process&#x27;, &#x27;0&#x27;, &#x27;28 K&#x27;)]</span><br><span class="line">[(&#x27;System&#x27;, &#x27;4&#x27;, &#x27;240 K&#x27;)]</span><br><span class="line">[(&#x27;smss.exe&#x27;, &#x27;708&#x27;, &#x27;420 K&#x27;)]</span><br><span class="line">[(&#x27;csrss.exe&#x27;, &#x27;764&#x27;, &#x27;5,016 K&#x27;)]</span><br><span class="line">[(&#x27;winlogon.exe&#x27;, &#x27;788&#x27;, &#x27;3,284 K&#x27;)]</span><br><span class="line">[(&#x27;services.exe&#x27;, &#x27;836&#x27;, &#x27;3,932 K&#x27;)]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>细致的正则表达式将会扫描全部的5列输出字符串，仅对重要的数据进行分组：命令名称、命令相应的PID，以及该命令使用的内存大小。该脚本使用已经在本章中介绍过的正则表达式的很多特性。</p>
<p>显然，在本小节中实现的全部脚本只向用户显示输出。实际上，我们有可能在处理数据，并将数据保存入数据库，使用得到的输出来为管理层生成报表等。</p>
<h2 id="1-5-更长的正则表达式示例"><a href="#1-5-更长的正则表达式示例" class="headerlink" title="1.5 更长的正则表达式示例"></a>1.5 更长的正则表达式示例</h2><p>我们现在将浏览一个深入的示例，它以不同的方式使用正则表达式来操作字符串。首先是一些实际上生成用于操作的随机数（查不是太随机）的代码。示例1－5展示了gendata.py，这是一个生成数据集的脚本。尽管该程序只是将简单地将生成的字符串集显示到标准输出，但是该输出可以很容易重定向到测试文件。<br><br><span style="font-size: 14pt;font-weight: bolder;background-color: grey;">示例1－5　用于正则表达式练习的数据生成器（gendata.py）</span><br><span style="font-size: 11pt;">该脚本为正则表达式练习创建随机数据，然后将生成的数据输出到屏幕。要将该程序移值到Python3，仅需要将print语句修改为函数，将xrange()函数修改为range()，以及将sys.maxint修改为sys.massize。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange, choice</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> ascii_lowercase <span class="keyword">as</span> lc </span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> maxint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line">tlds = (<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;edu&#x27;</span>, <span class="string">&#x27;net&#x27;</span>, <span class="string">&#x27;org&#x27;</span>, <span class="string">&#x27;gov&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(randrange(<span class="number">5</span>, <span class="number">11</span>)):</span><br><span class="line">    dtint = randrange(maxint)        <span class="comment"># pick date</span></span><br><span class="line">    dtstr = ctime(dtint)             <span class="comment"># date string</span></span><br><span class="line">    llen = randrange(<span class="number">4</span>, <span class="number">8</span>)           <span class="comment"># login is shorter</span></span><br><span class="line">    login = <span class="string">&#x27;&#x27;</span>.join(choice(lc) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(llen))</span><br><span class="line">    dlen = randrange(llen, <span class="number">13</span>)       <span class="comment"># domain is longer</span></span><br><span class="line">    dom = <span class="string">&#x27;&#x27;</span>.join(choice(lc) <span class="keyword">for</span> j <span class="keyword">in</span> xrange(dlen))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;%s::%s@%s.%s::%d-%d-%d&#x27;</span> % (dtstr, login, dom, choice(tlds), dtint, llen, dlen) </span><br></pre></td></tr></table></figure>
<p>该脚本生成拥有三个字段的字符串，由一对冒号或者一对双冒号分隔。第一个字段是随机（32位）整数，该整数将被转换为一个日期。下一个字段是一个随机生成的电子邮件地址。最后一个字段是一个由单横线（－）分隔的整数集。</p>
<p>运行这段代码，我们将获得以下输出（读者将会从此获益颇多），并将该输出在本地另存为redata.txt文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thu Jul 22 19:21:19 2004::izsp@dicqdhytvhv.edu::1090549279-4-11</span><br><span class="line">Sun Jul 13 22:42:11 2008::zqsu@dxaibjgkniy.com::1216014131-4-11</span><br><span class="line">Sat May  5 16:36:23 1990::fclihw@qlwdbzpsdg.edu::641950583-6-10</span><br><span class="line">Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8</span><br><span class="line">Thu Jun 26 19:08:59 2036::ugxfugt@jkhuqhs.net::2098145339-7-7</span><br><span class="line">Tue Apr 10 10:04:45 2012::zkwaq@rpxwmtikse.com::1334045085-5-10 </span><br></pre></td></tr></table></figure>
<p>读者或者可能会辨别出来，但是来自该程序的输出是为正则表达式处理做准备的。后续将逐行解释，我们将实现一些正则表达式来操作这些数据，以及为本章末尾的练习留下很多内容。</p>
<p><span style="font-size: 14pt; font-weight: bolder;">逐行解释</span></p>
<p>第1~6行</p>
<p>在示例脚本中，需要使用多个模块。由于多种原因，尽管我们小心翼翼地避免使用from-import语句（例如，很容易判断一个函数来自哪个模块，以及可能导致本地模块冲突等），我们还是选择从这些模块中仅导入特定的属性，来帮助读者仅专注于那些属性，以及缩短每行代码的长度。</p>
<p>第8行</p>
<p>tlds是一组高级域名集合，当需要随机生成电子邮件地址时，就可以从中随机选出一个。</p>
<p>第10~12行</p>
<p>每次执行gendata.py，就会生成第5行和第10行之间的输出（该脚本对于所有需要随机整数的场景都使用random.randrange()函数）。对于每一行，我们选取所有可能范围（0~$2^{31-1}$[sys.maxint]）中的随机整数。然后使用time.ctime()函数将该整数转换为日期。Python中的系统时间和大多数基于POSIX的计算机一样，两者都使用从“epoch”至今的秒数，epoch是指1979年1月1日的格林威治时间的午夜。如果我们选择一个32位整数，那么该整数将表示从epoch到最大可能时间（即epoch后的$2^{32}$秒）之间的某个时刻。</p>
<p>第13～16行</p>
<p>伪造邮件地址的登录名长度为4～7个字符（因此使用randrange(4, 8)）。为了将它们放在一起，需要随机选择4～7个小写字母，将所有字母逐个连接成一个字符串。random.choice()函数的功能就是接受一个序列，然后返回该序列中的一个随机元素。在该示例中，string.ascii_lowercase是字母表中拥有26个小写字母的序列集合。</p>
<p>我们决定伪造电子邮件地址的主域名长度不能多于12个字符，但是至少和登录名一样长。再一次使用随机的小写字母，逐个字母来组合这个名字。</p>
<p>第17～18行</p>
<p>该脚本的关键部分就是将所有随机数据放入输出行。先是数据字符串，然后是分隔符。然后将所有电子邮件地址通过登录名、“@”符号、域名和一个随机选择的高级域名组合在一起。在最终的双冒号之后，我们将使用用于表示初始时间的随机数字符串（日期字符串），后面跟着登录名和域名的长度，所有这些都由一个连字符分隔。</p>
<h3 id="1-5-1-匹配字符串"><a href="#1-5-1-匹配字符串" class="headerlink" title="1.5.1　匹配字符串"></a>1.5.1　匹配字符串</h3><p>对于后续的练习，为正则表达式创建宽松的约束性的版本。建议读者在一个简短的应用中测试这些正则表达式，该应用利用之前所展示的示例文件redata.txt(或者使用通过运行gendata.py生成的数据)。当做练习时，读者将需要再次使用该数据。</p>
<p>在将正则表达式放入应用中之前，为了测试正则表达式，我们将导入re模块，然后将redata.txt中的一个示例行赋给字符串变量data。如下所示，这些语句在所有展示的示例中都是常量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = <span class="string">&#x27;Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在第一个示例中，我们将创建一个正则表达式来提取（仅仅）数据文件redata.txt中每一行时间戳中一周的几天。我们将使用下面的正则表达式。<br><code>&quot;^Mon|^Tue|^Web|^Thu|^Fri|^Sat|^Sun&quot;</code><br>该示例需要字符串以列出的7个字符串中的任意一个开头（“^”正则表达式中的脱字符）。如果我们将该正则表达式“翻译”成自然语言，读起来就会像这样：“字符串应当以Mon或者Tue或者Web或者Thua…或者Sun开头”。</p>
<p>换句话说，如果按照如下所示的方式对日期字符串分组，我们就可以使用一个脱字符来替换所有脱字符。<br><code>^(Mon|Tue|Wed|Thu|fri|Sat|sun)</code><br>括住字符串集的圆括号的意思是：这些字符串中的一个将会有一次成功匹配。这是我们一开始就使用的“友好的”正则表达式版本，该版本并没有使用圆括号。如下所示，在这个修改过的正则表达式版本中，可以以子组的方式来访问匹配字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patt = <span class="string">&#x27;^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(patt, data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group()        <span class="comment"># entire match</span></span><br><span class="line"><span class="string">&#x27;Thu&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)       <span class="comment"># subgroup 1</span></span><br><span class="line"><span class="string">&#x27;Thu&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()       <span class="comment"># all subgroups</span></span><br><span class="line">(<span class="string">&#x27;Thu&#x27;</span>,)</span><br></pre></td></tr></table></figure>
<p>我们在该示例所实现的这个特性可能看起来并不是革命性的，但是在下一个示例或者作为正则表达式的一部分提供额外数据来实现字符串匹配操作的任何地方，它确定有它的独到之处，即使这些字符并不是你所感兴趣字符的一部分。</p>
<p>以上两个正则表达式都是非常严格的，尤其是要求一个字符串集。这可能在一个国际化的坏境中并不能良好地工作，因为所在的环境中会使用当地的日期和缩写。一个宽松的正则表达式将为：<code>^\w&#123;3&#125;</code>。该正则表达式仅仅需要一个以三个连续字母数字字符开头的字符串。再一次，将正则表达式转换为正常的自然语言：脱字符^表示“作为起始”，\w表示任意单个字母数字字符，｛3｝表示将会有3个连续的正则表达式副本，这里使用｛3｝来修饰正则表达式。再一次，如果想要分组，就必须使用圆括号，例如<code>^(\w&#123;3&#125;)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patt = <span class="string">&#x27;^(\w&#123;3&#125;)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(patt, data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;Thu&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)</span><br><span class="line"><span class="string">&quot;Thu&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，正则表达式<code>^\w&#123;3&#125;</code>是错误的。当{3}在圆括号中时，先匹配三个连续的字母数字字符，然后表示为一个分组。但是如果将｛3｝移到外部，它就等效于三个连续的单个字母数字字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patt = <span class="string">&#x27;^(\w)&#123;3&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.<span class="keyword">match</span>(patt, data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;Thu&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;u&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当我们访问子组1时，出现字母“u”的原因是子组1持续被下一个字符替换。换句话说，m.group(1)以字母“T”作为开始，然后变为“h”，最终被替换为“u”。这些是单个字母数字字符的三个独立（并且重叠）分组，与一个包含三个连续字母数字字符的单独分组相反。</p>
<p>在下一个（而且是最后）的示例中，我们将创建一个正则表达式来提取redata.txt每一行的末尾所发现的数字字段。</p>
<h3 id="搜索与匹配……还有贪婪"><a href="#搜索与匹配……还有贪婪" class="headerlink" title="搜索与匹配……还有贪婪"></a>搜索与匹配……还有贪婪</h3><p>然而，在创建任何正则表达式之前，我们就意识到这些整数数据项位于数据字符串的末尾。这就意味着我们需要选择使用搜索还是匹配。发起一个搜索将更易于理解，因为我们确切知道想要查找的内容（包含三个整数的数据集），所要查找的内容不是在字符串的起始部分，也不是整个字符串。如果我们想要实现匹配，就必须创建一个正则表达式来匹配整个行，然后使用子组来保存想要的数据。要展示它们之间的差别，就需要先执行搜索，然后实现匹配，以展示使用搜索更适合当前的需要。</p>
<p>因为我们想要寻找三个由连字符分隔的整数，所以可以创建自己的正则表达式来说明这一需求：<code>\d+-\d+-\d+</code>。该正则表达式的含义是，“任何数值的数字（至少一个）后面跟着一个连字符，然后是多个数字、另一个连字符，最后是一个数字集。”我们现在将使用search()来测试该正则表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patt = <span class="string">&#x27;\d+-\d+-\d+&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(patt, data).group()        <span class="comment"># entire match</span></span><br><span class="line"><span class="string">&#x27;1171590364-6-8&#x27;</span></span><br></pre></td></tr></table></figure>
<p>一个匹配尝试失败了，为什么呢？因为匹配从字符串的起始部分开始，需要被匹配的数值位于字符串的末尾。我们将不得不创建另一个正则表达式来匹配整个字符串。但是可以使用惰性匹配，即使用“.+”来表明一个任意字符集跟在我们真正感兴趣的部分之后。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patt = <span class="string">&#x27;.+\d+-\d+-\d+&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.<span class="keyword">match</span>(patt, data).group()</span><br><span class="line"><span class="string">&#x27;Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8&#x27;</span></span><br></pre></td></tr></table></figure>
<p>该正则表达式效果非常好，但是我们只想要末尾的数字字段，而并不是整个字符串，因些不得不使用圆括号对想要的内容进行分组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patt = <span class="string">&#x27;.+(\d+-\d+-\d+)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.<span class="keyword">match</span>(patt, data).group()        <span class="comment"># subgroup 1</span></span><br><span class="line"><span class="string">&#x27;4-6-8&#x27;</span></span><br></pre></td></tr></table></figure>
<p>发生了什么？我们将提取1171590364－6－8，而不仅仅是4－6－8.第一个整数的其余部分在哪儿？问题在于正则表达式本质上实现贪婪匹配。这就意味说对于该通配符模式，将对正则表达式从左至右按顺序求值，而且试图获取匹配该模式的尽可能多的字符。在之前的示例中，使用“.+”获取从字符串起始位置开始的全部单个字符，包括所期望的每一个整数字段。\d＋仅本一个数字，因此将得到“4”，其中.+匹配了从字符串起始部分到所期望的第一个数字的全部内容：“Thu Feb 15 17:46:04 2007::<a href="mailto:&#117;&#122;&#x69;&#102;&#x7a;&#x66;&#x40;&#x64;&#112;&#x79;&#105;&#118;&#105;&#x68;&#119;&#46;&#x67;&#x6f;&#x76;">&#117;&#122;&#x69;&#102;&#x7a;&#x66;&#x40;&#x64;&#112;&#x79;&#105;&#118;&#105;&#x68;&#119;&#46;&#x67;&#x6f;&#x76;</a>:117159036”，如图1－2所示。<br><img src="/1-2.jpg" alt="图 1-2　为什么匹配出错了: +是一个贪婪操作符" title="图　1－2"><br>其中的一个方案是使用“非贪婪”操作符“？”。读者可以在“*”、“＋”或者“?”之后使用该操作符。该操作符将要求正则表达式引擎匹配尽可能少的字符。因此，如果在“.+”之后放置一个“？”，我们将获得所期望的结果，如图1-3所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patt = <span class="string">&#x27;.+?(\d+-\d+-\d+)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.<span class="keyword">match</span>(patt, data).group(<span class="number">1</span>)        <span class="comment"># subgroup 1</span></span><br><span class="line"><span class="string">&#x27;1171590364-6-8&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/1-3.jpg" alt="图 1-3 解决贪婪匹配的问题：“?”表示非贪婪匹配" title="图 1-3"><br>另一个实际情况下更简单的方案，就是把“::”作为字段分隔符。读者可以仅仅使用正则字符串strip(‘::’)方法获取所有的部分，然后使用strip(‘-‘)作为另一个横线分隔符，就能够获取最初想要查询的三个整数。现在，我们不想先选择该方案，因为这就是我们如何将字符串放在一起，以使用gendata.py作为开始！</p>
<p>最后一个示例：假定我们仅想取出三个整数字段中间的那个整数。如下所示，这就是实现的方法（使用一个搜索，这样就不必匹配整个字符串）: -(\d+)-。尝试该模式，将得到以下内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patt = <span class="string">&#x27;-(\d+)-&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(patt, data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group()                        <span class="comment"># entire match</span></span><br><span class="line"><span class="string">&#x27;－6－&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)</span><br><span class="line">‘<span class="number">6</span>’</span><br></pre></td></tr></table></figure>
<p>本章几乎没有涉及正则表达式的强大功能，在有限的篇幅里面我们不可能做到。然而，我们希望已经向读者提供了足够有用的介绍性信息，使读者能够掌握这个强有力的工具，并融入到自己编程技巧里面。建议读者阅读参考文档以获取在Python中如何使用使用正则表达式的更多细节。对于想要更深入研究正则表达式的读者，建议阅读由Jeffrey E.F.FriedI编写的Msstering Regular Expressions。</p>
<h2 id="1-6-练习"><a href="#1-6-练习" class="headerlink" title="1.6 练习"></a>1.6 练习</h2><p><br>正则表达式。按照练习1－1～1－12的要求创建正则表达式。<br><br><span style="font-weight: bolder;">1-1 识别后续的字符串：“bat“、“bit“、“but”、”hat”、”hit”或者“hut”。</span><br><br><span style="font-weight: bolder;">1-2 匹配由单个空格分隔的任意单词对，也就是姓和名。</span><br><br><span style="font-weight: bolder;">1-3 匹配由单个逗号和单个空白符分隔的任何单词和单个字母，如姓氏的首字母。</span><br><br><span style="font-weight: bolder;">1-4 匹配所有有效Python标识符的集合。</span><br><br><span style="font-weight: bolder;">1-5 根据读者当地的格式，匹配街道地址（使你的正则表达达式足够通用，来匹配任意数量的街道单词，包括类型名称）。例如，美国街道地址使用如下格式：1180 Bordeaux Drive。使你的正则表达式足够灵活，以支持多单词的街道名称，如3120 De la Cruz Boulevard。</span><br><br><span style="font-weight: bolder;">1-6 匹配以“www”起始且以“.com”结尾的简单Web域名：例如，www:&#x2F;&#x2F;<a href="http://www.yahoo.com/%E3%80%82%E9%80%89%E5%81%9A%E9%A2%98%EF%BC%9A%E4%BD%A0%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%94%AF%E6%8C%81%E5%85%B6%E4%BB%96%E9%AB%98%E7%BA%A7%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%A6%82.edu%E3%80%81.net%E7%AD%89%EF%BC%88%E4%BE%8B%E5%A6%82%EF%BC%8Chttp://www.foothill.edu%EF%BC%89%E3%80%82">www.yahoo.com/。选做题：你的正则表达式也可以支持其他高级域名，如.edu、.net等（例如，http://www.foothill.edu）。</a></span><br><br><span style="font-weight: bolder;">1-7 匹配所有能够表示Python整数的字符串集。</span><br><br><span style="font-weight: bolder;">1-8 匹配所有能够表示Python长整数的字符串集。</span><br><br><span style="font-weight: bolder;">1-9 匹配所有能够表示Python浮点数的字符串集。</span><br><br><span style="font-weight: bolder;">1-10 匹配所有能够表示Python复数的字符串集。</span><br><br><span style="font-weight: bolder;">1-11 匹配所有能够表示有效电子邮件地址的集合（从一个宽松的正则表达式开始，然后尝试使它尽可能严谨，不过要保持正确的功能）。</span><br><br><span style="font-weight: bolder;">1-12　匹配所有能够表示有效的网站地址的集合（URL）（从一个宽松的正则表达式开始，然后尝试使它尽可能严谨，不过要保持正确的功能）。</span><br><br><span style="font-weight: bolder;">1-13 type()。内置函数type()返回一个类型对象。如下所示，该对象将表示为一个Pythonic类型的字符串。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">0</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">.34</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;float&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">dir</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;builtin_function_or_method&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>创建一个能够从字符串中报取实际类型名称的正则表达式。函数将对类心于&lt;type ‘int’&gt;的字符串返回int()。注意：你所实现的值将存入类和一些内置类型的<code>__name__</code>属性中。<br><br><span style="font-weight: bolder;">1-14 处理日期。1.2节提供了来匹配单个或者两个数字字符串的正则表达式模式，来表示1～9的月份(0?[1-9])。创建一个正则表达式来表示标准日历中剩余三个月的数字。</span><br><br><span style="font-weight: bolder;">1-15 处理信用卡号码。1.2节还提供了一个能够匹配信用卡（CC）号码([0-9]{15,16})的正则表达式模式。然而，该模式不允许使用连字符来分割数字块。创建一个允许使用连字符的正则表达式，但是仅能用于正确的位置。例如，15位信用卡号码使用4－6－5的模式。表明4个数字－连字符－6个数字－连字符－5个数字；16位的信用卡号码使用4－4－4－4模式。记住，要对整个字符串进行合适的分组。选做题：有一个判断信用卡号码是否有效的标准算法。编写一些代码，这些代码不但能够识别具有正确格式的号码，而且能够识别有效的信息用卡号码。使用gendata.py。下面一组练习（）专门处理由gendata.py生成的数据。在尝试练习1－17和1－18之前，读者需要先完成练习1－16以及所有正则表达式。</span><br><br><span style="font-weight: bolder;">1-16 为gendata.py更新代码，使数据直接输出到redata.txt而不是屏幕。</span><br><br><span style="font-weight: bolder;">1-17 判断在redata.tex中一周的每一天出现的次数（换句话说，读者也可以计算所选择的年份中每个月中出现的次数）。</span><br><br><span style="font-weight: bolder;">1-18 通过确认整数字段中的第一个整数匹配在每个输出行起始部分的时间戳，确保在redata.txt中没有数据损坏。</span></p>
<p>创建以下正则表达式：</p>
<p><br><span style="font-weight: bolder;">1-19 提取每行中完整的时间戳。</span><br><br><span style="font-weight: bolder;">1-20 提取每行中完整的电子邮件地址。</span><br><br><span style="font-weight: bolder;">1-21 仅仅提取时间戳中的月份。</span><br><br><span style="font-weight: bolder;">1-22 仅仅提取时间戳中的年份。</span><br><br><span style="font-weight: bolder;">1-23 仅仅提取时间戳中的时间（HH:MM:SS）</span><br><br><span style="font-weight: bolder;">1-24 仅仅从电子邮件地址中提取登录名和域名（包括主域名和高级域名一起提取）。</span><br><br><span style="font-weight: bolder;">1-25 仅仅从电子邮件地址中提取登录名和域名（包括主域名和高级域名）。</span><br><br><span style="font-weight: bolder;">1-26 使用你的电子邮件地址替换每一行数据中的电子邮件地址。</span><br><br><span style="font-weight: bolder;">1-27 从时间戳中提取月、日和年，然后以“月，日，年”的格式，每一行仅仅迭代一次。处理电话号码。对于练习1－28和1－29，回顾1.2节介绍的正则表达式<code>\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;</code>，它匹配电话号码，但是允许可选的区号作为前缀。更新正则表达式，使它满足以下条件。</span><br><br><span style="font-weight: bolder;">1-28 区号（三个整数集合中的第一部分和后面的连字符）是可选的，也就是说，正则表达式应当匹配800－555－1212，也能匹配555－1212。</span><br><br><span style="font-weight: bolder;">1-29 支持使用圆括号或者连字符连接的区号（更不用说是可选的内容）：使正则表达式匹配800-555-1212、555-1212以及（800）555－1212。正则表达式应用程序。下面练习在处理在线数据时生成了有用的应用程序脚本。</span><br><br><span style="font-weight: bolder;">1-30 生成HTML。提供一个链接列表（以及可选的简短描述），无论用户通过命令行方式提供、通过来自于其他脚本的输入，还是来自于数据库，都生成一个Web页面（.html），该页面包含作为超文本锚点的所有链接，它可以在Web浏览器中查看，允许用户单击这些链接，然后访问相应的站点。如果提供了简短的描述，就使用该描述作为超文本而不是URL。</span><br><br><span style="font-weight: bolder;">1-31 tweet精简。有时候你想要查看由Twitter用户发送到Twitter服务的tweet纯文本。创建一个函数以获取tweet和一个可选的“元”标记，该标记默认为False，然后返回一个已精简过的tweet字符串，即移除所有无关信息，例如，表示转推的RT符号、前导的“.”符号，以及所有＃号标签。如果元标记为True，就返回一个包含元数据的字典。这可以包含一个键“RT”，其相应的值是转推该消息的用户的字符串元组和&#x2F;或一个键“＃号标签”（包含一个＃号标签元组）。如果值不存在（空元组），就不要为此创建一个键值条目。</span><br><br><span style="font-weight: bolder;">1-32 亚马逊爬虫脚本。创建一个脚本，帮助你追踪你最喜欢的书，以及这些书在亚马逊上的表示（或者能够追踪图书排名的任何其他在线书店）。例如，亚马逊对于任何一本图书提供以下链接:<a href="http://amazon.com/dp/ISBN(%E4%BE%8B%E5%A6%82%EF%BC%8Chttp://amazon.com/dp/0132678209)%E3%80%82%E8%AF%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%9F%9F%E5%90%8D%EF%BC%8C%E6%A3%80%E6%9F%A5%E4%BA%9A%E9%A9%AC%E9%80%8A%E5%9C%A8%E5%85%B6%E4%BB%96%E5%9B%BD%E5%AE%B6%E7%9A%84%E7%AB%99%E7%82%B9%E4%B8%8A%E7%9B%B8%E5%90%8C%E7%9A%84%E5%9B%BE%E4%B9%A6%E6%8E%92%E5%90%8D%EF%BC%8C%E4%BE%8B%E5%A6%82%E5%BE%B7%E5%9B%BD%EF%BC%88.de%EF%BC%89%E6%B3%95%E5%9B%BD%EF%BC%88.fr%EF%BC%89%E6%97%A5%E6%9C%AC%EF%BC%88.jp%EF%BC%89%E4%B8%AD%E5%9B%BD%EF%BC%88.cn%EF%BC%89%E5%92%8C%E8%8B%B1%E5%9B%BD%EF%BC%88.co.uk%EF%BC%89%E3%80%82%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%88%96%E8%80%85%E6%A0%87%E8%AE%B0%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%8C%E4%BE%8B%E5%A6%82BeautifulSoup%E3%80%81lxml%E6%88%96%E8%80%85html5lib%E6%9D%A5%E8%A7%A3%E6%9E%90%E6%8E%92%E5%90%8D%EF%BC%8C%E7%84%B6%E5%90%8E%E8%AE%A9%E7%94%A8%E6%88%B7%E4%BC%A0%E5%85%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%EF%BC%8C%E6%8C%87%E6%98%8E%E8%BE%93%E5%87%BA%E6%98%AF%E5%90%A6%E5%BA%94%E5%BD%93%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%BA%AF%E6%96%87%E6%9C%AC%E4%B8%AD%EF%BC%8C%E4%B9%9F%E8%AE%B8%E5%8C%85%E5%90%AB%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E6%AD%A3%E6%96%87%E4%B8%AD%EF%BC%8C%E8%BF%98%E6%98%AF%E7%94%A8%E4%BA%8EWeb%E6%A0%BC%E5%BC%8F%E5%8C%96HTML%E4%B8%AD%E3%80%82">http://amazon.com/dp/ISBN(例如，http://amazon.com/dp/0132678209)。读者可以改变域名，检查亚马逊在其他国家的站点上相同的图书排名，例如德国（.de）法国（.fr）日本（.jp）中国（.cn）和英国（.co.uk）。使用正则表达式或者标记解析器，例如BeautifulSoup、lxml或者html5lib来解析排名，然后让用户传入命令行参数，指明输出是否应当在一个纯文本中，也许包含在一个电子邮件正文中，还是用于Web格式化HTML中。</a></span></p>
<h1 id="第2章-网络编程"><a href="#第2章-网络编程" class="headerlink" title="第2章　网络编程"></a>第2章　网络编程</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1　简介"></a>2.1　简介</h2><p>本节将简要介绍使用套接字进行网络编程的知识。然而，在深入研究之前，将介绍一些有关网络编程的背景信息，以及套接字如何应用于Python之中，然后展示如何使用Python的一些模块来创建网络应用程序。</p>
<h2 id="2-2-客户端-x2F-服务器架构"><a href="#2-2-客户端-x2F-服务器架构" class="headerlink" title="2.2　客户端&#x2F;服务器架构"></a>2.2　客户端&#x2F;服务器架构</h2><h3 id="2-2-1-硬件客户端-x2F-服务器架构"><a href="#2-2-1-硬件客户端-x2F-服务器架构" class="headerlink" title="2.2.1 硬件客户端&#x2F;服务器架构"></a>2.2.1 硬件客户端&#x2F;服务器架构</h3><p>打印（打印机）服务器是硬件服务器的一个例子。它们处理传入的打印作业并将其发送给系统中的打印机（或其他的打印设备）。这样的计算机通常可以通过网络进行访问，并且客户端计算机将向它发送打印请求。</p>
<p>硬件服务器的另一个例子就是文件服务器。这些通常都是拥有庞大通用存储容量的计算机，可以被客户端远程访问。客户端计算机会挂载服务器计算机上的磁盘，看起来好像这个磁盘就在本地计算机一样。支持文件服务器的一个最流行的网络操作系统就是Sun公司的网络文件系统（NFS）。如果你正在访问一个网络磁盘驱动器，并且无法分门辨它是在本地还是网络上，那么此时客户端&#x2F;服务器系统就已经完成了它的任务。它的目标就是让用户得到与访问本地磁盘完全相同的体验，抽象趣来就是正常的磁盘访问，而这些都是通过编程实现来确保以这种方式进行。</p>
<h3 id="2-2-2-软件客户端-x2F-服务器架构"><a href="#2-2-2-软件客户端-x2F-服务器架构" class="headerlink" title="2.2.2 软件客户端&#x2F;服务器架构"></a>2.2.2 软件客户端&#x2F;服务器架构</h3><p>软件服务器也运行在一块硬件之上，但是没有像硬件服务器那样的专用外围设备（如打印机、磁盘驱动器等）。软件服务器提供的主要服务包括程序执行、数据传输检索、聚合、更新，或其他类型的编程或数据操作。</p>
<p>现在一个更常见的输件服务器就是WEB服务器。如果个人或公司想要运行自己的Web服务器，那么必须拥有一台或多台计算机，在上面安装希望提供给用户的Web页面和Web应用程序，然后启动Web服务器。一个这样的服务器的工作就是接受客户端请求，并向（Web）客户端（即用户计算机上的浏览器）回送Web页面，然后等待下一个客户端的请求。这些服务器一旦开启，都将可能永远运行。虽然它们艵不能实现这一目标，但是它们会尽可能长时间地运行，除非受到一些外力驱使才会停止，如显式地关闭，或灾难性地关闭（由于硬件故障）。</p>
<p>数据库服务器是另一种类型的软件服务器。它们接受客户端的存储或检索请求，响应请求，然后等待更多的事务。与Web服务器类似，它们也是永远运行的。</p>
<p>我们将讨论的最后一类软件服务器就是窗体（windows）服务器，几乎可以认为这些服务器是硬件服务器。它们运行在一台附带（外接）显示设备（如显示器）的计算机上。窗体客户端其实就是一些程序，这些程序需要一个窗口化的环境来运行。这些通常被当作图形用户界面（GUI）应用程序。如果在没有窗体服务器的情况下执行它们，也即意味着在一个基于文本的环境中。如DOS窗口或一个UNIX　Shell中，即么将无法启动它们。一旦能够访问窗体服务器，即么一切都会正常。</p>
<p>在网络领域，这种环境会变得更加有趣。窗体客户端通常的显示设备就是本地计算机上的服务器，但是在一些网络化的窗体环境（如X Window系统）中，也可以选择另一台计算机的窗体服务器作为一个显示设备。在这种情况下，你就可以在一台计算机上运行一个GUI程序，而将它显示在另一台计算机上！</p>
<h3 id="2-2-3-银行出纳员作为服务器吗"><a href="#2-2-3-银行出纳员作为服务器吗" class="headerlink" title="2.2.3 银行出纳员作为服务器吗"></a>2.2.3 银行出纳员作为服务器吗</h3><p>想象客户端&#x2F;服务器架构如何工作的一个方法就是，在你的脑海中创建一个画面，那就是一个银行出纳员，他既不吃不睡，也不休息，服务一个又一个的排队客户，似乎永远不会结束。这个队列可能很长，也可能空无一人，但在任何给定的某个时刻，都可能会出现一个客户。当然，在几年前这样的出纳员完全是一种幻想，但是现在的自动取款机（ATM）似乎比较接近这种模型。</p>
<p>当然，出纳员就是一个运行在无限循环的服务器，而每个客户就是一个客户端，每个客户端都有一个需要解决的需求。这些客户到达银行，并由出纳以“先来先服务”的方式处理。一旦一个事务完成，客户就会离开，而出纳员要么为下一位客户服务，要么坐下来等待，直到一下位客户到来。</p>
<p>为什么所有的这些都很重要呢？因为在一般意义上，这种执行风格正是客户端&#x2F;服务器架构的工作方式。既然现在你已经有了基本的概念，接下来就让我们将它应用到网络编程上，而网络编程正是遵循客户端&#x2F;服务器架构的软件模型。</p>
<h3 id="2-2-4-客户端-x2F-服务器网络编程"><a href="#2-2-4-客户端-x2F-服务器网络编程" class="headerlink" title="2.2.4 客户端&#x2F;服务器网络编程"></a>2.2.4 客户端&#x2F;服务器网络编程</h3><p>在服务器响应客户端请求之前，必须进行一些初步的设置流程来为之　后的工作做准备。首先会创建一个通信端点，它能够使服务器监听请求。可以把服务器比作公司前台，或者应答公司主线呼叫的总机接线员。一旦电话号码和设备安装成功且接线员到达时，服务就可以开始了。这个过程与网络世界一样，一旦一个通信端点已经建立，监听服务器就可以进行无限循环中，等待客户端的连接并响应它们的请求。当然，为了使公司电话接待员一直处理忙碌状态，我们绝不能忘记将电话号码放在公司信笺，广告或一些新闻稿上：否则，将没有人会打电话过来！</p>
<p>相似地，必须让潜在的客户知道存在这样的服务器来处理他们的需求；否则，服务器将永远不会得到任何请求。想象着创建一个全新的网站，这可能是最了不起的、劲爆的、令人惊异的、有用的并且最酷的网站，但如果该网站的Web地址或URL从来没有以任何方式广播或进行广告宣传，那么永远也不会有人知道它，并且也将永远不会看到任何访问者。</p>
<p>现在你已经非常了解了服务器是如何工作的，这就已经解决了较固难的部分。客户端比服务器更简单，客户端所需要做的只是创建它的单一通信端点，然后建立一个到服务器的连接。然后，客户端就可以发出请求，该请求包括任何必要的数据交换。一旦请求被服务器处理，且客户端收到结果或某种确认信息，此次通信息就会被终止。</p>
<h2 id="2-3-套接字：通信端点"><a href="#2-3-套接字：通信端点" class="headerlink" title="2.3 套接字：通信端点"></a>2.3 套接字：通信端点</h2><p>本节将介绍套接字（socket），给出有关其起源的一些背景知识，并讨论各种类型的套接字。最后，将讲述如何利用它们使运行在不同（或相同）计算机上的进程相互通信。</p>
<h3 id="2-3-1-套接字"><a href="#2-3-1-套接字" class="headerlink" title="2.3.1 套接字"></a>2.3.1 套接字</h3><p>套接字是计算机网络数据结构，它体现了上节中所描述的“通信端点”的概念。在任何类型的通信开始之前，网络应用程序必须创建套接字。可以将它们比作电话插孔，没有它将无法进行通信。</p>
<p>套接字的起源可以追溯到20世纪70年代，它是加利福尼亚大学伯克利版本UNIX（称为BSD UNIX）的一部分。因此，有时你可能会听过将套接字称为伯克利套接字或BSD套接字。套接字最初是为同一主机上的应用程序所创建，使得主机上运行的一个程序（又名一个进程）与另一个运行的程序进行通信。这就是所谓的进程间通信（Inter Process Communication, IPC）。有两种类型的套接字：基于文件的和面向网络的。</p>
<p>UNIX套接字是我们所讲的套接字的第一个家族，并且拥有一个“家族名字”AF_UNIX（又名AF_LOCAL，在POSIX1.g标准中指定），它代表地址家族（address family）:UNIX。包括Python在内的大多数受欢迎的平台都使用术语地址家族及其缩写AF；其他比较旧的系统可能会将地址家族表示成域（domain）或协议家族（protocol family），并使用其缩写PF而非AF。类似地，AF_LOCAL（在2000～2001年标准化）将代替AF_UNIX。然而，考虑到向后兼容性，很多系统同时使用二者，只是对同一个常数使用不同的别名。Python本身仍然在使用AF_UNIX。</p>
<p>因为两个进程运行在同一台计算机上，所以这些套接字都是基于文件的，这意味文件系统支持它们的底层基础结构。这是能够说得通的，因为文件系统是一个运行在同一主机上的多个进程之间的共享常量。</p>
<p>第二种类型的套接字是基于网络的，它也有自己的家族名字AF_INET，或者地址家族；因特网。另一个地址家族AF_INET6用于第6版因特网协议（IPv6）寻址。此外，还有其他的地址家族，这些要么是专业的、过时的、很少使用的，要么是仍末实现的。在所有的地址家族之中，目前AF_INET是使用最广泛的。</p>
<p>Python2.5中引入了对特殊类型的Linux套接字的支持。套接字的AF_NETLINK家族（无连接［见2.3.3字］）允许使用标准的BSD套接字接口进行用户级别和内核级别代码之间IPC。之前那种解决方案比较麻烦，而这个解决方案可以看作一种比前一种更加优雅且风险更低的解决方案，例如，添加新系统调用、&#x2F;proc支持，或者对一个操作系统的“IOCTL”。</p>
<p>针对Linux的另一种特性（Python2.6中新增）就是支持透明的进程间通信（TIPC）协议。TIPC允许计算机集群之中的机器相互通信息，而无须使用基于IP的寻址方式。Python对TIPC的支持以AF_TIPC家族的方式呈现。</p>
<p>总的来说，Python只支持AF_UNIX、AF_NETLINK、AF_TIPC和AF_INET家族。因为本章重点讨论网络编程，所以在本章剩余的大部分内容中，我们将使用AF_INET。</p>
<h3 id="2-3-2-套接字地址：主机－端口对"><a href="#2-3-2-套接字地址：主机－端口对" class="headerlink" title="2.3.2 套接字地址：主机－端口对"></a>2.3.2 套接字地址：主机－端口对</h3><p>如果一个套接字像一个电话插孔－允许通信的一些基础设施，那么主机名和端口号就像区号和电话号码的组合。然而，拥有硬件和通信息的能力本身并没有任何好处，除非你知道电话打给谁以及如何拨打电话。一个网络地址由主机名和端口号对组成，而这是网络通信所需要的。此外，并未事先说明必须有其他人在另一端接听；否则，你将咱到这个熟悉的声音“对不起，你所拨打的电话是容号，请核对后再拨”。你可能已经在浏览网页的过程中见过一个网络类比，例如“无法连接服务器，服务器没有响就着或者服务器不可达。”</p>
<p>有效的端口号范围为0～65535（尽管小于1024的端口号预留给了系统）。可果你正在使用POSIX兼容系统（如Linux、Mac OS X等），那么可以在&#x2F;etc&#x2F;services文件中找到预留端口号的列表（以及服务器&#x2F;协议和套接字类型）。众所周知的端口号列表可以在这个网站中查看：<code>http://www.iana.org/assignments/port-numbers</code>。</p>
<h3 id="2-3-3-面向连接的套接字与无连接的套接字"><a href="#2-3-3-面向连接的套接字与无连接的套接字" class="headerlink" title="2.3.3 面向连接的套接字与无连接的套接字"></a>2.3.3 面向连接的套接字与无连接的套接字</h3><ol>
<li>面向连接的套接字</li>
</ol>
<p>不管你采用的是哪种地址家族，都有两种不同风格的套接字连接。第一种是面向连接的，这意味着在进行通信之前必须先建立一个连接，例如，使用电话系统给一个朋友打电话。这种类型的通信也称为虚拟电路或流套接字。</p>
<p>而向连接的通信提供序列化的、可靠的和不重复的数据交付，而没有记录边界。这基本上意味着每条消息可以拆分成多个片段，并且每一条消息片段都确保能够到达目的地，然后将它们按顺序组合在一起，最后将完整消息传递给正在等待的应用程序。</p>
<p>实现这种连接类型的主要协议是传输控制协议（更为人熟知的是它的缩写TCP）。为了创建TCP套接字，必须使用SOCK_STREAM作为套接字类型。TCP套接字的名字SOCK_STREAM基于流套接字的其中一种表示。因为这些套接字（AF_INET）的网络版本使用因特网协议（IP）来搜寻网络中的主机，所以整个系统通常结合这两种协议（TCP和IP）来进行（当然，也可以使用TCP和本地［非网络的AF_LOCAL&#x2F;AF_UNIX］套接字，但是很明显此时并没有使用IP）。</p>
<ol start="2">
<li>无连接的套接字</li>
</ol>
<p>与虚拟电路形成鲜明对比的是数据报类型的套接字，这是一种无连接的套接字。这意味着，在通信开始之前并不需要建立连接。此时，在数据传输过程中并无法保证它的顺序性］可靠性或重复性。然而，数据报确实保存了记录边界，这就意味着消息是以整体发送的，而并非道先分成多个片段，例如，使用面向连接的协议。</p>
<p>使用数据报的消息传输可以比作邮政服务。信件和包裹或许并不能以发送顺序到达。事实上，它们可能不会到达。为了将其添加到并发通信息中，在网络中基甚至有可能存在重复的消息。</p>
<p>既然有这么多副作用，为什么还使用数据报呢（使用流套接字肯定有一些优势）？由于面向连接的套接字所提供的保证，因此它们的设置以及对虚拟电路连接的维护需要大量的开销。然而，数据报不需要这些开销，即它的成本更加“低廉”。因此，它们通常能提供更好的性能，并且可能适合一些类型的应用程序。</p>
<p>实现这种连接类型的主要协议是用户数据报协议（更为人熟知的是其缩写UDP）。为了创建UDP套接字，必须使用SOCK_DGRAM作为套接字类型。你可能知道，UDP套接字的SOCK_DGRAM名字来自于单词“datagram”(数据报)。因为这些套接字也使用因特网协议来寻找网络中的主机，所以这个系统也有一个更加普通的名字，即这两种协议（UDP和IP）的组合名字，或UDP&#x2F;IP。</p>
<h2 id="2-4-Python中的网络编程"><a href="#2-4-Python中的网络编程" class="headerlink" title="2.4 Python中的网络编程"></a>2.4 Python中的网络编程</h2><p>既然你知道了所有关于客户端&#x2F;服务器架构、套接字和网络主面的基础知识，接下来就让我们试着将这些概念应用到Python中。本节中将使用的主要模块就是socket模块，在这个模块中可以找到socket()函数，该函数用于创建套接字对象。套接字也有自己的方法集，这些方法可以实现基于套接字的网络通信。</p>
<h3 id="2-4-1-socket-模块函数"><a href="#2-4-1-socket-模块函数" class="headerlink" title="2.4.1 socket()模块函数"></a>2.4.1 socket()模块函数</h3><p>要创建套接字，必须使用socket.socket()函数，这一般语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket(socket_family, socket_type, protocol=0)</span><br></pre></td></tr></table></figure>
<p>其中，socket_family是AF_UNIX或AF_INET（所前所述），socket_type是SOCK_STREAM或SOCK_DGRAM（也如前所述）。protocol通常省略，默认为0。所以，为了创建TCP&#x2F;IP套接字，可以用下面的方式调用socket.socket()。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br></pre></td></tr></table></figure>
<p>同样，为了创建UDP&#x2F;IP套接字，需要执行以下语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br></pre></td></tr></table></figure>
<p>因为有很多socket模块属性，所以此时使用“from module import *”这种导入方式可以接受，不过这只是其中的一个例外。如果使用“from socket import *”，那么我们就把scoket属性引入到了命名空间中。虽然这看起来有些麻烦，但是通过这种方式将能够大大缩短代码，正如下面所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpSock = socket(AF_INET, SOCK_STREAM)</span><br></pre></td></tr></table></figure>
<p>一旦有了一个套按字对象，那么使用套接字对象的方法可以进行进一步的交互。</p>
<h3 id="2-4-2-套接字对象（内置）方法"><a href="#2-4-2-套接字对象（内置）方法" class="headerlink" title="2.4.2 套接字对象（内置）方法"></a>2.4.2 套接字对象（内置）方法</h3><p>表2－1列出了最常见的套按字方法。在下一节中，我们将使用其中的一些方法创建TCP和UDP客户端与服务器。虽然我们专注于网络套接字，但这些方法与使用本地&#x2F;不联网的套按字时有类似的含义。</p>
<center><span style="font-size: 12px">表2－1　常见的套接字对象方法和属性</span></center>

<table>
<thead>
<tr>
<th>名　　称</th>
<th>描　　　　　　　　述</th>
</tr>
</thead>
<tbody><tr>
<td>服务器套接字方法</td>
<td></td>
</tr>
<tr>
<td>s.bind()</td>
<td>将地址（主机名、端口号对）绑定到套接字上</td>
</tr>
<tr>
<td>s.listen()</td>
<td>设置并启动TCP监听器</td>
</tr>
<tr>
<td>s.accept()</td>
<td>被动接受TCP客户端连接，一直等待直到连接到达（阻塞）</td>
</tr>
<tr>
<td>客户端套接字方法</td>
<td></td>
</tr>
<tr>
<td>s.connect()</td>
<td>主动发起TCP服务器连接</td>
</tr>
<tr>
<td>s.connect_ex()</td>
<td>connect()的扩展版本，此时会以错误码的形式返回问题，而不是抛出一个异常</td>
</tr>
<tr>
<td>普通的套按字方法</td>
<td></td>
</tr>
<tr>
<td>s.recv()</td>
<td>接收TCP消息</td>
</tr>
<tr>
<td>s.recv_into()➀</td>
<td>接收TCP消息到指定的缓冲区</td>
</tr>
<tr>
<td>s.send()</td>
<td>发送TCP消息</td>
</tr>
<tr>
<td>s.sendall()</td>
<td>完整地发送TCP消息</td>
</tr>
<tr>
<td>s.recvfrom()</td>
<td>接收UDP消息</td>
</tr>
<tr>
<td>s.recvfrom_into()➀</td>
<td>接收UDP消息到指定的缓冲区</td>
</tr>
<tr>
<td>s.sendto()</td>
<td>发送UDP消息</td>
</tr>
<tr>
<td>s.getpeername()</td>
<td>连接到套接字（TCP）的远程地址</td>
</tr>
<tr>
<td>s.getsockname()</td>
<td>当前套接字的地址</td>
</tr>
<tr>
<td>s.getsockopt()</td>
<td>返回给定套接字选项的值</td>
</tr>
<tr>
<td>s.setsockopt()</td>
<td>设置给定套接字选项的值</td>
</tr>
<tr>
<td>s.shutdown()</td>
<td>关闭连接</td>
</tr>
<tr>
<td>s.close()</td>
<td>关闭套接字</td>
</tr>
<tr>
<td>s.detach() ➁</td>
<td>在未关闭文件描述符的情况下关闭套接字，返回文件描述符</td>
</tr>
<tr>
<td>s.iocl() ➂</td>
<td>控制套接字的模式（仅支持Windows）</td>
</tr>
<tr>
<td>面向阻塞的套接字方法</td>
<td></td>
</tr>
<tr>
<td>s.setblocking()</td>
<td>设置套接字的阻塞或非阻塞模式</td>
</tr>
<tr>
<td>s.settimeout() ➃</td>
<td>设置阻塞套接字操作的超时时间</td>
</tr>
<tr>
<td>s.gettimeout() ➃</td>
<td>获取阻塞套接字操作的超时时间</td>
</tr>
<tr>
<td>面向文件的套接字方法</td>
<td></td>
</tr>
<tr>
<td>s.fileno()</td>
<td>套接字的文件描述符</td>
</tr>
<tr>
<td>s.makefile()</td>
<td>创建与套接字关联的文件对象</td>
</tr>
<tr>
<td>数据属性</td>
<td></td>
</tr>
<tr>
<td>s.family ➀</td>
<td>套接字家族</td>
</tr>
<tr>
<td>s.type ➀</td>
<td>套接字类型</td>
</tr>
<tr>
<td>s.proto ➀</td>
<td>套接字协议</td>
</tr>
<tr>
<td><span style="font-size: 14px;"><br/>➀ Python2.5中新增<br/>➁ Python3.2中新增<br/>➂ Python2.6中新增，仅仅支持Windows平台：POSIX系统可以使用functl模块函数<br/>➃ Python2.3中新增</span></td>
<td></td>
</tr>
</tbody></table>
<div class="note primary"><p><span style="font-size: 12pt;font-weight: bolder;">核心提示：在不同的计算机上分别安装客户端和服务器来运行网络应用程序</span><br/><br>在本章众多的例子中，你会经常看到指示主机“localhost”的代码和输出，或者看到127.0.0.1的IP地址。在这里的示例中，客户端和服务器运行在同一台计算机上。不过，鼓励读者修改主机名，交将代码复制到不同的计算机上，因为这样开发的代码运行起来更加有趣，让计算机通过网络相互通信，然后可以看到网络程序确实能够工作！</p>
</div>

<h3 id="2-4-3-创建TCP服务器"><a href="#2-4-3-创建TCP服务器" class="headerlink" title="2.4.3 创建TCP服务器"></a>2.4.3 创建TCP服务器</h3><p>首先，我们将展现创建通用TCP服务器的一般伪代码，然后对这些代码的含义进行一般性的描述。需要记住的是，这仅仅是设计服务器的一种方式。一旦熟悉了服务器设计，那么你将能够按照自己的需求修改下面的伪代码来操作服务器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ss = socket()                 <span class="comment"># 创建服务器套接字</span></span><br><span class="line">ss.bind()　　　　　　　　　　　　<span class="comment"># 套接字与地址绑定</span></span><br><span class="line">ss.listen()　　　　　　　　　　　<span class="comment"># 监听连接</span></span><br><span class="line">inf_loop:　　　　　　　　　　　　<span class="comment">#　服务器无限循环</span></span><br><span class="line">    cs = ss.accept()　　　　　 <span class="comment"># 接受客户端连接</span></span><br><span class="line">    comm_loop:　　　　　　　　　<span class="comment"># 通信循环</span></span><br><span class="line">        cs.recv()/cs.send()　 <span class="comment"># 对话（接收/发送）</span></span><br><span class="line">    cs.close()　　　　　　　　　<span class="comment"># 关闭客户端套接字</span></span><br><span class="line">ss.close()　　　　　　　　　　　<span class="comment"># 关闭服务器套接字＃（可选）</span></span><br></pre></td></tr></table></figure>
<p>所有套接字都是通过使用socket.socket()函数来创建的。因为服务器需要占用一个端口并等持客户端的请求，所以它们必须绑定到一个本地地址。因为TCP是一种面向连接的通信系统，所以在TCP服务器开始操作之前，必须安装一些基础设施。特别地，TCP服务器必须监听（传入）的连接。一旦这个安装过程完成后，服和器就可以开始它的无限循环。</p>
<p>调用accept()函数之后，就开启了一个简单的（单线程）服务器，它会等待客户端连接。默认情况下，accept()是阻塞的，这意味着执行将被暂停，直到一个连接到达。另外，套接字确实也支持非阻塞模式，可以参考文档或操作系统教材，以了解有关为什么以及如何使用非阻塞套接字的更多细节。</p>
<p>一旦服务器接受了一个连接，就会返回（利用accept()）一个独立的客户端套接字，用来与即将到来的消息进行交换。使用新的客户端套接字类似于将客户的电话切换给客服代表。当一个客户电话最后接进来时，主要的总机接线员会接到这个电话，并使用另一条线路将这个电话转接给合适的人来处理客户的需求。</p>
<p>这将能够空出主线（原始服务器套接字），以便接线员可以继续等待新的电话（客户请求），而此时客户及其连接的客服代表能够进行他们自己的谈话。同样地，当一个传入的请求到达时，服务器会创建一个新的通信端口来直接与客户端进行通信，再次空出主要的端口，以使其能够接受新的客户端连接。</p>
<p>一旦创建了临时套接字，通信就可以开始，通过使用这个新的套接字，客户端与服务器就可以开始参与发送和接收的对话中，直到连接终止。当一方关闭连接或者向对方发送一个空字符串时，通常就会关闭连接。</p>
<p>在代码中，一个客户端连接关闭之后，服务器就会等待另一个客户端连接，最后一行代码是可选的，在这里关闭了服务器套接字。其实，这种情况永远也不会碰到，因为服务器应该在一个无限循环中运行。在示例中这行代码用来提醒读者，当为服务器实现一个智能的退出方案时，建议调用close()方法。例如，当一个处理程序检测到一个外部条件时，服务器就应该关闭。在这些情况下，应该调用一个close()方法。</p>
<div class="note primary"><p><span style="font-size: 12pt;font-weight: bolder;">核心提示：多线程处理客户端请求</span><br/><br>我们没在该例子中实现这一点，但将一个客户端请求切换到一个新线程或进程来完成客户端处理也是相当普遍的。SocketServer模块是一个以socket为基础而创建的高级套接字通信模块，它支持客户端请求的线程和多进程处理。可以参考文档或在第4章的练习部分获取SocketServer模块的更多信息。</p>
</div>

<p>示例2－1给出了tsTserv.py文件，它是一个TCP服务器程序，它接受客户端发送的数据字符串，并将其打上时间戳（格式：［时间戳］数据）并返回给客户端（“tsTserv”代表时间戳TCP服务器，其他文件以类似的方式命令）。<br><br/><span style="background: #c0c0c0;">示例2－1　TCP时间戳服务器（tsTserv.py）&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br/><span style="font-size: 12px">这个脚本创建一个TCP服务器，它接受来自客户端的消息，然后将消息加上时间戳前缀并发送回客户端。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;&#x27;</span></span><br><span class="line">PORT = <span class="number">21567</span></span><br><span class="line">BUFSIZ = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line">tcpSerSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">tcpSerSock.bind(ADDR)</span><br><span class="line">tcpSerSock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;waiting for connection...&#x27;</span></span><br><span class="line">    tcpCliSock, addr = tcpSerSock.accept()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;...connected from:&#x27;</span>, addr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = tcpCliSock.recv(BUFSIZ)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        tcpCliSock.send(<span class="string">&#x27;[%s] %s &#x27;</span> % (</span><br><span class="line">            ctime(), data))</span><br><span class="line"></span><br><span class="line">    tcpCliSock.close()</span><br><span class="line">tcpSerSock.close()</span><br></pre></td></tr></table></figure>
<p><br/><span style="font-size: 14pt;font-weight: bolder;">逐行解释</span><br>第1～4行<br>在UNIX启动行后面，导入了time.ctime()和socket模块的所有属性。<br>第6～13行<br>HOST变量是空白的，这是对bind()方法的标识，表示它可以使用任何可用的地址。我们也选择了一个随机的端口号，并且该端口号似乎没有被使用或被系统保留。另外，对于该应用程序，将缓冲区大小设置为1KB。可以根据网络性能和程序需要改变这个容量。listen()方法的参数是在连接被转接或拒绝之前，传入连接请求的最大数。<br>第11行，分配了TCP服务器套接字（tcpSerSock），紧随其后的是将套接字绑定到服务器地址以及开启TCP监听器的调用。<br>第15～28行<br>一旦进入服务器的无限循环之中，我们就（被动的）等待客户端的连接。当一个连接请求出现时，我们进入对话循环中，在该循环中我们等待客户端发送的消息。如果消息是空白的，这意味着客户端已经退出，所以此时我们将跳出对话循环，关闭当前客户端连接，然后等待另一个客户端连接。如果确实得到了客户端发送的消息，就将其格式化并返回相同的数据，但是会在这些数据中加上当前时间戳的前缀。最后一行永远不会执行，它只是用来提醒读者，如果写了一个处理程序来考虑一个更加优雅的退出方式，正如前面讨论的，那么应该调用close()方法。<br>现在让我们看一下Python3版本（tsTserv3.py），如示例2－2所示。<br><br/><span style="background: #c0c0c0;">示例2－2　Python3 TCP时间戳服务器（tsTserv3.py）&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br/><span style="font-size: 12px">这个脚本创建一个TCP服务器，它接受来自客户端的消息，并返回加了时间戳前缀的相同消息。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;&#x27;</span></span><br><span class="line">PORT = <span class="number">21567</span></span><br><span class="line">BUFSIZ = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line">tcpSerSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">tcpSerSock.<span class="built_in">bin</span>(ADDR)</span><br><span class="line">tcpSerSock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;waiting for connection...&#x27;</span>)</span><br><span class="line">    tcpCliSock, addr = tcpSerSock.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;...connected from:&#x27;</span>, addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = tcpCliSock.recv(BUFSIZ)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        tcpCliSock.send(<span class="string">&#x27;[%s] %s&#x27;</span> % (</span><br><span class="line">            <span class="built_in">bytes</span>(ctime(), <span class="string">&#x27;utf-8&#x27;</span>), data))</span><br><span class="line"></span><br><span class="line">    tcpCliSock.close()</span><br><span class="line">tcpSerSock.close()</span><br></pre></td></tr></table></figure>
<p>第16、18和25行是与之前版本的变化，其中print变成了一个函数，并且也将字符串作为一个ASCII字节“字符串”发送，而并非Unicode编码。本书后面部分分们将讨论Python2到Python3的迁移，以及如何编写出无须修改即可运行于2.x版本或3.x版本解释器上的代码。</p>
<p>支持IPv6的另外两个变化并未在这里展示出来，但是当创建套接字时，你仅仅需要将地址家族中的AF_INET（IPv4）修改臧AF_INET6（IPv6）（如果你不熟悉这些术语，那么IPv4描述了当前的因特网协议，而下一代是版本6，即“IPv6”）。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>程序设计</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML前端技术学习</title>
    <url>/2017/09/26/html/</url>
    <content><![CDATA[<h1 id="1、常用标签"><a href="#1、常用标签" class="headerlink" title="1、常用标签"></a>1、常用标签</h1><ol>
<li>h标签</li>
<li>p标签</li>
<li>pre标签</li>
<li>br标签</li>
<li>em和i标签</li>
<li>strong标签和b标签</li>
<li>span标签</li>
<li>sub和sup标签</li>
<li>del和ins标签</li>
<li>a标签</li>
<li>列表标签ul ol dl<span id="more"></span></li>
</ol>
<h2 id="1-1、h标签"><a href="#1-1、h标签" class="headerlink" title="1.1、h标签"></a>1.1、h标签</h2><p>h标签又叫标题标签，是从h1到h6的，分别代表标题从大到小，即h1是最大的标题标签，依次减小。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>大象无形，大音希声。<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>大象无形，大音希声。<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>大象无形，大音希声。<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>大象无形，大音希声。<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>大象无形，大音希声。<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>大象无形，大音希声。<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下所示：<br><img src="1-1.png" style="margin : auto;"  width="50%" height="50%" title="[图1-1]"></p>
<div class="note danger"><p>h标签的数量有且仅有6个，并且一般情况下h标签在页面中只会允许出现一次</p>
</div>
<h2 id="1-2、p标签"><a href="#1-2、p标签" class="headerlink" title="1.2、p标签"></a>1.2、p标签</h2><p>p标签又叫做段落标签，代表的是一个完整的段落，当然这个标签可不仅仅只是用来代表段落的，同样也可以作为其他标签的容器来使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p代表的段落标签是独占一行<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3、pre标签"><a href="#1-3、pre标签" class="headerlink" title="1.3、pre标签"></a>1.3、pre标签</h2><p>pre标签是特殊的段落标签，它可以解析空格，比如下面这样的代码，要原样在html中展示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">  public void run()&#123;</span><br><span class="line">    log.i(tag,&quot;run function&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如上所示内容区域能够按照我们想要的排布来进行显示，一般情况下，主要用来显示代码区域等。</p>
<h2 id="1-4、br换行标签"><a href="#1-4、br换行标签" class="headerlink" title="1.4、br换行标签"></a>1.4、br换行标签</h2><p>br标签主要是用来进行换行操作的，是一个单标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">大象无形<span class="tag">&lt;<span class="name">br</span>&gt;</span>大音希声。</span><br></pre></td></tr></table></figure>
<h2 id="1-5、em和i标签，斜体字标签"><a href="#1-5、em和i标签，斜体字标签" class="headerlink" title="1.5、em和i标签，斜体字标签"></a>1.5、em和i标签，斜体字标签</h2><p>em标签和i标签都是斜体字标签，可能是在显示上面没有区们，但是他们也有很大的区别</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>我是em<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>我是i<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：<br><img src="1-2.png" title="[图1－2]" /><br>可以看到其实在显示上面并没有多少区别，但是他们也有几点区别：</p>
<ul>
<li><code>&lt;i&gt;</code>在创建之初就是简单　地表示粗体和斜体样式，但是到了HTML5，为了语义化特性，这两个标签也被赋予了语议，样式倒不那么重要，因为那是css的事情。但上面两组标签语义还是各有侧重。</li>
<li>i元素代表在普通文本中具有不同语态或语气的一段文本，某种程序上表明一段不同特性的文本，比如一个分类学名称，一个技术术语，一个外语习语，一个音译，一个想法或西本方文本中的一般船名</li>
<li>em元素代表对其内容的强调。突出强调的位置会改变语句本身的意义。因此，元素构成内容的一个部分。且这种方式表示强调的程序依赖于是何种语言</li>
<li>em不是一个普通的斜体标签。有时为了部分文本由于不同的语态或语气需有别于段落的其他部分，这是i标签更为合适。em标签不是为了表明重要性而是表示着强调。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//分类学名称</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;taxonomy&quot;</span>&gt;</span>Felis silvestris catus<span class="tag">&lt;/<span class="name">i</span>&gt;</span>is cute.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">//术语</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The term <span class="tag">&lt;<span class="name">i</span>&gt;</span>prose content<span class="tag">&lt;/<span class="name">i</span>&gt;</span>is defined above.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">//外语习语</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>There is a certain<span class="tag">&lt;<span class="name">i</span> <span class="attr">lang</span>=<span class="string">&quot;fr&quot;</span>&gt;</span>je ne sais quoi<span class="tag">&lt;/<span class="name">i</span>&gt;</span>in the air.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">//这是一句不带任何强调的句子</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Cats are cute animals.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">//em包围Cats，强调猫是种可爱的动物，而不是狗或者其他动物</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Cats<span class="tag">&lt;/<span class="name">em</span>&gt;</span> are cute animals.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">//em包围are，代表句子所说是事实，来反驳那些说猫不可爱的人</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Cats <span class="tag">&lt;<span class="name">em</span>&gt;</span>are<span class="tag">&lt;/<span class="name">em</span>&gt;</span> cute animals.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">//em包围cute，强调猫是一种可爱的动物，而不是有人说的刻薄、讨厌的动物</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Cats are <span class="tag">&lt;<span class="name">em</span>&gt;</span>cute<span class="tag">&lt;/<span class="name">em</span>&gt;</span> animals.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">//这里强调猫是动物而不是植物</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Cats are cute <span class="tag">&lt;<span class="name">em</span>&gt;</span>animals<span class="tag">&lt;/<span class="name">em</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-6、strong标签和b标签"><a href="#1-6、strong标签和b标签" class="headerlink" title="1.6、strong标签和b标签"></a>1.6、strong标签和b标签</h2><ul>
<li><code>&lt;strong&gt;</code>元素可以被用在标题、说明或者段落上，来显示这部分被包围的文字的重要性。它代表内容的强烈的重要性、严重性或者紧急性</li>
<li><code>&lt;b&gt;</code>元素主要是为了突出显示关键词、产品名称等。</li>
</ul>
<h2 id="1-7、-span标签"><a href="#1-7、-span标签" class="headerlink" title="1.7、 span标签"></a>1.7、 span标签</h2><p>span标签对应的是文本样式的分离标签：大概的意思就是，如果需要对文本样式中个别的样式进行单独定义的话，就可以使用如下的方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">这是一个<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red;background:blue;&quot;</span>&gt;</span>没有固定的格式表现，可对其应用样式<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="1-3.png" title="[图1－3]" style="margin:auto;" />
## 1.8、 sub和sup标签
sub标签和sup标签主要是用来进行上标显示和下标显示的，具体sub是表示下标显示的，sup用来表示上标显示的。如下所示显示勾股定理：
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>x<span class="tag">&lt;<span class="name">sub</span>&gt;</span>1<span class="tag">&lt;/<span class="name">sub</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>+y<span class="tag">&lt;<span class="name">sub</span>&gt;</span>1<span class="tag">&lt;/<span class="name">sub</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>=z<span class="tag">&lt;<span class="name">sub</span>&gt;</span>1<span class="tag">&lt;/<span class="name">sub</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
显示效果如下：
<img src="1-4.png" title="[图1－4]" style="margin:auto;" />
## 1.9、 del和ins标签
* del标签主要是定义是删除标签，定义文档中已经被删除的一些文本，如淘宝上的一些特价商品，在前面都会有一个废弃的价格。
* ins标签主要是插入标签，定义被插入的文本
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">原价<span class="tag">&lt;<span class="name">del</span>&gt;</span>￥998<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">惊爆价<span class="tag">&lt;<span class="name">ins</span>&gt;</span>558<span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br></pre></td></tr></table></figure>
效果显示如下：
<img src="1-5.png" title="[图1-5]" style="margin:auto;" />
## 1.10、 a标签
a标签又叫做文本链接标签，同时它也是唯一具有可以包含块级元素特性的标签。
* target属性：`_blank`属性：`_self(在本文档中去显示)、_blank（在新窗口中打开）`
* href属性：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//链接到同一个页面不同的位置</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#锚点名称&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;锚点名称&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:1234556@qq.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>a标签是一个超链接标签，默认的a标签在鼠标指上去的时候会有一个手指效果</li>
<li>a标签是一个行级元素标签</li>
<li>a标签有自己的默认的标签样式</li>
<li>如果a标签中的href没有指向的话，一般情况下我们都默认它是值为＃</li>
<li>在href链接到外部网站的时候，需要补全<code>http://</code></li>
</ul>
<h2 id="1-11、-列表标签ul-ol-dl"><a href="#1-11、-列表标签ul-ol-dl" class="headerlink" title="1.11、 列表标签ul ol dl"></a>1.11、 列表标签ul ol dl</h2><h3 id="1-11-1、无序列表的使用"><a href="#1-11-1、无序列表的使用" class="headerlink" title="1.11.1、无序列表的使用"></a>1.11.1、无序列表的使用</h3><p>无序列表是一个项目的列表，此列表项目默认使用粗体的原点来标记。无序列表始于ul标签，每个列表项始于li，也就是ul里面包含着每个列表项</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>显示效如如下所示：<br><img src="1-6.png" title="[图1－6]" style="margin:auto;" /><br>默认情况是，每个列表前面有一个默认的原点表示，这是默认的样式，可以进行修改为空心圆，方块符号，可以使用list-style-type或者直接用type属性来进行修改，一般情况下使用list-style-type来进行修改，因为属性集更为丰富。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;circle&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;square&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="1-7.png" title="［图1－7］" style="margin:auto;" />
* 无序列表是没有顺序的，但是可以通过样式设置来进行修改
* 无序列表是有默认样式的，这个可以使用list-style-type:none来进行去除
* 无序列表ul内部只能去嵌套li，不以嵌套别的，li内部可以去做嵌套操作
* 可以使用type="disc"(实心圆)、type="square"(方块)、type="circle"(空心圆)来进行无序列表样式的设置
### 1.11.2、有序列表的使用
有序列表ol，与无序列表相对应的肯定就是有序列表了，有序列表表示一列项目，列表项目默认使用的是数字来进行表示
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>赵六<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
效果如下：
<img src="1-8.png" title="[图1－8]" style="margin:auto;" />
默认ol是按照数字1234的序号进行显示操作的。对于有序弄表的显示，同样也可以使用type来进行序号的样式的修改
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>赵六<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;A&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>赵六<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;I&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>赵六<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>赵六<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
效果如下：
<img src="1-9.png" title="[图1－9]" style="margin:auto;" />
* 有序列表是以ol开始，第个列表项目以li开始
* ol的默认样式为1234显示
* 可以通过list-style-type:none来取消其默认的样式
* 可以通过type来设置其样式类型

<h3 id="1-11-3、自定义组合列表的使用"><a href="#1-11-3、自定义组合列表的使用" class="headerlink" title="1.11.3、自定义组合列表的使用"></a>1.11.3、自定义组合列表的使用</h3><p>自定义列表dl不仅仅是一列项目，同样是项目及其注释的组合，定义列表以dl标签开始，每个定义列表项目以dt开始，每个定义列表项的定义以dd开始，注意：定义列表dl，定义列表项目dt，定义列表项目的定义dd</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>计算机<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Lenvono　.......<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Dell ......<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>电视机<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>SONY ......<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>创维 .......<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="1-10.png" title="[图1－10]" style="margin:auto;" />
注意：
定义列表在前端开发的时候使用比较多。结合CSS样式，可以更好的布局与增加视觉效果等。
## 1.12、img标签的使用
img标签是前端页面中用来加载图像、图片的，当时有时候我们也不一定会使用img来进行图片的加载操作，而会使用background来作为背景添加上。
&emsp;&emsp;img标签是一个单标签，即`<img/>`而不是`<img></img>`这样一个对应结尾的部分
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//简单的使用方式</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;**.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200px&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片加载失败的时候的文字&quot;</span> <span class="attr">title</span>=<span class="string">&quot;鼠标放在图片上显示的文字&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
img标签的属性：
* src属性：`<img src="图片加载的路径，可以是本地图片，也可以是网络图下，图片类型可以是png、jpg、GIF" />`
* width宽度属性：`<img width="300px" />`
* height高度属性：`<img height="300px" />`
* alt图片加载失败显示的文字：`<img alt="图片加载失败的时候显示的文字" />`
* title鼠标放在图片上显示的文字：`<img title="鼠标放在图片上面显示出的文字" />`
# 2、`CSS+DIV`盒子模型
## 2.1、CSS样式
CSS样式指的是对html标签样式的设计，html等于是框架。CSS样式对于框架的一种装修。
### 2.1.1、CSS的构成
CSS规则是由两个主要的部分构成，选择器与一条或者多条样式属性声明
<img src="1-11.png" title="[图1－11]" style="margin:auto;" />
从上面可以看出，CSS样式其实就是选择器＋属性＋值，所构成的选择器可以是我们的标签名，可以是ID，也可以是我们的类名。
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>最简单的CSS样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span>&#123;<span class="attribute">width</span>:<span class="number">300px</span>;<span class="attribute">height</span>:<span class="number">300px</span>;<span class="attribute">background-color</span>:deeppink;<span class="attribute">color</span>:<span class="number">#777</span>;&#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>最简单的CSS样式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="1-12.png" title="[图1－12]" style="margin:auto;" />
### 2.1.1、CSS的分类
CSS样式在加载的时候，同样是需要去链接属性的，所以对CSS样式的加载又可以分为以下三种：
* 内部样式：如上例中的样式为，内部样式
* 行内样式：在标签内`style="width:300px;background:red;"`
* 外部样式：在`<head><link rel="stylesheet" href="外部样式链接.css" rel="">`

<p>关于外部样式、内部样式、行内样式的几点注意事项</p>
<ol>
<li>优先级：外部样式&lt;内部样式&lt;行内样式，所以优先级别最高的其实是行内样式，如果定义了行内样式的话那么外部样式和内部样式就不生效</li>
<li>rel属性规定当前文　档与被链接文档之间的关系</li>
</ol>
<h2 id="2-2、DIV盒子模型"><a href="#2-2、DIV盒子模型" class="headerlink" title="2.2、DIV盒子模型"></a>2.2、DIV盒子模型</h2><p>首先想象一下生活中的盒子模型，一个盒子主要包括的是：外壳和内部空间，那么外壳主要又包括了外壳的厚度，外壳的上侧面、底侧面，那么同样在前端设置中的盒子也是一样。<br><b>div盒子元素框＝元素内容＋内边＋边框＋外边距</b><br><img src="1-13.png" title="[图1－13]" style="margin:auto;" /></p>
<ul>
<li>元素的内容：主要指的是元素最内部分所承载的实际内容（element）</li>
<li>边框：围绕元素的内容和内边距的一条或者多条线（boder）</li>
<li>内边距：元素内容和边框之间的空白区域（padding）</li>
<li>外边距：边框以外是外边距默认透明的，因此不会遮挡其后的任何元素（margin）</li>
</ul>
<h3 id="2-2-1、内边距padding"><a href="#2-2-1、内边距padding" class="headerlink" title="2.2.1、内边距padding"></a>2.2.1、内边距padding</h3><p>内边距padding是元素内容与边框之间的空白区域<br>&amp;emsp;&amp;emsp;主要有如下几个属性：</p>
<ul>
<li>padding-top：顶部内边距padding-top:30px</li>
<li>padding-left：左侧内边距padding-left:30px</li>
<li>padding-right：右侧内边距padding-right:30px</li>
<li>padding-bottom：底部内边距padding-bottom:30px</li>
</ul>
<p>以上的内边距属性是都单一侧面来展示的，但是同时内边距同样有自己的复合展示属性padding</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//padding:复合属性</span><br><span class="line">padding:30px 30px 30px 30px</span><br><span class="line">//代表的是上、右、下、左（按照顺时针的方向来生效）</span><br><span class="line">padding:30px 30px 30px;</span><br><span class="line">//代表上，左右，下</span><br><span class="line">padding:30px 30px</span><br><span class="line">//代表的是上下，左右生效</span><br><span class="line">padding:30px;</span><br><span class="line">//代表的是四个方向都生效</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2、外边距margin"><a href="#2-2-2、外边距margin" class="headerlink" title="2.2.2、外边距margin"></a>2.2.2、外边距margin</h3><p>边框margin以外的外边距默认透明的，因此不会遮挡其后的任何元素，margin主要有以下四个属性，类似于padding</p>
<ul>
<li>margin-top：顶部外边距margin-top:30px</li>
<li>margin-left：左侧外边距margin-left:30px</li>
<li>margin-right：右侧外边距margin-right:30px</li>
<li>margin-bottom：底部外边距margin-bottom:30px</li>
</ul>
<p>以上的内边距属性是都单一侧面来展示的，但是同时内边距同样有自己的复合展示属性padding</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//margin:复合属性</span><br><span class="line">margin:30px 30px 30px 30px</span><br><span class="line">//代表的是上、右、下、左（按照顺时针的方向来生效）</span><br><span class="line">margin:30px 30px 30px;</span><br><span class="line">//代表上，左右，下</span><br><span class="line">margin:30px 30px</span><br><span class="line">//代表的是上下，左右生效</span><br><span class="line">margin:30px;</span><br><span class="line">//代表的是四个方向都生效</span><br></pre></td></tr></table></figure>
<div class="note success"><p>补充：使用margin:auto;可以让块级元素在父元素中居中显示</p>
</div>
<h3 id="2-2-3、边框border"><a href="#2-2-3、边框border" class="headerlink" title="2.2.3、边框border"></a>2.2.3、边框border</h3><p>boder属性主要代表的是边框属性，也就是外边距和内边距的分界线部分。所以与内外边距一样，其是支持上下左右属性及以复合属性，主要分为以下四种：</p>
<ul>
<li>border-top：上边框border-top:1px solid red;</li>
<li>border-right：右侧边框border-right:1px dotted red;</li>
<li>border-bottom：底部边框border-bottom:1px dashed green;</li>
<li>border-left：左侧边框border-left:1px solid blue;<br>border的其他属性：border-style</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>没有边框样式</td>
</tr>
<tr>
<td>solid</td>
<td>实线边框</td>
</tr>
<tr>
<td>dotted</td>
<td>点状边框</td>
</tr>
<tr>
<td>souble</td>
<td>双实线边框</td>
</tr>
<tr>
<td>dashed</td>
<td>虚线边框</td>
</tr>
<tr>
<td>border的其他属性：border-width</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>border-width</td>
<td>复合边框样式类型</td>
</tr>
<tr>
<td>border-top-width</td>
<td>顶部边框宽度</td>
</tr>
<tr>
<td>border-left-width</td>
<td>左侧边框宽度</td>
</tr>
<tr>
<td>border-right-width</td>
<td>右侧边框宽度</td>
</tr>
<tr>
<td>border-bottom-width</td>
<td>底部边框宽度</td>
</tr>
<tr>
<td>border的其他属性：border-color</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>border-color</td>
<td>复合边框样式类型</td>
</tr>
<tr>
<td>border-top-color</td>
<td>顶部边颜色</td>
</tr>
<tr>
<td>border-left-color</td>
<td>左侧边框颜色</td>
</tr>
<tr>
<td>border-right-color</td>
<td>右侧边框颜色</td>
</tr>
<tr>
<td>border-bottom-color</td>
<td>底部边框颜色</td>
</tr>
<tr>
<td>当然关于以上的border-style border-width border-color一般情况下用的都比较少，因为border复合属性其实已经可以完成其功能了;</td>
<td></td>
</tr>
<tr>
<td><code>border:border-width border-style border-color;</code></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: deeppink;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">10px</span> auto;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.main</span> <span class="selector-class">.content</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">250px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">250px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    这是外部盒子</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">      这是内部盒子</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="1-14.png" title="[图1－14]" style="margin:auto;" />

<h2 id="2-4、CSS选择器"><a href="#2-4、CSS选择器" class="headerlink" title="2.4、CSS选择器"></a>2.4、CSS选择器</h2><h3 id="2-4-1、初级选择器"><a href="#2-4-1、初级选择器" class="headerlink" title="2.4.1、初级选择器"></a>2.4.1、初级选择器</h3><ul>
<li>通配符选择器</li>
<li>元素选择器</li>
<li>ID选择器</li>
<li>class类选择器</li>
<li>类选择器与ID选择器之间的区别</li>
<li>后代选择器</li>
</ul>
<h4 id="2-4-1-1、通配符选择器"><a href="#2-4-1-1、通配符选择器" class="headerlink" title="2.4.1.1、通配符选择器"></a>2.4.1.1、通配符选择器</h4><p><code>*</code>星号会匹配所有有的元素，针对所有的元素设置，使用方式如下所示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;<span class="attribute">margin</span>:<span class="number">0px</span>;<span class="attribute">padding</span>:<span class="number">0px</span>&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，使用通配符的选择器的场景并不是很多，上面是我们清除浏览器默认样式的时候进行使用的。</p>
<h4 id="2-4-1-2、元素选择器"><a href="#2-4-1-2、元素选择器" class="headerlink" title="2.4.1.2、元素选择器"></a>2.4.1.2、元素选择器</h4><p>元素选择器是指用标签名字来进行选择，如下使用方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">width</span>:<span class="number">200px</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:red;<span class="attribute">font-size</span>:<span class="number">10px</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">width</span>:<span class="number">100px</span>;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-1-3、ID选择器"><a href="#2-4-1-3、ID选择器" class="headerlink" title="2.4.1.3、ID选择器"></a>2.4.1.3、ID选择器</h4><p>ID选择器主要是指的是通过标签的ID进行标签的选择，首先要给标签赋予一个id</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main_div&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在css样式中，通过#ID的形式，来进行选择，如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#main_div</span>&#123;<span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>ID选择器在与js结合的时候，会使用的比较多</p>
<h4 id="2-4-1-4、class类选择器"><a href="#2-4-1-4、class类选择器" class="headerlink" title="2.4.1.4、class类选择器"></a>2.4.1.4、class类选择器</h4><p>类选择器的使用方式类似ID选择器，首先要给标签一个指定的类，然后通过<code>.</code>点操作符来进行类名的选择如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在style样式中去进行类的选择</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;<span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>类选择器一般情况下在样式实现的时候会比较多，主要是因为html标准支持一个标签可以拥有多个类，但是不支持多个ID</p>
<h4 id="2-4-1-5、类选择器与ID选择器之间的区别"><a href="#2-4-1-5、类选择器与ID选择器之间的区别" class="headerlink" title="2.4.1.5、类选择器与ID选择器之间的区别"></a>2.4.1.5、类选择器与ID选择器之间的区别</h4><ul>
<li>ID选择器必须是唯一的不能有同名的ID存在，只能够使用一次，同名的class类选择器可以多次使用，也就是可以定义一个类来实现一个样式复用，但是ID选择器则不行。</li>
<li>关于权重（优先级），ID选择器的优先级会大于class类选择器，如果一个标签既有ID选择器也有class选择器，那么这个时候会优先ID选择器进行选择。</li>
</ul>
<h4 id="2-4-1-6、后代选择器"><a href="#2-4-1-6、后代选择器" class="headerlink" title="2.4.1.6、后代选择器"></a>2.4.1.6、后代选择器</h4><p>后代选择器，就是一个父级标签下面的所有后代，既可以包括这个标签的子集后代，也可包含这个子集后代的后代，即选择这个标签下所有指定元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      第一个li元素</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      第二个li元素</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>后代选择器，先去选择div然后选择div下面的ul然后再次选择ul下面的li</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;<span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;backgroud:blue;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-1-7、选择器实例"><a href="#2-4-1-7、选择器实例" class="headerlink" title="2.4.1.7、选择器实例"></a>2.4.1.7、选择器实例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    *&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;&#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">width</span>: <span class="number">1200px</span>;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">44</span>,<span class="number">44</span>,<span class="number">44</span>,<span class="number">0.5</span>);</span></span><br><span class="line"><span class="language-css">         <span class="attribute">margin</span>: <span class="number">10px</span> auto;</span></span><br><span class="line"><span class="language-css">     &#125;</span></span><br><span class="line"><span class="language-css">     <span class="selector-id">#id_selector</span>&#123;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">     &#125;</span></span><br><span class="line"><span class="language-css">     <span class="selector-class">.class_selector</span>&#123;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">     &#125;</span></span><br><span class="line"><span class="language-css">     <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">background-color</span>: <span class="number">#84a3e3</span>;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">margin-top</span>:<span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">     &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;id_selector&quot;</span>&gt;</span></span><br><span class="line">      ID选择器使用</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;class_selector&quot;</span>&gt;</span></span><br><span class="line">      类选择器使用</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>后代选择器1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>后代选择器2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>后代选择器3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：<br><img src="1-16.png" title="[图1－16]" style="margin:auto;" /></p>
<h1 id="3、HTML5"><a href="#3、HTML5" class="headerlink" title="3、HTML5"></a>3、HTML5</h1><h2 id="3-1、html文件的声明"><a href="#3-1、html文件的声明" class="headerlink" title="3.1、html文件的声明"></a>3.1、html文件的声明</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在html标签内部主要分为两个部分，一个是head头部部分，一个是body体部</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span> //头部部分</span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span> //体部部分</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>头部部分主要是一些对一引些必要属性的声明，或者样式的设计，以及CSS或者JS等链接。体部部分主要包括页面的一些布局，或者样式等设置，JS等引用等也可以在体部做引用声明。在head标签中必须要声明语言类型，一般为<code>lang = &quot;en&quot;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>头部文件中包含的必要的一些属性和对应的值。meta标签，元素可提供相关页面的元信息（meta-information）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>http-equiv</td>
<td>content-type<br/>expires<br/>refresh<br/>set-cookie</td>
<td>把content属性关联到HTTP的头部</td>
</tr>
<tr>
<td>name</td>
<td>author(html的定义作者)<br/>description(html文档主要的描述)<br/>keywords(关链字)<br/>generator(编辑器的名称)<br/>revised(网页文档的修改时间)<br/>others</td>
<td>把content属性关联到一个名称</td>
</tr>
<tr>
<td>scheme</td>
<td>some_text</td>
<td>定义用于翻译content属性值的格式</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;****&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;html文档的描述&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;webstorm&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;revised&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2015-01-01&quot;</span> /&gt;</span></span><br><span class="line">//定义文档的编码类型</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>link标签是用来进行外部链接使用的</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>href</td>
<td>url</td>
<td>规定被链接的文档的位置</td>
</tr>
<tr>
<td>hreflang</td>
<td>language-code</td>
<td>规定被链接的文档中的文本语言</td>
</tr>
<tr>
<td>media</td>
<td>media-query</td>
<td>规定被链接文档被显示在什么设备上</td>
</tr>
<tr>
<td>ref</td>
<td>alternate<br/>author<br/>help<br/>icon<br/>licence<br/>next<br/>pingback<br/>stylesheet<br/>tag<br/>search<br/>prev</td>
<td>规定当前文档与被链接文档之间的关系</td>
</tr>
<tr>
<td>sizes</td>
<td>尺寸</td>
<td>规定被链接资源的尺寸，仅仅试用与rel&#x3D;”icon”</td>
</tr>
<tr>
<td>type</td>
<td>MIME_TYPE</td>
<td>规定被链接文档的MIME类型</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>script标签：引入js文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;***.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>title标签：用来定义文档的名称</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>html网页名称<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>举例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>举例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">body</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dt</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">p</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">list-style</span>:none;<span class="attribute">padding</span>:<span class="number">0</span>;&#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">img</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">border</span>:<span class="number">0</span>;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">display</span>:block;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">a</span>&#123;text-descoration:none;<span class="attribute">color</span>:inherit;&#125;</span></span><br><span class="line"><span class="language-css">      *&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;&#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ........</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2、行内元素与块级元素"><a href="#3-2、行内元素与块级元素" class="headerlink" title="3.2、行内元素与块级元素"></a>3.2、行内元素与块级元素</h2><p>行内元素（display:inline）：只是占据它内容所占的位置，默认是内容撑开高度，其他的内容的显示是在行级元素的后面进行的。行级元素是不能设置宽高的，默认是内容撑开的高度。<br>&amp;emsp;&amp;emsp;块级元素（display:block）：块级元素是会独占一行的位置，它后面的元素是会换行进行显示的，并且块级元素如果不给宽高，默认宽度是父级元素宽度的100%，高度则是内容撑开的高度的。</p>
<h3 id="3-2-1、行内元素与块级元素区别"><a href="#3-2-1、行内元素与块级元素区别" class="headerlink" title="3.2.1、行内元素与块级元素区别"></a>3.2.1、行内元素与块级元素区别</h3><ol>
<li>块级元素会占一行显示，但是行内元素可以在一行并排的显示</li>
<li>行内元素对以下属性的特殊化效果</li>
</ol>
<ul>
<li>设置宽度width无效</li>
<li>设置高度height无效</li>
<li>设置margin外边距的时候，默认只会支持左右，上下设置无效，并且auto也是无效的</li>
<li>设置padding内边距的时候，默认左右有效，上下是无效</li>
</ul>
<h3 id="3-2-2、行内元素与块级元素之间转换"><a href="#3-2-2、行内元素与块级元素之间转换" class="headerlink" title="3.2.2、行内元素与块级元素之间转换"></a>3.2.2、行内元素与块级元素之间转换</h3><p>我们可以通过样式属性的设置，来控制标签的样式显示，即去改变标签的行块级的特性。主要有以下四种：</p>
<ol>
<li>display:none：不显示，包括其子元素都会被隐藏起来，彻彻底底消失</li>
<li>display:block：将行内元素转换成块级元素，有块级的宽高，独占一行，padding,margin等设置特性。</li>
<li>display:inline：将块级元素转换成行内元素，这个时候具有行内元素的特性，可以横排显示灯</li>
<li>display:inline-block：以行内元素形式进行排列，以块级元素的样式进行显示，有块级元素的所有特性，但是支持行内的横排显示，一般使用会多一些。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>行块级元素的转换<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>:<span class="number">1200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>:<span class="number">10px</span> auto;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span> <span class="number">1px</span> solid blcak;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>:<span class="number">#00aa00</span></span></span><br><span class="line"><span class="language-css">      border:<span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.main</span> <span class="selector-class">.display_none_demo</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>:none;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.main</span> <span class="selector-class">.display_inline_demo</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: inline;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.main</span> <span class="selector-class">.display_block_demo</span> <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>:block;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#84a3e3</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.main</span> <span class="selector-class">.display_inline_block_demo</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;display_none_demo&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个块级元素p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>第二个块级素p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;display_inline_demo&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>第三个块级元素p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>第四个块级元素p<span class="tag">&lt;/<span class="name">p</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;display_block_demo&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>第一个span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>第二个span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;display_inline_block_demo&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>第5个p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>第三个span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>第6个p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="1-15.png" title="[图1－15]" style="margin:auto;" /></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>前端技术</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>锋利的jquery</title>
    <url>/2017/08/17/jquery/</url>
    <content><![CDATA[<h1 id="1、认识jQuery"><a href="#1、认识jQuery" class="headerlink" title="1、认识jQuery"></a>1、认识jQuery</h1><h2 id="1-1、jQuery库类型说明"><a href="#1-1、jQuery库类型说明" class="headerlink" title="1.1、jQuery库类型说明"></a>1.1、jQuery库类型说明</h2><p>jQuery库的类型分为两种版本，如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>jquery-1.3.1.js</td>
<td>114KB</td>
<td>完整无压缩版本，主要用于测试、学习和开发</td>
</tr>
<tr>
<td>jquery-1.3.1.min.js</td>
<td>54KB&#x2F;18KB</td>
<td>经过JSMin等工具压缩后的版本，大小为54KB。如果服务器开启Gzip压缩后，大小将变为只有18KB，成为体积最小的版本。主要应用于产品和项目</td>
</tr>
</tbody></table>
<span id="more"></span>
<h2 id="1-2、DOM对象"><a href="#1-2、DOM对象" class="headerlink" title="1.2、DOM对象"></a>1.2、DOM对象</h2><p>DOM（Document Object Model，文档对象模型），每一份DOM都可以表示成一棵树。下面来构建一个非常基本的网页，网页代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!Document <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>例子<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">title</span>=<span class="string">&quot;你最喜欢的水果&quot;</span>&gt;</span>你最喜欢的水果是?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>菠萝<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以把上面的HTML结构描述为一棵DOM树，如图1-14所示</p>
<center><img src="1-14.png"  width="50%" height="50%" title="[图1-14]"></center>

<p>在这棵DOM树中，<code>&lt;h3&gt;、&lt;p&gt;、&lt;ul&gt;以及&lt;ul&gt;的3个&lt;li&gt;</code>子节点都是DOM元素节点。可以通过javascript中的getElementsByTagName或者getElementByID来获取元素的节点。像这样得到的DOM元素就是DOM对象。DOM对象可以使用javascript中的方法，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> domObj = <span class="variable language_">document</span>.<span class="title function_">getElementByID</span>(<span class="string">&quot;id&quot;</span>);  <span class="comment">//获得DOM对象</span></span><br><span class="line"><span class="keyword">var</span> dobHTML = domObj.<span class="property">innerHTML</span>;  <span class="comment">//使用javascript中的方法--innerHTML</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>lychee说明文档</title>
    <url>/2021/08/21/lychee/</url>
    <content><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="1-1-服务器要求"><a href="#1-1-服务器要求" class="headerlink" title="1.1. 服务器要求"></a>1.1. 服务器要求</h3><ul>
<li><p>一个Web服务器，如Apache或nginx</p>
</li>
<li><p>数据库</p>
<ul>
<li>MySQL (版本&gt;5.7.8) &#x2F; MariaDB(版本&gt;10.2)</li>
<li>PostgreSQL (版本&gt;9.2)</li>
<li>Lyche的内置SQLite3支持</li>
</ul>
</li>
<li><p>PHP&gt;&#x3D;7.4带有这此扩展：</p>
<ul>
<li>BCMath</li>
<li>Ctype</li>
<li>Exif</li>
<li>Ffmpeg（可选 - 可以生成视频缩略图）</li>
<li>Fileinfo</li>
<li>GD</li>
<li>Imagick (可选 - 可以生成更好的缩略图)</li>
<li>JSON</li>
<li>Mbstring</li>
<li>OpenSSL</li>
<li>PDO</li>
<li>Tokenizer</li>
<li>XML</li>
<li>ZIP</li>
</ul>
</li>
</ul>
<blockquote>
<p>Lychee强烈建议使用64位操作系统，虽然它可以在32位系统上工作</p>
</blockquote>
<span id="more"></span>

<h3 id="1-2-安装荔枝"><a href="#1-2-安装荔枝" class="headerlink" title="1.2 安装荔枝"></a>1.2 安装荔枝</h3><p>Lychee提供了三种安装方法：它们分别是使用Docker镜像、源文件安装、使用Composer</p>
<h4 id="1-2-1-使用Docker"><a href="#1-2-1-使用Docker" class="headerlink" title="1.2.1. 使用Docker"></a>1.2.1. 使用Docker</h4><h4 id="1-2-2-源文件安装"><a href="#1-2-2-源文件安装" class="headerlink" title="1.2.2. 源文件安装"></a>1.2.2. 源文件安装</h4><h5 id="1-2-2-1-MariaDB安装"><a href="#1-2-2-1-MariaDB安装" class="headerlink" title="1.2.2.1 MariaDB安装"></a>1.2.2.1 MariaDB安装</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install mariadb-server </span><br><span class="line">sudo systemctl status mariadb</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> mariadb <span class="comment"># 开机运行</span></span><br><span class="line">sudo mysql_secure_installation <span class="comment"># 进行简单相关配置</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-2-PHP安装"><a href="#1-2-2-2-PHP安装" class="headerlink" title="1.2.2.2 PHP安装"></a>1.2.2.2 PHP安装</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install php php-fpm</span><br></pre></td></tr></table></figure>

<p>与Apache不同，<a href="https://www.myfreax.com/how-to-install-nginx-on-debian-10/"> Nginx </a>没有内置的支持来处理PHP文件。您需要使用PHP FPM fastCGI进程管理器服务来处理PHP文件。</p>
<p>安装软件包后，PHP FPM服务将自动启动。</p>
<p>您现在可以编辑Nginx服务器域块并添加以下行，以便Nginx可以处理PHP文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># . . . other code</span></span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include snippets/fastcgi-php.conf;</span><br><span class="line">        fastcgi_pass unix:/run/php/php7.3-fpm.sock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装php扩展：<code>sudo apt install php-[extname]</code></p>
<h5 id="1-2-2-3-安装nginx"><a href="#1-2-2-3-安装nginx" class="headerlink" title="1.2.2.3 安装nginx"></a>1.2.2.3 安装nginx</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install curl gnupg2 ca-certificates lsb-release <span class="comment"># 安装先决条件</span></span><br><span class="line"><span class="comment"># 需要将Nginx主线包添加到我们的存储库中，这样当我们运行apt install nginx时，我们将下载主线版本而不是旧的稳定版本</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://nginx.org/packages/mainline/debian &#x27;lsb_release -cs&#x27; nginx&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nginx.list</span><br><span class="line"><span class="comment"># 或者，如果您想使用较旧且较慢的Nginx稳定版本，你可以通过运行：（请记住，您应该只运行以下之一）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://nginx.org/packages/stable/debian &#x27;lsb_release -cs&#x27; nginx&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nginx.list</span><br><span class="line"><span class="comment"># 下载签名密钥，以便我们可以验证其真实性</span></span><br><span class="line">curl -fsSL https://nginx.org/keys/nginx_signing.key | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="1-2-2-4-Lycheee"><a href="#1-2-2-4-Lycheee" class="headerlink" title="1.2.2.4 Lycheee"></a>1.2.2.4 Lycheee</h5><p>从<a href="https://github.com/LycheeOrg/Lychee/releases">发布</a>页面下载发布zip文件并将其解压缩。它包含一个精简版的Lychee文件。<code>/var/www/html</code></p>
<h4 id="1-2-3-使用Composer"><a href="#1-2-3-使用Composer" class="headerlink" title="1.2.3. 使用Composer"></a>1.2.3. 使用Composer</h4><p>Lychee使用Composer来管理其依赖项。确保您的机器上安装Composer。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://www.github.com/LycheeOrg/Lychee /var/www/html/Lychee</span><br></pre></td></tr></table></figure>



<p>进入目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/html/Lychee</span><br></pre></td></tr></table></figure>

<p>安装所需的依赖项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">composer install --no-dev</span><br></pre></td></tr></table></figure>

<p>如果你想帮助开发Lychee，请删除<code>--no-dev</code>并替换为<code>--dev</code></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3>]]></content>
      <categories>
        <category>文档手册</category>
      </categories>
      <tags>
        <tag>Lychee</tag>
      </tags>
  </entry>
  <entry>
    <title>openvpn安装与配置</title>
    <url>/2018/08/31/openvpn/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>OpenVPN是一个用于创建虚拟专用网络加密通道的软件包，最早由James Yonan编写。OpenVPN允许创建的VPN使用公开密钥、电子证书、或者用户名／密码来进行身份验证。</p>
<p>它大量使用了OpenSSL加密库中的SSLv3&#x2F;TLSv1协议函数库。</p>
<p>目前OpenVPN能在Solaris、Linux、OpenBSD、FreeBSD、NetBSD、Mac OS X与Microsoft Windows以及Android和iOS上运行，并包含了许多安全性的功能。它并不是一个基于Web的VPN软件，也不与IPsec及其他VPN软件包兼容。</p>
<span id="more"></span>

<h1 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h1><h2 id="为什么使用PKI而不是静态密码呢？"><a href="#为什么使用PKI而不是静态密码呢？" class="headerlink" title="为什么使用PKI而不是静态密码呢？"></a>为什么使用PKI而不是静态密码呢？</h2><p>静态加密使用的是静态密钥，它容易设置，但是缺点是：</p>
<ol>
<li>一次只能有一个客户端使用服务器</li>
<li>如果密钥遭到丢失，将带来不可挽回的损失</li>
</ol>
<p>使用PKI允许一次使用多个客户端，每个客户端都有自己的密钥。服务器不必具有客户端的任何特殊知识。OpenVPN只需要提供我们即将设置的OpenVPN CA签署的证书。反之，客户端也会验证服务器的证书</p>
<p>OpenVPN CA密钥不应放在OpenVPN服务器上。它仅用于签署客户端的证书，因此应该存储在可以执行操作的地方，但不能被盗。一旦CA密码被盗，你将无法再信任该CA颁发的任何证书。</p>
<h2 id="什么是Certificate-Authority-CA-？"><a href="#什么是Certificate-Authority-CA-？" class="headerlink" title="什么是Certificate Authority(CA)？"></a>什么是Certificate Authority(CA)？</h2><p>你可能在应用中遇到过TLS网站证书，通常证书在WEB上下文中有两个作用</p>
<ol>
<li>加密浏览器与服务器之间的数据</li>
<li>确保流览器连接到目标网站</li>
</ol>
<p>由当浏览器信任某个证书颁发机构颁发的证书时，才可以执行第二个任务。任何人都可以制作证书，但它并不能保证证书是合法的拥有者。因为证书颁发机构可以带来可靠的额外保证，因此CA证书分为收费与免费，创建自己的CA以签署OpenVPN客户端证书是一种可以控制谁可以连接到OpenVpn服务器的有效方法。这样您的Openvpn服务器只会信任你要创建的CA签署的客户端证书。同样如果一个政府机构在互联网提供一些便民服务，那么如何有效的必免钓鱼网站的信息套取呢，注册收费的CA证书是个有效的方法。</p>
<p>##OpenVPN是一个用于创建虚拟专用网络加密通道的软件包，最早由James Yonan编写。OpenVPN允许创建的VPN使用公开密钥、电子证书、或者用户名／密码来进行身份验证。</p>
<p>它大量使用了OpenSSL加密库中的SSLv3&#x2F;TLSv1协议函数库。</p>
<h2 id="完美前向保密PFS（perfect-forward-secrecy）"><a href="#完美前向保密PFS（perfect-forward-secrecy）" class="headerlink" title="完美前向保密PFS（perfect forward secrecy）"></a>完美前向保密PFS（perfect forward secrecy）</h2><p>“perfect forward secrecy”则是由Christoph G. Günther在EUROCRYPT ’89提出的，其最初用于定义会话密钥交换协议的一种安全性。它的作用是保证密钥丢失之前的消息案全性或签名的不可伪造性。一般而言公钥是固定的，而密钥则随着时间进行更新。这个更新过程是单向的，因引也就保证了拿到当前的密钥，是无法恢复出以前的密钥，从而保证了前向安全。</p>
<p>Openvpn服务器配置我们将使用“perfect forward secrecy”，也就是说，加密的数据即使在前进的进候也会是秘密的。用于连接的证书和密钥不用于加密您的通讯数据。它们在传递数据时使用临时的加密密钥。默认情况下，这个临时密钥随着时间的推移每小时旋转一次。以这种方式，如果来不法份子收集了VPN数据包要想获得临时密钥那是不可能的，它允其量能够解密你最后一小时的数据。</p>
<p>在Openvpn服务器上配置了perfect forward secrecy你会在日志中看到每小时数据重置的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tue Jun 13 01:51:20 2017 client/142.68.135.226:53504 TLS: soft reset sec=0 bytes=51538/0 pkts=255/0</span><br><span class="line">Tue Jun 13 01:51:20 2017 client/142.68.135.226:53504 VERIFY OK: depth=1, C=US, ST=RI, L=Quahog, O=Happy Go Lucky Toys, OU=Inspections, CN=Happy Go Lucky Toys CA, name=EasyRSA, emailAddress=ca@happygoluckytoys.com</span><br><span class="line">Tue Jun 13 01:51:20 2017 client/142.68.135.226:53504 VERIFY OK: depth=0, C=US, ST=RI, L=Quahog, O=Happy Go Lucky Toys, OU=Inspections, CN=client, name=EasyRSA, emailAddress=noreply@happygoluckytoys.com</span><br><span class="line">Tue Jun 13 01:51:20 2017 client/142.68.135.226:53504 Data Channel Encrypt: Cipher &#x27;AES-256-CBC&#x27; initialized with 256 bit key</span><br><span class="line">Tue Jun 13 01:51:20 2017 client/142.68.135.226:53504 Data Channel Encrypt: Using 512 bit message hash &#x27;SHA512&#x27; for HMAC authentication</span><br><span class="line">Tue Jun 13 01:51:20 2017 client/142.68.135.226:53504 Data Channel Decrypt: Cipher &#x27;AES-256-CBC&#x27; initialized with 256 bit key</span><br><span class="line">Tue Jun 13 01:51:20 2017 client/142.68.135.226:53504 Data Channel Decrypt: Using 512 bit message hash &#x27;SHA512&#x27; for HMAC authentication</span><br><span class="line">Tue Jun 13 01:51:21 2017 client/142.68.135.226:53504 Control Channel: TLSv1.2, cipher TLSv1/SSLv3 DHE-RSA-AES256-SHA256, 2048 bit RSA</span><br></pre></td></tr></table></figure>
<p>Openvpn允许您控制旋转周期以匹配偏执狂级别。在server.conf文件中配置reneg-sec xx控制关键周期是多少秒。</p>
<h2 id="都包括哪个密钥文件"><a href="#都包括哪个密钥文件" class="headerlink" title="都包括哪个密钥文件"></a>都包括哪个密钥文件</h2><h3 id="Key文件（-key）"><a href="#Key文件（-key）" class="headerlink" title="Key文件（*.key）"></a>Key文件（*.key）</h3><p>这个是应该保密的私钥文件。只有所有者才需要使用私钥，所以它不应该在随意丢放。它可以用来代表其的所有者进行加密、解密和签名文件。</p>
<h3 id="证书文件（-crt）"><a href="#证书文件（-crt）" class="headerlink" title="证书文件（*.crt）"></a>证书文件（*.crt）</h3><p>这是个可以公开使用的公钥文件。证书文件只能用于对私有密钥所有者签名的文件进行加密或验证，因此可以广泛共享。在Openvpn上下文中，证书文件用于验证Openvpn服务器本身的身份以及连接客户端的标识。由于这引动证书是由我们信任的CA签署的，双方都会信任它。</p>
<h3 id="证书签名请求文件-csr"><a href="#证书签名请求文件-csr" class="headerlink" title="证书签名请求文件(*.csr)"></a>证书签名请求文件(*.csr)</h3><p>CA证书不需要客户端的私钥来生成，它需要来自客户端的CSR一完成，CSR由客户端签名，因此CA信任它是合法的请求并返回签名的证书文件。在购买SSL证书时，CSR的使用更为常见。在服务器上生成CSR，并将其提供给SSL供应商，然后它们将证书文件返回给您，然后将证书文件安装到服务器上。</p>
<h1 id="Linux环境下配置openvpn"><a href="#Linux环境下配置openvpn" class="headerlink" title="Linux环境下配置openvpn"></a>Linux环境下配置openvpn</h1><h2 id="ubuntu环境下安装OpenVPN"><a href="#ubuntu环境下安装OpenVPN" class="headerlink" title="ubuntu环境下安装OpenVPN"></a>ubuntu环境下安装OpenVPN</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install openvpn </span><br></pre></td></tr></table></figure>
<h3 id="生成服务器及客户端相关证书"><a href="#生成服务器及客户端相关证书" class="headerlink" title="生成服务器及客户端相关证书"></a>生成服务器及客户端相关证书</h3><p>为了安全起见，建议不要在服务器上安装easy-rsa密钥生成程序，因为我不希望我的密钥出现在服务器上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install easy-rsa</span><br><span class="line">$ /usr/bin/make-cadir CA</span><br></pre></td></tr></table></figure>
<p>OR</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/make-cadir CA</span><br></pre></td></tr></table></figure>

<p>设置vars文件，此文件包含我们制作证书所需要的默认值，将这些值设置在53，64～69行之间。<br><code>53 export KEY_SIZE=2048 64 export KEY_COUNTRY=&quot;CN&quot; 65 export KEY_PROVINCE=&quot;ZheJiang&quot; 66 export KEY_CITY=&quot;HangZhou&quot; 67 export KEY_ORG=&quot;A Li Ba Ba&quot; 68 export KEY_EMAIL=&quot;ca@ali.com&quot; 69 export KEY_OU=&quot;Inspections&quot;</code><br>接下来，下面的命令将在keys目录中生成CA证书和密钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ ~/CA ]$ <span class="built_in">source</span> ./vars</span><br><span class="line">NOTE: <span class="keyword">if</span> you run ./clean-all, I will be doing a <span class="built_in">rm</span> -rf on /CA/kyes </span><br><span class="line">[ ~/CA ]$ ./clean-all</span><br><span class="line">[ ~/CA ]$ ./build-ca</span><br></pre></td></tr></table></figure>
<p>执行后在keys文件夹中生成如下文件：<br><code>ca.crt    ca.key</code><br>现在创建服务器的密钥。虽然你希望接受输入密码的挑战，但这不是个好主意，因为如果输入密码，那每次服务器启动后都需要输入密码。除非服务器每次重启时都在那里。<br>你可以任意指定服务器的名称。访名称将用作生成的密钥、CRT和CSR文件的文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ ~/CA ]$ ./build-key-server server </span><br></pre></td></tr></table></figure>
<p>我们现在需要创建一些Diffie-Hellman数据。此数据用于生成临时密钥，该密钥将在Openvpn会话期间使用以创建完美的向前保密。你可以使用4096位，位数越高需要的时间越长。若要强制使用较长的键，请将vars文件的第53行更改为所需的密钥长度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./build-dh</span><br></pre></td></tr></table></figure>
<p>在计算中，entropy被定义为系统上可用的随机性的数量，这些随机性可以被需要随机数据的进程所利用。密码学是entropy的巨大消耗者。计算机系统从它们的环境中提取entropy，比轺鼠标移动、风扇噪音，以及任何自然界中适当的随机现象。空闲系统通常具有较少的可用entropy，因此密钥生成可能需要更长的时间。此外，entropy不是有限的。一个具有大量entropy的系统可能在创建多个密钥后“耗尽”，因此后续的密钥可能需要更长的时间来生成。在极端情况下，没有entropy或低entropy的系统实际上可以创建较不安全的密钥。</p>
<p>回顾一下：我们现在有两个我们需要的三件事。我们有一个带有签名密钥的CA设置，并且有一组服务器凭据（一个密钥和一个crt），并且证书由CA签名。那些，我只打算创建一组客户机凭证，但是您可以根据需要多次重新运行的构建命令，以创建尽可能多的客户机凭证。</p>
<p>此外，与服务器密钥不同，当用户希望连接时，他必须提供密码连接，这时可以在创建客户密钥的时候指定密码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ ~/CA ]$ ./build-key client</span><br></pre></td></tr></table></figure>
<p>现在我们在keys文件夹中生成的相关密钥文件，目录如下：<br><img src="/keys.png" alt="keys" title="keys"><br>服务器和客户端文件各生成三个文件，一个CRT文件，一个密钥文件和一个CSR文件。CA文件只有两种类型，一个CRT和一个密钥。这是因为CA签署了自已的证书，因此不需要生成CSR来请求它签署自己的证书。</p>
<p>由于CA签名的证书需要提供CSR，因此可以在隔离的系统上创建客户端和服务器密钥和CSR文件，然后仅向CA提交CSR以获得证书。这意味着客户端密钥不需要知道CA。但是easy-rsa就是这样，很简单。像这样的高级配置需要使用OpenSSL而不是简单的RSA脚本。</p>
<p>如果我们查看server.crt和client.crt文件的顶部，我们可以看到这些证书已经签名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ ~/CA/keys ]$ <span class="built_in">head</span> server.crt</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number: 1 (0x1)</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C=US, ST=RI, L=Quahog, O=Happy Go Lucky Toys, OU=Inspections, CN=Happy Go Lucky Toys CA/name=EasyRSA/emailAddress=ca@happygoluckytoys.com</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jun  5 12:26:04 2017 GMT</span><br><span class="line">            Not After : Jun  3 12:26:04 2027 GMT</span><br><span class="line">        Subject: C=US, ST=RI, L=Quahog, O=Happy Go Lucky Toys, OU=Inspections, CN=server/name=EasyRSA/emailAddress=noreply@happygoluckytoys.com</span><br></pre></td></tr></table></figure>
<p>最后一件事是生成用于将OpenVPN作为完美的前向保密的TLS密钥。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ ~/CA/keys ]$ openvpn --genkey --secret pfs.key </span><br></pre></td></tr></table></figure>
<p>以上生成了一个名这pfs密钥的密钥，该密钥将在客户端和服务器上都需要。回想一下，所有这些文件都驻留在本地系统上，而不是服务器上。为了使Openvpn服务器运行，我们需要将必要的文件传输到Openvpn服务器。Openvpn服务器只需要以下文件：</p>
<ul>
<li>dh2048.pem</li>
<li>server.key</li>
<li>serrer.crt</li>
<li>ca.crt</li>
<li>pfs.key</li>
</ul>
<h3 id="使用easy-rsa3-0证书认证"><a href="#使用easy-rsa3-0证书认证" class="headerlink" title="使用easy-rsa3.0证书认证"></a>使用easy-rsa3.0证书认证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install easy-rsa</span><br><span class="line">make-cadir CA</span><br><span class="line"><span class="built_in">cd</span> CA </span><br><span class="line">vi ./vars</span><br><span class="line">set_var EASYRSA_REQ_COUNTRY     <span class="string">&quot;US&quot;</span>          <span class="comment">#国家</span></span><br><span class="line">set_var EASYRSA_REQ_PROVINCE    <span class="string">&quot;California&quot;</span>    <span class="comment">#省</span></span><br><span class="line">set_var EASYRSA_REQ_CITY        <span class="string">&quot;Shanghai&quot;</span>       <span class="comment">#城市</span></span><br><span class="line">set_var EASYRSA_REQ_ORG <span class="string">&quot;Copyleft Certificate Co&quot;</span>    <span class="comment">#组织</span></span><br><span class="line">set_var EASYRSA_REQ_EMAIL       <span class="string">&quot;test@example.net&quot;</span>     <span class="comment">#邮箱</span></span><br><span class="line">set_var EASYRSA_REQ_OU          <span class="string">&quot;My Organizational Unit&quot;</span>    <span class="comment">#公司、组织</span></span><br><span class="line">./easyrsa init-pki</span><br></pre></td></tr></table></figure>
<h4 id="创建ca证书"><a href="#创建ca证书" class="headerlink" title="创建ca证书"></a>创建ca证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./easyrsa build-ca</span><br></pre></td></tr></table></figure>

<h4 id="创建服务器证书server-crt"><a href="#创建服务器证书server-crt" class="headerlink" title="创建服务器证书server.crt"></a>创建服务器证书server.crt</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./easyrsa gen-req server nopass</span><br><span class="line">./easyrsa sign server server <span class="comment"># 证书签名，第二个server为服务器证书名</span></span><br></pre></td></tr></table></figure>

<h4 id="创建dh证书"><a href="#创建dh证书" class="headerlink" title="创建dh证书"></a>创建dh证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./easyrsa gen-dh    </span><br></pre></td></tr></table></figure>
<h4 id="创建ta密钥"><a href="#创建ta密钥" class="headerlink" title="创建ta密钥"></a>创建ta密钥</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/OpenVPN</span><br><span class="line">openvpn --genkey --secret ta.key</span><br></pre></td></tr></table></figure>
<h4 id="创建客户端证书"><a href="#创建客户端证书" class="headerlink" title="创建客户端证书"></a>创建客户端证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./easyrsa gen-req client nopass</span><br><span class="line">./easyrsa import-req ./pki/reqs/client.req client <span class="comment">#导入req，clien为客户端名称</span></span><br><span class="line">./easyrsa sign client client <span class="comment"># 签名，第二个为客户证书名称</span></span><br></pre></td></tr></table></figure>





<h3 id="配置OpenVPN服务端"><a href="#配置OpenVPN服务端" class="headerlink" title="配置OpenVPN服务端"></a>配置OpenVPN服务端</h3><p>现在我们已经准备好了所有凭证文件，我们需要构建一个简单的Openvpn配置文件来告诉OpenVPN在哪里可以找到这些文件，并且还要指定一些需要运行的基本配置。将带有示例的服务器配置文件复制到Openvpn目录中并使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">cp</span> /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz /etc/openvpn &amp;&amp; sudo gunzip server.conf.gunzip</span><br></pre></td></tr></table></figure>
<p>查看配置文件的第78至80行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">75 # Any X509 key management system can be used.</span><br><span class="line">76 # OpenVPN can also use a PKCS #12 formatted key file</span><br><span class="line">77 # (see &quot;pkcs12&quot; directive in man page).</span><br><span class="line">78 ca ca.crt</span><br><span class="line">79 cert server.crt</span><br><span class="line">80 key server.key  # This file should be kept secret</span><br></pre></td></tr></table></figure>
<p>Diffle-Hellman文件的路径需要更正，下面是配置文件的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port 1194</span><br><span class="line">proto udp</span><br><span class="line">dev tun</span><br><span class="line">ca /etc/openvpn/keys/ca.crt</span><br><span class="line">cert /etc/openvpn/keys/server.crt</span><br><span class="line">key /etc/openvpn/keys/server.key <span class="comment"># This file should be kept secret</span></span><br><span class="line">dh /etc/openvpn/keys/dh2048.pem</span><br><span class="line">cipher AES-256-CBC</span><br><span class="line">auth SHA512</span><br><span class="line">server 10.8.0.0 255.255.255.0</span><br><span class="line">push <span class="string">&quot;redirect-gateway def1 bypass-dhcp&quot;</span></span><br><span class="line">push <span class="string">&quot;dhcp-option DNS 8.8.8.8&quot;</span></span><br><span class="line">push <span class="string">&quot;dhcp-option DNS 8.8.4.4&quot;</span></span><br><span class="line">ifconfig-pool-persist ipp.txt</span><br><span class="line">keepalive 10 120</span><br><span class="line">comp-lzo</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">status openvpn-status.log</span><br><span class="line">log-append  openvpn.log</span><br><span class="line">verb 3</span><br><span class="line">tls-server</span><br><span class="line">tls-auth /etc/openvpn/keys/pfs.key</span><br></pre></td></tr></table></figure>
<p>如果启动Openvpn有问题，可以将日志记录的详细信息从3增到6，以便得到更多的详细信息。以上配置足以允许Openvpn客户端连接到服务器，但是服务器还不能代理任何互联网的数据，为了允许这一点，请在服务器上输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE</span><br><span class="line">$ sudo <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>
<p>第一条命令允许客户端使用服务器作为Internet代理，它将客户端流量（网络10.8.0.x）呼由一服务器上的eth0网络接口上。eth0接口通常是广域网接口。<br>第二条命令是允许内核转转IPv4流量，这对于VPN来说是必需的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo openvpn server.conf  <span class="comment"># 开启Openvpn服务</span></span><br></pre></td></tr></table></figure>

<h3 id="配置OpenVPN客户端"><a href="#配置OpenVPN客户端" class="headerlink" title="配置OpenVPN客户端"></a>配置OpenVPN客户端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">client</span><br><span class="line">dev tun</span><br><span class="line">proto udp</span><br><span class="line">remote XXX.XXX.XXX.XXX 1194   </span><br><span class="line">ca ca.crt</span><br><span class="line">cert client.crt</span><br><span class="line">key client.key</span><br><span class="line">tls-version-min 1.2</span><br><span class="line">tls-cipher TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384:TLS-DHE-RSA-WITH-AES-256-CBC-SHA256</span><br><span class="line">cipher AES-256-CBC</span><br><span class="line">auth SHA512</span><br><span class="line">resolv-retry infinite</span><br><span class="line">auth-retry none</span><br><span class="line">nobind</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">ns-cert-type server</span><br><span class="line">comp-lzo</span><br><span class="line">verb 3</span><br><span class="line">tls-client</span><br><span class="line">tls-auth pfs.key</span><br></pre></td></tr></table></figure>
<h1 id="ubuntu下OpenVPN客户端配置教程"><a href="#ubuntu下OpenVPN客户端配置教程" class="headerlink" title="ubuntu下OpenVPN客户端配置教程"></a>ubuntu下OpenVPN客户端配置教程</h1><p>首先需要安装OpenVPN客户端。一般来说直接使用apt-get即可。执行如下命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ sudo apt-get install openvpn </span><br></pre></td></tr></table></figure>
<h2 id="配置OpenVPN客户端-1"><a href="#配置OpenVPN客户端-1" class="headerlink" title="配置OpenVPN客户端"></a>配置OpenVPN客户端</h2><p>作为客户端，OpenVPN并没有特定的配置文件，而是由服务器提供给出一个配置文件。对于认证，OpenVPN提供了两种认证方法：基于用户名&#x2F;密码的认证与SSL证书认证。用户名&#x2F;密码方式无法（或较难）限制一个账号同时连接多个客户端，而采用证书，则可保证同一证书同一时间只能有一个客户端连接。当然，这些都是由服务器决定的，不需要客户端进行选择。</p>
<p>将客户端配置文件放到&#x2F;etc&#x2F;openvpn&#x2F;中</p>
<h2 id="连接OpenVPN"><a href="#连接OpenVPN" class="headerlink" title="连接OpenVPN"></a>连接OpenVPN</h2><p>在配置好.ovpn文件后，执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openvpn /etc/openvpn/client.ovpn</span><br><span class="line">#后台连接</span><br><span class="line">openvpn /etc/openvpn/client.ovpn &gt; /dev/null &amp;</span><br></pre></td></tr></table></figure>


<h1 id="DD-WRT环境下配置openvpn"><a href="#DD-WRT环境下配置openvpn" class="headerlink" title="DD-WRT环境下配置openvpn"></a>DD-WRT环境下配置openvpn</h1><h2 id="基本设置–-gt-时间设置"><a href="#基本设置–-gt-时间设置" class="headerlink" title="基本设置–&gt;时间设置"></a>基本设置–&gt;时间设置</h2><p><img src="/dd-1.png" alt="Alt text" title="Optional title"></p>
<h2 id="为解决路由器重启时无可用时间问题在启动时加入如下代码"><a href="#为解决路由器重启时无可用时间问题在启动时加入如下代码" class="headerlink" title="为解决路由器重启时无可用时间问题在启动时加入如下代码"></a>为解决路由器重启时无可用时间问题在启动时加入如下代码</h2><ul>
<li>注意要保证网络通畅，可在路由器的SSH命令行或telnet命令行下ping一下地址是否通畅；</li>
<li>注意路由器的工作模式，如果本路由器正在控制您的Internet连接，选择网关模式。如果是网络中已经存在的另外一个路由器，选择路由模式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntpclient pool.ntp.org</span><br><span class="line">stopservice process_monitor</span><br><span class="line">startservice process_monitor</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="图形界面启用OpenVPN-Server"><a href="#图形界面启用OpenVPN-Server" class="headerlink" title="图形界面启用OpenVPN Server"></a>图形界面启用OpenVPN Server</h2><p>服务–&gt;VPN<br><img src="/dd-2.png" alt="Alt text" title="Optional title"><br><span style="font-weight: bolder;"></p>
<ol>
<li>OpenVPN : 启用</li>
<li>Start Type : WAN up</li>
<li>Config as : Server</li>
<li>Server mode : Router(TUN)</li>
<li>Network : 10.8.0.0</li>
<li>Netmask : 255.255.255.0</li>
<li>端口 ： 1194</li>
<li>通道协议 ： UDP</li>
<li>Encryption Cipher : AES-256 CBC</li>
<li>Hash Algorithm : SHA512</li>
<li>Advanced Options : 禁用</li>
<li>公共服务器端证书 : ca.crt</li>
<li>Public Server Cert : server.crt</li>
<li>Private Server Key : server.key </li>
<li>DH PEM : dh2048.pem</li>
<li>TLS Auth Key : ta.key</span></li>
<li>Additional Config:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push &quot;route 192.168.1.0 255.255.255.0&quot;</span><br><span class="line">push &quot;dhcp-option DNS 8.8.8.8&quot;</span><br><span class="line">push &quot;dhcp-option DNS 8.8.4.4&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h2><p>管理–&gt;命令–&gt;保存为防火墙指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT 1 -p tcp --dport 1194 -j ACCEPT</span><br><span class="line">iptables -I INPUT 1 -p udp --dport 1194 -j ACCEPT</span><br><span class="line">iptables -I FORWARD 1 --source 10.8.0.0/24 -j ACCEPT</span><br><span class="line">iptables -I FORWARD -i br0 -o tun2 -j ACCEPT</span><br><span class="line">iptables -I FORWARD -i tun2 -o br0 -j ACCEPT</span><br><span class="line">iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE</span><br></pre></td></tr></table></figure>

<h2 id="配置OpenVPN-Server自启动"><a href="#配置OpenVPN-Server自启动" class="headerlink" title="配置OpenVPN Server自启动"></a>配置OpenVPN Server自启动</h2><p>创建启动文件openvpn.startup</p>
<figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">killall -q openvpn</span><br><span class="line">/jffs/usr/sbin/openvpn --config /jffs/etc/openvpn/office.conf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>openvpn</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础52道题</title>
    <url>/2018/05/07/python%E4%BA%94%E5%8D%81%E4%BA%8C%E9%81%93/</url>
    <content><![CDATA[<h1 id="习题1"><a href="#习题1" class="headerlink" title="习题1"></a>习题1</h1><h2 id="文件名：ex1-py"><a href="#文件名：ex1-py" class="headerlink" title="文件名：ex1.py"></a>文件名：ex1.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Hello Again&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;I like typing this.&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;This is fun.&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Yay!Printing.&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;I&#x27;d much rather you &#x27;not&#x27;.&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;I &quot;said&quot; do not touch this.&#x27;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="你应该看到的结果："><a href="#你应该看到的结果：" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><img src="ex1.PNG"  title="[习题1]" />
# 习题2：注释和井号
## 文件名：ex2.py
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A comment, this is so you can ead your program later.</span></span><br><span class="line"><span class="comment"># Anything after  the # is ignore by python.</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;I could have code like this.&quot;</span></span><br><span class="line"><span class="comment"># and the comment after is ignore</span></span><br><span class="line"><span class="comment"># you can also use a comment to disable&quot;  or comment out a piece of code:</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;This will run.&quot;</span></span><br></pre></td></tr></table></figure>
## 你应该看到的结果：
<img src="ex2.PNG"  title="[习题2]" />

<h1 id="习题3：数字和数学计算"><a href="#习题3：数字和数学计算" class="headerlink" title="习题3：数字和数学计算"></a>习题3：数字和数学计算</h1><h2 id="文件名：ex3-py"><a href="#文件名：ex3-py" class="headerlink" title="文件名：ex3.py"></a>文件名：ex3.py</h2><div class="note primary"><ul>
<li>“+” 加号</li>
<li>“-“ 减号</li>
<li>“&#x2F;“ 斜杠</li>
<li>“*” 星号</li>
<li>“%” 百分号</li>
<li>“&lt;” 小于号</li>
<li>“&gt;” 大于号</li>
<li>“&lt;&#x3D;” 小于等于号</li>
<li>“&gt;&#x3D;” 大于等于号</li>
</ul>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;I will noew count my chickens:&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Hans&quot;</span>, <span class="number">25</span>+<span class="number">30</span>/<span class="number">6</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Roosters&quot;</span>, <span class="number">100</span>-<span class="number">25</span>*<span class="number">3</span>%<span class="number">4</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Now I will count the eggs:&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="number">3</span>+<span class="number">2</span>+<span class="number">1</span>-<span class="number">5</span>+<span class="number">4</span>%<span class="number">2</span>-<span class="number">1</span>/<span class="number">4</span>+<span class="number">6</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Is it true that 3+2&lt;5-7?&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="number">3</span>+<span class="number">2</span>&lt;<span class="number">5</span>-<span class="number">7</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;What is 3+2?&quot;</span>, <span class="number">3</span>+<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;what is 5-7?&quot;</span>, <span class="number">5</span>-<span class="number">7</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;How about some more.&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Is it greater?&quot;</span>, <span class="number">5</span>&gt;-<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Is it greater or equal?&quot;</span>,<span class="number">5</span>&gt;=-<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Is it less or equal?&quot;</span>, <span class="number">5</span>&lt;=-<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="你应该看到的结果：-1"><a href="#你应该看到的结果：-1" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><img src="ex3.PNG"  title="[习题3]" />

<h1 id="习题4：变量（variable）和命名"><a href="#习题4：变量（variable）和命名" class="headerlink" title="习题4：变量（variable）和命名"></a>习题4：变量（variable）和命名</h1><h2 id="文件名：ex4-py"><a href="#文件名：ex4-py" class="headerlink" title="文件名：ex4.py"></a>文件名：ex4.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line">cars = <span class="number">100</span></span><br><span class="line">space_in_a_car = <span class="number">4.0</span></span><br><span class="line">drivers = <span class="number">30</span></span><br><span class="line">passengers = <span class="number">90</span></span><br><span class="line">cars_not_driven = cars - drivers</span><br><span class="line">cars_driven = drivers</span><br><span class="line">carpool_capacity = cars_driven * space_in_a_car</span><br><span class="line">average_passengers_per_car = passengers / cars_driven</span><br><span class="line"><span class="comment">#有100辆车可用</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;There are &quot;</span>, cars, <span class="string">&quot; cars available.&quot;</span></span><br><span class="line"><span class="comment">#仅有30名驾驶员</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;There are only &quot;</span>, drivers, <span class="string">&quot;drivers available.&quot;</span></span><br><span class="line"><span class="comment">#今天将有70辆车没有驾驶员</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;There will be&quot;</span>, cars_not_driven, <span class="string">&quot;empty cars tody.&quot;</span></span><br><span class="line"><span class="comment">#今天可以运送120人</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;We can transport&quot;</span>, carpool_capacity, <span class="string">&quot;people today.&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;We have&quot;</span>,passengers, <span class="string">&quot;to carpool today.&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;We need to put about&quot;</span>, average_passengers_per_car, <span class="string">&quot;in each car.&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="你应该看到的结果：-2"><a href="#你应该看到的结果：-2" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><img src="ex4.PNG"  title="[习题4]" />

<h1 id="习题5：更多的变量和打印"><a href="#习题5：更多的变量和打印" class="headerlink" title="习题5：更多的变量和打印"></a>习题5：更多的变量和打印</h1><h2 id="文件名：ex5-py"><a href="#文件名：ex5-py" class="headerlink" title="文件名：ex5.py"></a>文件名：ex5.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_name = <span class="string">&#x27;Zed A. Shaw&#x27;</span></span><br><span class="line">my_age = <span class="number">35</span> <span class="comment"># not a lie</span></span><br><span class="line">my_height = <span class="number">74</span> <span class="comment"># inches</span></span><br><span class="line">my_weight = <span class="number">180</span> <span class="comment"># lbs</span></span><br><span class="line">my_eyes = <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">my_teeth = <span class="string">&#x27;White&#x27;</span></span><br><span class="line">my_hair = <span class="string">&#x27;Brown&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Let&#x27;s talk about %s.&quot;</span>% my_name</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;He&#x27;s %d inches tall.&quot;</span>% my_height</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;He&#x27;s %d pounds heavy.&quot;</span>% my_weight</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Actually that&#x27;s not too heavy.&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;He&#x27;s got %s eyes and %s hair.&quot;</span>%(my_eyes,my_hair)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;His teeth are usually %s depending no the coffee.&quot;</span> %my_teeth</span><br><span class="line"><span class="comment"># this line is tricky, try to get it exactly right </span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;if I add %d,%d,and %d I get %d.&quot;</span>%(my_age, my_height, my_weight, my_age+my_height+my_weight)</span><br></pre></td></tr></table></figure>
<h2 id="你应该看到的结果：-3"><a href="#你应该看到的结果：-3" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><img src="ex5.PNG"  title="[习题5]" />

<h1 id="习题6：字符串（string）和文本"><a href="#习题6：字符串（string）和文本" class="headerlink" title="习题6：字符串（string）和文本"></a>习题6：字符串（string）和文本</h1><h2 id="文件名：ex6-py"><a href="#文件名：ex6-py" class="headerlink" title="文件名：ex6.py"></a>文件名：ex6.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&quot;There are %d types of people.&quot;</span> % <span class="number">10</span></span><br><span class="line">binary = <span class="string">&quot;binary&quot;</span></span><br><span class="line">do_not = <span class="string">&quot;don&#x27;t&quot;</span></span><br><span class="line">y = <span class="string">&quot;Those who know %s and those who %s.&quot;</span> % （binary,do_not）</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> x</span><br><span class="line"><span class="built_in">print</span> y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;I said:%r.&quot;</span> % x</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;I also said:&#x27;%s&#x27;.&quot;</span> % y </span><br></pre></td></tr></table></figure>
<h2 id="你应该看到的结果：-4"><a href="#你应该看到的结果：-4" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><img src="ex6.PNG"  title="[习题6]" />

<h1 id="习题7：更多打印"><a href="#习题7：更多打印" class="headerlink" title="习题7：更多打印"></a>习题7：更多打印</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;Mary had a little lamb.&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Its fleece was white as %s.&quot;</span> % <span class="string">&#x27;snow&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;And everywhere that Mary went.&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;.&quot;</span> * <span class="number">10</span> <span class="comment"># what&#x27;d that do?</span></span><br><span class="line"></span><br><span class="line">end1 = <span class="string">&quot;C&quot;</span></span><br><span class="line">end2 = <span class="string">&quot;h&quot;</span></span><br><span class="line">end3 = <span class="string">&quot;e&quot;</span></span><br><span class="line">end4 = <span class="string">&quot;e&quot;</span></span><br><span class="line">end5 = <span class="string">&quot;s&quot;</span></span><br><span class="line">end6 = <span class="string">&quot;e&quot;</span></span><br><span class="line">end7 = <span class="string">&quot;B&quot;</span></span><br><span class="line">end8 = <span class="string">&quot;u&quot;</span></span><br><span class="line">end9 = <span class="string">&quot;r&quot;</span></span><br><span class="line">end10 = <span class="string">&quot;g&quot;</span></span><br><span class="line">end11 = <span class="string">&quot;e&quot;</span></span><br><span class="line">end12 = <span class="string">&quot;r&quot;</span></span><br><span class="line"><span class="comment"># watch that comma at the end. try removing it to see what happens</span></span><br><span class="line"><span class="built_in">print</span> end1 + end2 + end3 + end4 + end5 + end6, </span><br><span class="line"><span class="built_in">print</span> end7 + end8 + end9 + end10 + end11 + end12</span><br></pre></td></tr></table></figure>
<h2 id="你应该看到的结果：-5"><a href="#你应该看到的结果：-5" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><img src="ex7.PNG"  title="[习题7]" />

<h1 id="习题8：打印，打印"><a href="#习题8：打印，打印" class="headerlink" title="习题8：打印，打印"></a>习题8：打印，打印</h1><h2 id="文件名：ex8-py"><a href="#文件名：ex8-py" class="headerlink" title="文件名：ex8.py"></a>文件名：ex8.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">formatter = <span class="string">&quot;%r %r %r %r&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> formatter % (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span> formatter % (<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> formatter % (<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span> formatter % (formatter, formatter, formatter, formatter)</span><br><span class="line"><span class="built_in">print</span> formatter % (<span class="string">&quot;I had this thing.&quot;</span>, <span class="string">&quot;That you could type up right.&quot;</span>, <span class="string">&quot;But it didn&#x27;t sing.&quot;</span>, <span class="string">&quot;So I said goodnight.&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="你应该看到的结果：-6"><a href="#你应该看到的结果：-6" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><img src="ex8.PNG"  title="[习题8]" />

<h1 id="习题9：打印，打印，打印"><a href="#习题9：打印，打印，打印" class="headerlink" title="习题9：打印，打印，打印"></a>习题9：打印，打印，打印</h1><h2 id="文件名：ex9-py"><a href="#文件名：ex9-py" class="headerlink" title="文件名：ex9.py"></a>文件名：ex9.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Here&#x27;s some new strange stuff, remember type it exactly.</span></span><br><span class="line">days = <span class="string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span></span><br><span class="line">months = <span class="string">&quot;Jan\nFeb\nMar\nApr\nMay\nJun\nJul\nAug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Here are the days:&quot;</span>, days</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Here are the months:&quot;</span>, months</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">There&#x27;s something foning on here.</span></span><br><span class="line"><span class="string">With the three double-quotes.</span></span><br><span class="line"><span class="string">We&#x27;ll be able to type as much as we like.</span></span><br><span class="line"><span class="string">Even 4 lines if we want, or 5, or 6.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="你应该看到的结果：-7"><a href="#你应该看到的结果：-7" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><img src="ex9.PNG"  title="[习题9]" />

<h1 id="习题10：那是什么？"><a href="#习题10：那是什么？" class="headerlink" title="习题10：那是什么？"></a>习题10：那是什么？</h1><h2 id="文件名-ex10-py"><a href="#文件名-ex10-py" class="headerlink" title="文件名:ex10.py"></a>文件名:ex10.py</h2><div class="note primary"><ul>
<li>“\n”：在该位置上放入一个新行字符</li>
<li>“\“：打印出一个反斜杠</li>
</ul>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tabby_cat = <span class="string">&quot;\tI&#x27;m tabbed in.&quot;</span></span><br><span class="line">persian_cat = <span class="string">&quot;I&#x27;m split\non a line.&quot;</span></span><br><span class="line">backslash_cat =  <span class="string">&quot;I&#x27;m \\ a \\ cat.&quot;</span></span><br><span class="line"></span><br><span class="line">fat_cat = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">I&#x27;ll do a list:</span></span><br><span class="line"><span class="string">\t* Cat food</span></span><br><span class="line"><span class="string">\t* Fishies</span></span><br><span class="line"><span class="string">\t* Catnip\n\t* Grass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> tabby_cat</span><br><span class="line"><span class="built_in">print</span> persian_cat</span><br><span class="line"><span class="built_in">print</span> backslash_cat</span><br><span class="line"><span class="built_in">print</span> fat_cat</span><br></pre></td></tr></table></figure>
<h2 id="你应该看到的结果：-8"><a href="#你应该看到的结果：-8" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><img src="ex10.PNG"  title="[习题10]" />

<h1 id="习题11：提问"><a href="#习题11：提问" class="headerlink" title="习题11：提问"></a>习题11：提问</h1><h2 id="文件名：ex11-py"><a href="#文件名：ex11-py" class="headerlink" title="文件名：ex11.py"></a>文件名：ex11.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;How old are you?&quot;</span>,</span><br><span class="line">age = raw_input()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;How tall are you?&quot;</span>,</span><br><span class="line">height = raw_input()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;How much do you weight?&quot;</span>,</span><br><span class="line">weight = raw_input()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;So, you&#x27;re %r old, %r tall and %r heavy.&quot;</span> % (age,height,weight)</span><br></pre></td></tr></table></figure>

<div class="note primary"><p>注意到在每行print后面加了一个逗号？这样的话print就不会输出新行符而结束这一行跑到下一行去了。</p>
</div>
<h2 id="你应该看到的结果：-9"><a href="#你应该看到的结果：-9" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><img src="ex11.PNG"  title="[习题11]" />

<h1 id="习题12：提示别人"><a href="#习题12：提示别人" class="headerlink" title="习题12：提示别人"></a>习题12：提示别人</h1><h2 id="文件名：ex12-ppy"><a href="#文件名：ex12-ppy" class="headerlink" title="文件名：ex12.ppy"></a>文件名：ex12.ppy</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = raw_input(<span class="string">&quot;How old are you?&quot;</span>)</span><br><span class="line">height = raw_input(<span class="string">&quot;How tall are you?&quot;</span>)</span><br><span class="line">weight = raw_input(<span class="string">&quot;How much do you weigh?&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;So, you&#x27;re %r old, %r tall and %r heavy.&quot;</span> % (age,height,weight)</span><br></pre></td></tr></table></figure>
<h2 id="你应该看到的结果：-10"><a href="#你应该看到的结果：-10" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><img src="ex12.PNG"  title="[习题12]" />

<h1 id="习题13：参数、解包、变量"><a href="#习题13：参数、解包、变量" class="headerlink" title="习题13：参数、解包、变量"></a>习题13：参数、解包、变量</h1><h2 id="文件名：ex13-py"><a href="#文件名：ex13-py" class="headerlink" title="文件名：ex13.py"></a>文件名：ex13.py</h2><p>在这个练习中我们讲到另外一种将变量传递给脚本的方法，我们现在要做的就是写一个可以接受参数的脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line">script, first, second, third = argv</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;The script is called:&quot;</span>, script</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Your first variable is:&quot;</span>, first</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Your second variable is:&quot;</span>, second</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Your third variable is:&quot;</span>, third</span><br></pre></td></tr></table></figure>
<p>‘argv’是所谓的参数变量，这个变量包含了你传递给Python的参数。第3行将<code>argv</code>解包，与其将所有参数放到同一个变量下面，我们将每个参数赋予一个变量名：script, frist, second以及third，这也许看上去有些奇怪，不过解包可能是最好的描述方式了。包的含义很简单：“就是把argv中的东西解包，将所有的参数依次赋予左边的变量名”。<br>我们把导入（import）进来的功能叫做模组。你将看到类似这样的说法：“你需要把sys模组import进来。”也有人将它们称作“库（libraries）”</p>
<h2 id="你应该看到的结果：-11"><a href="#你应该看到的结果：-11" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><p>用下面的方法运行你的程序（注意你必须传递3个参数）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python ex13.py first 2nd 3rd</span><br></pre></td></tr></table></figure>
<img src="ex13.PNG"  title="[习题13]" />

<h1 id="习题14：提示和传递"><a href="#习题14：提示和传递" class="headerlink" title="习题14：提示和传递"></a>习题14：提示和传递</h1><h2 id="文件名：ex14-py"><a href="#文件名：ex14-py" class="headerlink" title="文件名：ex14.py"></a>文件名：ex14.py</h2><p>让我们使用argv和raw_input一起来向用户提一些特别的问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line">script, user_name = argv</span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Hi %s, I&#x27;m the %s script.&quot;</span> % (user_name, script)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;I&#x27;d like to ask you a few questions.&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Do you like me %s?&quot;</span> % user_name</span><br><span class="line">likes = raw_input(prompt)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Where do you live %s?&quot;</span> % user_name</span><br><span class="line">lives = raw_input(prompt)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;What kind of computer do you have?&quot;</span></span><br><span class="line">computer = raw_input(prompt)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Alright, so you said %r about liking me.</span></span><br><span class="line"><span class="string">You live in %r. Not sure where that is.</span></span><br><span class="line"><span class="string">And you have a %r computer. Nice.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span> % (likes, lives, computer)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="你应该看到的结果：-12"><a href="#你应该看到的结果：-12" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><p>用下面的方法运行你的程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python ex14.py Zed</span><br></pre></td></tr></table></figure>
<img src="ex14.PNG"  title="[习题14]" />

<h1 id="习题15：读取文件"><a href="#习题15：读取文件" class="headerlink" title="习题15：读取文件"></a>习题15：读取文件</h1><h2 id="文件名：ex15-py"><a href="#文件名：ex15-py" class="headerlink" title="文件名：ex15.py"></a>文件名：ex15.py</h2><p>这节练习涉及到写两个文件。一个正常的ex15.py，另外一个是ex15_sample.txt，第二个文件并不是脚本，而是供你的脚本讯取的文本文件。以下是后者的内容：<br><img src="ex15_sample.PNG"  /><br>我们要做的就是把该文件用我们的脚本“打开（open）”，然后打印出来。然而把文件名ex15_sample.txt写死（hardcode）在代码中不是一个好主意，这些信息应该是用户输入的才对。如果我们碰到其他文件要处理，写死的文件名就会给你带来麻烦了。我们的解决方案是使用argv和raw_input来从用户获取信息，从而知道哪些文件该被处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line">script,filename = argv</span><br><span class="line">txt = <span class="built_in">open</span>(filename)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Here&#x27;s your file %r:&quot;</span> % filename</span><br><span class="line"><span class="built_in">print</span> txt.read()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Type the filename again:&quot;</span></span><br><span class="line">file_again = raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">txt_again = <span class="built_in">open</span>(file_again)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> txt_again.read()</span><br></pre></td></tr></table></figure>
<h2 id="你应该看到的结果：-13"><a href="#你应该看到的结果：-13" class="headerlink" title="你应该看到的结果："></a>你应该看到的结果：</h2><p>用下面的方法运行你的程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python ex15.py ex15_sample.txt</span><br></pre></td></tr></table></figure>
<img src="ex15.PNG"  title="[习题15]" />

<h1 id="习题16：读写文件"><a href="#习题16：读写文件" class="headerlink" title="习题16：读写文件"></a>习题16：读写文件</h1><h2 id="文件名：-ex16-py"><a href="#文件名：-ex16-py" class="headerlink" title="文件名： ex16.py"></a>文件名： ex16.py</h2><div class="note primary"><ul>
<li>close - 关闭文件。跟你用编辑器的文件–&gt;保存一个意思</li>
<li>read - 读取文件内容。你可以把结果赋给一个变量</li>
<li>readline - 读取文本文件中的一行</li>
<li>truncate - 清空文件，请小心使用该命令</li>
<li>write(stuff) - 将stuff写入文件</li>
</ul>
</div>
<p><code>write</code>需要接收一个字符串作为参数，从而将该字符串写入文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line">script, filename = argv</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;We&#x27;re going to erase %r.&quot;</span> % filename</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;If you don&#x27;t want that, hit CTRL-C（^C）.&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;If you do want that, hit RETURN.&quot;</span></span><br><span class="line"></span><br><span class="line">raw_input(<span class="string">&quot;?&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Opening the file...&quot;</span></span><br><span class="line">target = <span class="built_in">open</span>(filename,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Truncating the file. Goodbye!&quot;</span></span><br><span class="line">target.truncate()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Now I&#x27;m going to ask you for three lines.&quot;</span></span><br><span class="line"></span><br><span class="line">line1 = raw_input(<span class="string">&quot;line 1:&quot;</span>)</span><br><span class="line">line2 = raw_input(<span class="string">&quot;line 2:&quot;</span>)</span><br><span class="line">line3 = raw_input(<span class="string">&quot;line 3:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;I&#x27;m going to write these to the file.&quot;</span></span><br><span class="line"></span><br><span class="line">target.write(line1)</span><br><span class="line">target.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">target.write(line2)</span><br><span class="line">target.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">target.write(line3)</span><br><span class="line">target.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;And finally, we close it.&quot;</span></span><br><span class="line">target.close()</span><br></pre></td></tr></table></figure>
<h2 id="用下面的方法运行你的程序"><a href="#用下面的方法运行你的程序" class="headerlink" title="用下面的方法运行你的程序"></a>用下面的方法运行你的程序</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python ex16.py ex15_sample.txt</span><br></pre></td></tr></table></figure>
<img src="ex16.PNG"  title="[习题16]" />

<h1 id="习题17：更多文件操作"><a href="#习题17：更多文件操作" class="headerlink" title="习题17：更多文件操作"></a>习题17：更多文件操作</h1><h2 id="文件名：ex17-py"><a href="#文件名：ex17-py" class="headerlink" title="文件名：ex17.py"></a>文件名：ex17.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> exists</span><br><span class="line"></span><br><span class="line">script, from_file, to_file = argv</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Copying from %s to %s&quot;</span> % (from_file,to_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we could do these two on one line too, how?</span></span><br><span class="line"><span class="built_in">input</span> = <span class="built_in">open</span>(from_file)</span><br><span class="line">indata = <span class="built_in">input</span>.read()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;The input file is %d bytes long&quot;</span> % <span class="built_in">len</span>(indata)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Does the output file exist? %r&quot;</span> % exists(to_file)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Ready, hit RETURN to continue, CTRL-C to abort.&quot;</span></span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line">output = <span class="built_in">open</span>(to_file,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">output.write(indata)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Alright, all done.&quot;</span></span><br><span class="line"></span><br><span class="line">output.close()</span><br><span class="line"><span class="built_in">input</span>.close()</span><br></pre></td></tr></table></figure>

<h2 id="用下面的方法运行你的程序-1"><a href="#用下面的方法运行你的程序-1" class="headerlink" title="用下面的方法运行你的程序"></a>用下面的方法运行你的程序</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python ex17.py ex15_sample.txt ex17_sample.txt</span><br></pre></td></tr></table></figure>
<img src="ex17.PNG"  title="[习题17]" />

<h1 id="习题18：命名、变量、代码、函数"><a href="#习题18：命名、变量、代码、函数" class="headerlink" title="习题18：命名、变量、代码、函数"></a>习题18：命名、变量、代码、函数</h1><h2 id="文件名：ex18-py"><a href="#文件名：ex18-py" class="headerlink" title="文件名：ex18.py"></a>文件名：ex18.py</h2><p>函数可以做三样事情：</p>
<ol>
<li>它们给代码片段命名，就跟“变量”给字符串和数字命名一样。</li>
<li>它们可以接受参数，就跟你的脚本接受argv一样</li>
<li>通过#1和#2，它们可以让你创建“微型脚本”或者“小命令”</li>
</ol>
<p>你可以使用def新建函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># this one is like your scripts with argv</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_two</span>(<span class="params">*args</span>):</span><br><span class="line">    arg1, arg2 = args</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;arg1: %r, arg2: %r&quot;</span> % (arg1,arg2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok, that *args is actually pointless, we can just do this </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_two_again</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;arg1: %r, arg2: %r&quot;</span> % (arg1, arg2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this just takes one argument</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_one</span>(<span class="params">arg1</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;arg1: %r&quot;</span> % arg1</span><br><span class="line"></span><br><span class="line"><span class="comment"># this one takes on arguments</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_none</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;I got nothin.&quot;</span></span><br><span class="line"></span><br><span class="line">print_two(<span class="string">&quot;Zed&quot;</span>,<span class="string">&quot;Shaw&quot;</span>)</span><br><span class="line">print_two_again(<span class="string">&quot;Zed&quot;</span>,<span class="string">&quot;Shaw&quot;</span>)</span><br><span class="line">print_one(<span class="string">&quot;First!&quot;</span>)</span><br><span class="line">print_none()</span><br></pre></td></tr></table></figure>

<ol>
<li>首先我们告诉Python创建一个函数，我们使用到的命令是def，也就是“定义（define）”的意思。</li>
<li>紧接着def的是函数的名称。本例中它的名称是“print_two”，但名字可以随便取。</li>
<li>然后告诉函数我们需要<code>*args(asterisk args)</code>，这和脚本argv非常相似，参数必须放在圆括号<code>（）</code>中才能正常工作</li>
<li>接着用冒号<code>:</code>结束本行，然后开始下一行缩进</li>
<li>冒号以下，使用4个空格缩进的行都是属于<code>print_two</code>这个函数的内容。其中第一行的作用是将参数解包，这和脚本参数解包的原理差不多。</li>
<li>为了演示它的工作原理，我们把解包后的每个参数都打印出来，这和我们在这前脚本练习中所作的类似</li>
</ol>
<h2 id="用下面的方法运行你的程序-2"><a href="#用下面的方法运行你的程序-2" class="headerlink" title="用下面的方法运行你的程序"></a>用下面的方法运行你的程序</h2><img src="ex18.PNG"  title="[习题18]" />

<h1 id="习题19：函数和变量"><a href="#习题19：函数和变量" class="headerlink" title="习题19：函数和变量"></a>习题19：函数和变量</h1><h2 id="文件名：ex19-py"><a href="#文件名：ex19-py" class="headerlink" title="文件名：ex19.py"></a>文件名：ex19.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cheese_and_crackers</span>(<span class="params">cheese_count, boxes_of_crackers</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;You have %d cheeses!&quot;</span> % cheese_count</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;You have %d boxes of crackers!&quot;</span> % boxes_of_crackers</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Man that&#x27;s enough for a party!&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Get a blanket.\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;We can just give the function numbers directly:&quot;</span></span><br><span class="line">cheese_and_crackers(<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;OR, we can use variables from our script:&quot;</span></span><br><span class="line">amount_of_cheese = <span class="number">10</span></span><br><span class="line">amount_of_crackers = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">cheese_and_crackers(amount_of_cheese, amount_of_crackers)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;We can even do math inside too:&quot;</span></span><br><span class="line">cheese_and_crackers(<span class="number">10</span>+<span class="number">20</span>,<span class="number">5</span>+<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;And we can combine the two, variables and math:&quot;</span></span><br><span class="line">cheese_and_crackers(amount_of_cheese + <span class="number">100</span>, amount_of_crackers + <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="用下面的方法运行你的程序-3"><a href="#用下面的方法运行你的程序-3" class="headerlink" title="用下面的方法运行你的程序"></a>用下面的方法运行你的程序</h2><img src="ex19.PNG"  title="[习题19]" />

<h1 id="习题20：函数和文件"><a href="#习题20：函数和文件" class="headerlink" title="习题20：函数和文件"></a>习题20：函数和文件</h1><h2 id="文件名：ex20-py"><a href="#文件名：ex20-py" class="headerlink" title="文件名：ex20.py"></a>文件名：ex20.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line">script, input_file = argv</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_all</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="built_in">print</span> f.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewind</span>(<span class="params">f</span>):</span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_a_line</span>(<span class="params">line_count, f</span>):</span><br><span class="line">    <span class="built_in">print</span> line_count, f.readline()</span><br><span class="line"></span><br><span class="line">current_file = <span class="built_in">open</span>(input_file)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;First let&#x27;s print the whole file:\n&quot;</span></span><br><span class="line"></span><br><span class="line">print_all(current_file)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Now let&#x27;s rewind, kind of like a tape.&quot;</span></span><br><span class="line">rewind(current_file)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Let&#x27;s print three lines:&quot;</span></span><br><span class="line"></span><br><span class="line">current_line =<span class="number">1</span></span><br><span class="line">print_a_line(current_line, current_file)</span><br><span class="line">current_line = current_line + <span class="number">1</span></span><br><span class="line">print_a_line(current_line, current_file)</span><br></pre></td></tr></table></figure>
<h2 id="用下面的方法运行你的程序-4"><a href="#用下面的方法运行你的程序-4" class="headerlink" title="用下面的方法运行你的程序"></a>用下面的方法运行你的程序</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python ex20.py test.txt</span><br></pre></td></tr></table></figure>
<img src="ex20.PNG"  title="[习题20]" />

<h1 id="习题21：函数可以返回东西"><a href="#习题21：函数可以返回东西" class="headerlink" title="习题21：函数可以返回东西"></a>习题21：函数可以返回东西</h1><h2 id="文件名：ex21-py"><a href="#文件名：ex21-py" class="headerlink" title="文件名：ex21.py"></a>文件名：ex21.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ADDING %d + %d&quot;</span> % (a, b)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subtract</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;SUBTRACTING %d - %d&quot;</span> % (a, b)</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;MULTIPLYING %d * %d&quot;</span> % (a,b)</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;DIVIDING %d / %d&quot;</span> % (a,b)</span><br><span class="line">    <span class="keyword">return</span> a/b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Let&#x27;s do some math with just functions!&quot;</span></span><br><span class="line">age = add(<span class="number">30</span>,<span class="number">5</span>)</span><br><span class="line">height = subtract(<span class="number">78</span>,<span class="number">4</span>)</span><br><span class="line">weight = multiply(<span class="number">90</span>,<span class="number">2</span>)</span><br><span class="line">iq = divide(<span class="number">100</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Age:%d, Height:%d, Weight:%d, IQ:%d&quot;</span> % (age, height, weight, iq)</span><br><span class="line"><span class="comment"># A puzzle for the extra credit, type it in anyway.</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Here is a puzzle.&quot;</span></span><br><span class="line">what = add(age,subtract(height,multiply(weight,divide(iq,<span class="number">2</span>))))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;That becomes:&quot;</span>, what, <span class="string">&quot;Can you do it by hand?&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="用下面的方法运行你的程序-5"><a href="#用下面的方法运行你的程序-5" class="headerlink" title="用下面的方法运行你的程序"></a>用下面的方法运行你的程序</h2><img src="ex21.PNG"  title="[习题21]" />

<h1 id="习题24：更多练习"><a href="#习题24：更多练习" class="headerlink" title="习题24：更多练习"></a>习题24：更多练习</h1><h2 id="文件名：ex24-py"><a href="#文件名：ex24-py" class="headerlink" title="文件名：ex24.py"></a>文件名：ex24.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;Let&#x27;s practice everything.&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;You\&#x27;d need to know \&#x27;bout escapes with \\ that do \n newlines and \t tabs.&#x27;</span></span><br><span class="line"></span><br><span class="line">poem = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">\tThe lovely world</span></span><br><span class="line"><span class="string">with logic so firmly planted</span></span><br><span class="line"><span class="string">cannot discern \n the needs of love</span></span><br><span class="line"><span class="string">nor comprehend passion from intuition</span></span><br><span class="line"><span class="string">and requires an explanation</span></span><br><span class="line"><span class="string">\n\t\twhere there is none.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;--------------&quot;</span></span><br><span class="line"><span class="built_in">print</span> poem</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;--------------&quot;</span></span><br><span class="line"></span><br><span class="line">five = <span class="number">10</span> - <span class="number">2</span> + <span class="number">3</span> - <span class="number">6</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;This should be five:%s&quot;</span> % five</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">secret_formula</span>(<span class="params">started</span>):</span><br><span class="line">    jelly_beans = started * <span class="number">500</span></span><br><span class="line">    jars = jelly_beans / <span class="number">1000</span></span><br><span class="line">    crates = jars /<span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> jelly_beans, jars, crates</span><br><span class="line"></span><br><span class="line">start_point = <span class="number">10000</span></span><br><span class="line">beans, jars, crates = secret_formula(start_point)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;With a starting point of:%d&quot;</span> % start_point</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;We&#x27;d have %d beans, %d jars, and %d crates.&quot;</span> % (beans, jars, crates)</span><br><span class="line"></span><br><span class="line">start_point = start_point / <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;We can also do that this way:&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;We&#x27;d have %d beans, %d jars, and %d crates.&quot;</span> % secret_formula(start_point)</span><br></pre></td></tr></table></figure>
<h2 id="用下面的方法运行你的程序-6"><a href="#用下面的方法运行你的程序-6" class="headerlink" title="用下面的方法运行你的程序"></a>用下面的方法运行你的程序</h2><img src="ex24.PNG"  title="[习题24]" />

<h1 id="习题25：更多更多的练习"><a href="#习题25：更多更多的练习" class="headerlink" title="习题25：更多更多的练习"></a>习题25：更多更多的练习</h1><h2 id="文件名：ex25-py"><a href="#文件名：ex25-py" class="headerlink" title="文件名：ex25.py"></a>文件名：ex25.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">break_words</span>(<span class="params">stuff</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This function will break up words for us.&quot;&quot;&quot;</span></span><br><span class="line">    words = stuff.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sort_words</span>(<span class="params">words</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Sorts the words.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(words)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_first_word</span>(<span class="params">words</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Prints the first word after popping it off.&quot;&quot;&quot;</span></span><br><span class="line">    word = words.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_last_word</span>(<span class="params">words</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Prints the last word after popping it off.&quot;&quot;&quot;</span></span><br><span class="line">    word = words.pop(-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sort_sentence</span>(<span class="params">sentence</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Takes in a full sentence and returns the sorted words.&quot;&quot;&quot;</span></span><br><span class="line">    words = break_words(setence)</span><br><span class="line">    <span class="keyword">return</span> sort_words(words)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_first_and_last</span>(<span class="params">sentence</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Prints the first and last words of the sentenct.&quot;&quot;&quot;</span></span><br><span class="line">    words = break_words(sentenct)</span><br><span class="line">    print_first_word(words)</span><br><span class="line">    print_last_word(words)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_first_and_last_sorted</span>(<span class="params">sentenct</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Sorts the words then prints the first and last one.&quot;&quot;&quot;</span></span><br><span class="line">    words =  sort_sentence(sentence)</span><br><span class="line">    print_first_word(words)</span><br><span class="line">    print_last_word(words)</span><br></pre></td></tr></table></figure>
<h1 id="习题27：记住逻辑关系"><a href="#习题27：记住逻辑关系" class="headerlink" title="习题27：记住逻辑关系"></a>习题27：记住逻辑关系</h1><h2 id="文件名：ex27-py"><a href="#文件名：ex27-py" class="headerlink" title="文件名：ex27.py"></a>文件名：ex27.py</h2><div class="note primary"><ul>
<li><code>and</code> 与</li>
<li><code>or</code> 或</li>
<li><code>not</code> 非</li>
<li><code>!=</code> 不等于</li>
<li><code>==</code> 等于</li>
<li><code>&gt;=</code> 大于等于</li>
<li><code>&lt;=</code> 小于等于</li>
<li><code>True</code> 真</li>
<li><code>False</code> 假</li>
</ul>
</div>

<h1 id="习题29：如果if"><a href="#习题29：如果if" class="headerlink" title="习题29：如果if"></a>习题29：如果if</h1><h2 id="文件名：ex29-py"><a href="#文件名：ex29-py" class="headerlink" title="文件名：ex29.py"></a>文件名：ex29.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">people = <span class="number">20</span></span><br><span class="line">cats = <span class="number">30</span></span><br><span class="line">dogs = <span class="number">15</span></span><br><span class="line"><span class="keyword">if</span> people &lt; cats:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Too many cats! The world is doomed!&quot;</span></span><br><span class="line"><span class="keyword">if</span> people &gt; cats:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Not many cats! The world is saved!&quot;</span></span><br><span class="line"><span class="keyword">if</span> people &lt; dogs:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;The world is drooled on!&quot;</span></span><br><span class="line"><span class="keyword">if</span> people &gt; dogs:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;The world is dry!&quot;</span></span><br><span class="line">dogs +=<span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> people &gt;= dogs:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;People are greater than or equal to dogs.&quot;</span></span><br><span class="line"><span class="keyword">if</span> people &lt;= dogs:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;People are less than or equal to dags.&quot;</span></span><br><span class="line"><span class="keyword">if</span> people == dogs:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;People are dogs.&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="习题30：Else-和-if"><a href="#习题30：Else-和-if" class="headerlink" title="习题30：Else 和 if"></a>习题30：Else 和 if</h1><h2 id="文件名：ex30-py"><a href="#文件名：ex30-py" class="headerlink" title="文件名：ex30.py"></a>文件名：ex30.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">people = <span class="number">30</span></span><br><span class="line">cars = <span class="number">40</span></span><br><span class="line">buses = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cars &gt; people:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;We should take the cars.&quot;</span></span><br><span class="line"><span class="keyword">elif</span> cars &gt; people:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;We should not take the cars.&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;We can&#x27;t decide.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> buses &gt; cars:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;That&#x27;s too many buses.&quot;</span></span><br><span class="line"><span class="keyword">elif</span> buses &lt; cars:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Maybe we could take the buses.&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;We still can&#x27;t decide.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> people &gt; buses:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Alright, let&#x27;s just take the buses.&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;Fine, let&#x27;s stay home then.&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="习题31：作出决定"><a href="#习题31：作出决定" class="headerlink" title="习题31：作出决定"></a>习题31：作出决定</h1><h2 id="文件名：ex31-py"><a href="#文件名：ex31-py" class="headerlink" title="文件名：ex31.py"></a>文件名：ex31.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;You enter a dark room with two doors. Do you go through door #1 or door #2? &quot;</span></span><br><span class="line">door = raw_input(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> door == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;There&#x27;s a giant bear here eating a cheese cake. What do you do?&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;1. Take the cake.&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;2. Scream at the bear.&quot;</span></span><br><span class="line">    bear = raw_input(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> bear == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;The bear eats your face off. Good job!&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> bear == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;The bear eats your legs off. Good job!&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Well, doing %s is probably better. Bear runs away.&quot;</span> % bear</span><br><span class="line"><span class="keyword">elif</span> door == <span class="string">&quot;2&quot;</span>：</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;You stare into the endless abyss at Cthulhu&#x27;s retina.&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;1. Blueberries.&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;2. Yellow jacket clothespins.&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;3. Understanding revolvers yelling melodies.&quot;</span></span><br><span class="line">    </span><br><span class="line">    insanity = raw_input(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> insanity == <span class="string">&quot;1&quot;</span> <span class="keyword">or</span> insanity == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Your body survives powered by a mind of jello. Good job!&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;The insanity rots your eyes into a pool of muck. Good job!&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;You stumble around and fall on a knife and die. Good job!&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="习题31：循环和列表"><a href="#习题31：循环和列表" class="headerlink" title="习题31：循环和列表"></a>习题31：循环和列表</h1><h2 id="文件名：ex32-py"><a href="#文件名：ex32-py" class="headerlink" title="文件名：ex32.py"></a>文件名：ex32.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">the_count = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">fruits = [<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;oranges&#x27;</span>, <span class="string">&#x27;pears&#x27;</span>, <span class="string">&#x27;apricots&#x27;</span>]</span><br><span class="line">change = [<span class="number">1</span>, <span class="string">&#x27;pennies&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;dimes&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;quarters&#x27;</span>]</span><br><span class="line"><span class="comment"># this first kind of for-loop goes through a list</span></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> the_count:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;This is count %d&quot;</span> % number</span><br><span class="line"><span class="comment"># same as above</span></span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> fruits:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;A fruit of type: %s&quot;</span> % fruit</span><br><span class="line"><span class="comment"># also we can go through mixed lists too</span></span><br><span class="line"><span class="comment"># notice we have to use %r since we don&#x27;t know what&#x27;s in it </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> change:</span><br><span class="line">     <span class="built_in">print</span> <span class="string">&quot;I got %r&quot;</span> % i </span><br><span class="line"><span class="comment"># we can also build lists, first start with an empty one</span></span><br><span class="line">elements = []</span><br><span class="line"><span class="comment"># then use the range function to do 0 to 5 counts</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Adding %d to the list.&quot;</span> % i</span><br><span class="line">    element.append(i)</span><br><span class="line"><span class="comment"># noew we can print them out too</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> elements:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Element was: %d&quot;</span> % i</span><br></pre></td></tr></table></figure>
<h1 id="习题33：while循环"><a href="#习题33：while循环" class="headerlink" title="习题33：while循环"></a>习题33：while循环</h1><h2 id="文件名：ex33-py"><a href="#文件名：ex33-py" class="headerlink" title="文件名：ex33.py"></a>文件名：ex33.py</h2><p>接下来是一个更在你意料之外的概念：<code>while-loop</code>，它会一直执行它下面的代码片段，直到它对应的布尔表达式为<code>False</code>时才会停下来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">numbers = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">6</span> :</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;At the top i is %d&quot;</span> % i</span><br><span class="line">    numbers.append(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Numbers now:&quot;</span>, numbers</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;At the bottom i is %d&quot;</span> % i</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;The numbers:&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">    <span class="built_in">print</span> num</span><br></pre></td></tr></table></figure>
<h1 id="习题34：访问列表的元素"><a href="#习题34：访问列表的元素" class="headerlink" title="习题34：访问列表的元素"></a>习题34：访问列表的元素</h1><h2 id="文件名：ex34-py"><a href="#文件名：ex34-py" class="headerlink" title="文件名：ex34.py"></a>文件名：ex34.py</h2><p>列表的用处很大，但只有你能访问里边的内容时它才能发挥出来。你已经学会按顺序读出列表的内容，但如果你要得到第5个元素该怎么办呢？你要得第5个元素该怎么办呢？你需要知道如何访问列表中的元素。访问第一个元素的方法是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals = [<span class="string">&#x27;bear&#x27;</span>, <span class="string">&#x27;tigher&#x27;</span>, <span class="string">&#x27;penguin&#x27;</span>, <span class="string">&#x27;zebra&#x27;</span>]</span><br><span class="line">bear = animal[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>你定义一个animals的列表，然后你用0来获取第一个元素</p>
<h1 id="习题35：分支和函数"><a href="#习题35：分支和函数" class="headerlink" title="习题35：分支和函数"></a>习题35：分支和函数</h1><h2 id="文件名：ex35-py"><a href="#文件名：ex35-py" class="headerlink" title="文件名：ex35.py"></a>文件名：ex35.py</h2><p>你已经学会了if语句、函数、还用列表。现在需要练习一下思维了。把下面的代码写下来，看你是否能弄懂它实现的是什么功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> exit</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gold_room</span>()： </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;This room if full of gold. How much do you take?&quot;</span></span><br><span class="line">        <span class="built_in">next</span> = raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;0&quot;</span> <span class="keyword">in</span> <span class="built_in">next</span> <span class="keyword">or</span> <span class="string">&quot;1&quot;</span> <span class="keyword">in</span> <span class="built_in">next</span>: </span><br><span class="line">            how_much = <span class="built_in">int</span>(<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dead(<span class="string">&quot;Man, learn to type a number. &quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> how_much &lt; <span class="number">50</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Nice, you&#x27;re not greedy, you win!&quot;</span></span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dead(<span class="string">&quot;You greedy bastard!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bear_room</span>():</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;There is a bear here. &quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;The bear has a bunch of honey.&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;The fat bear is in front of another door.&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;How are you going to move the bear?&quot;</span></span><br><span class="line">        bear_moved = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">next</span> = raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">next</span> == <span class="string">&quot;take honey&quot;</span>:</span><br><span class="line">                dead(<span class="string">&quot;The bear looks at you then slaps your face off.&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">next</span> ==<span class="string">&quot;taunt bear&quot;</span> <span class="keyword">and</span> <span class="keyword">not</span> bear_moved:</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&quot;The bear has moved from the door. You can go ghrough is now.&quot;</span></span><br><span class="line">                bear_moved = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">next</span> == <span class="string">&quot;taunt bear&quot;</span> <span class="keyword">and</span> bear_moved:</span><br><span class="line">                dead(<span class="string">&quot;The bear gets pissed off and chews your legoff. &quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">next</span> == <span class="string">&quot;open door &quot;</span> <span class="keyword">and</span> bear_moved:</span><br><span class="line">                gold_room()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&quot;I got no idea what that means.&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cthulhu_room</span>():</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Here you see the great evil Cthulhu.&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;He, it, whatever stares at you and you go insane.&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Do you flee for your life or eat your head?&quot;</span></span><br><span class="line">        <span class="built_in">next</span> = raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;flee&quot;</span> <span class="keyword">in</span> <span class="built_in">next</span>:</span><br><span class="line">            start()</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&quot;head&quot;</span> <span class="keyword">in</span> <span class="built_in">next</span>:</span><br><span class="line">            dead(<span class="string">&quot;Well that was tasty!&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cthulhu_room()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dead</span>(<span class="params">why</span>):</span><br><span class="line">        <span class="built_in">print</span> why, <span class="string">&quot;Good job!&quot;</span></span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>():</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;You are in a dark room.&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;There is a door to your right and left.&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Which one do you take?&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">next</span> == raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">next</span> == <span class="string">&quot;left&quot;</span>:</span><br><span class="line">            bear_room()</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">next</span> == <span class="string">&quot;right&quot;</span>:</span><br><span class="line">            cthulhu_room()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dead(<span class="string">&quot;You stumble around the room until you starve.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    start()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用rclone同步远程云盘</title>
    <url>/2018/11/08/rclone/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>rclone是一个命令行程序，用于同步文件和目录，并支持网盘同步，可同步网盘包括如下：</p>
<ul>
<li>Amazon Drive</li>
<li>Amazon S3</li>
<li>Backblaze B2</li>
<li>Box</li>
<li>Ceph</li>
<li>DigitalOcean Spaces</li>
<li>Dreamhost</li>
<li>Dropbox</li>
<li>FTP</li>
<li>Google Cloud Storage</li>
<li>Google Drive</li>
<li>HTTP</li>
<li>Hubic</li>
<li>Jottacloud</li>
<li>IBM COS S3</li>
<li>Memset Memstore</li>
<li>Mega</li>
<li>Microsoft Azure Blob Storage</li>
<li>Microsoft OneDrive</li>
<li>Minio</li>
<li>Nextcloud</li>
<li>OVH</li>
<li>OpenDrive</li>
<li>Openstack Swift</li>
<li>Oracle Cloud Storage</li>
<li>ownCloud</li>
<li>pCloud</li>
<li>put.io</li>
<li>QingStor</li>
<li>Rackspace Cloud Files</li>
<li>SFTP</li>
<li>Wasabi</li>
<li>WebDAV</li>
<li>Yandex Disk</li>
<li>The local filesystem</li>
</ul>
<span id="more"></span>

<h1 id="2-常用的rclone命令"><a href="#2-常用的rclone命令" class="headerlink" title="2. 常用的rclone命令"></a>2. 常用的rclone命令</h1><ol>
<li>rclone config : 配置会话；</li>
<li>rclone copy : 将文件从原文件夹复制至目标文件夹，跳过已复制的文件；</li>
<li>rclone sync : 将文件从原文件夹同步至目标文件夹，只修改目的地；</li>
<li>rclone move : 将文件从原文件夹移动至目标文件夹；</li>
<li>rclone delete : 删除路径中的内容；</li>
<li>rclone purge : 清空指定路径下的所有文件数据；</li>
<li>rclone mkdir : 创建一个新目录； </li>
<li>rclone rmdir : 删除一个空目录；</li>
<li>rclone rmdirs : 删除路径下的所有空目录；</li>
<li>rclone check : 检查源和目标的数据是否匹配；</li>
<li>rclone ls : 列出指定路径下所有的文件包含文件的大小及路径；</li>
<li>rclone lsd : 列出路径中的所有目录containers和buckets；</li>
<li>rclone lsl : 列出具有大小、修改时间和路径中的所有对象；</li>
<li>rclone md5sum : 为路径中的所有对象生成一个md5sum文件；</li>
<li>rclone sha1sum : 为路径中的所有对象生成一个sha1sum文件；</li>
<li>rclone size : 返回远程路径中对象的总大小和数量；</li>
<li>rclone version : 显示版本号；</li>
<li>rclone cleanup : 如果可能的话，清理remote；</li>
<li>rclone dedupe : 交互式查找重复文件并删除重命名它们；</li>
<li>rclone authorize : 远程认证；</li>
<li>rclone cat : 连接文件并将它们发送到stdout；</li>
<li>rclone copyto : 将文件从源复制到目标，跳过已复制的文件；</li>
<li>rclone genautocomplete : rclone输出完成脚本；</li>
<li>rclone gendocs : rclone将markdown文档输出到所提供的目录；</li>
<li>rclone listremotes : 列出所有远程的配置文件；</li>
<li>rclone mount : 将远程目标挂载至本地；</li>
<li>rclone moveto : 将文件或目录从源移动至目标；</li>
<li>rclone obscure : 在rclone.conf文件中使用模糊密码；</li>
<li>rclone cryptcheck : 检验远程认证；</li>
<li>rclone about : 获取配额信息；</li>
</ol>
<h1 id="3-选项"><a href="#3-选项" class="headerlink" title="3. 选项"></a>3. 选项</h1><h2 id="3-1-–backup-dir-x3D-DIR"><a href="#3-1-–backup-dir-x3D-DIR" class="headerlink" title="3.1 –backup-dir&#x3D;DIR"></a>3.1 –backup-dir&#x3D;DIR</h2><p>当使用<code>sync、copy or move</code>时，所有涉及到覆盖或删除的文件变动，原始文件会被移动到<code>--backup-dir=DIR</code>选项所设置的目录中，如果设置了后缀选项<code>--suffix</code>，则在文件后缀附加指定字符串，例如原文件’abc.txt’，如果指定<code>--suffix 20181101</code>，则备份后的文件名全称为”abc.txt20181101”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同步本地目录至远程目录current的文件，并且备份已经覆盖或删除文件至远程old文件夹中</span></span><br><span class="line">$ rclone <span class="built_in">sync</span> /path/to/local remote:current --backup-dir remote:old</span><br><span class="line"><span class="comment"># 同步本地目录“./&quot;至远程”test“目录，覆盖或删除的文件移动至远程old文件夹中，并将后缀名后附加”20181108“</span></span><br><span class="line">$ sudo rclone <span class="built_in">sync</span> ./ One:<span class="built_in">test</span> --backup-dir One:old --suffix 20181108</span><br></pre></td></tr></table></figure>
<h2 id="3-2-–bind-string"><a href="#3-2-–bind-string" class="headerlink" title="3.2 –bind string"></a>3.2 –bind string</h2><p>要绑定到输出连接的本地地址。这可以是IPv4地址、IPv6地址或主机名。如果主机名没有解析或解析为多个IP地址，则会出错。</p>
<h2 id="3-3-–bwlimit-x3D-BANDWIDTH-SPEC"><a href="#3-3-–bwlimit-x3D-BANDWIDTH-SPEC" class="headerlink" title="3.3 –bwlimit&#x3D;BANDWIDTH_SPEC"></a>3.3 –bwlimit&#x3D;BANDWIDTH_SPEC</h2><p>此选项控制带宽限制。限制可以通过两种方式指定：单个限制或依据时间表限制。指定带宽限制单位为kBytes&#x2F;s，或使用后缀b、k、M、G，默认值为0，表示不限制带宽。例如，要将带宽限制为10MB&#x2F;s，则使用–bwlimit 10M。</p>
<p>还可以指定限制的”时间表“，这将导致在某些时间应用某些限制。要指定时间表，请将条目格式设置为”WEEKDAY-HH:MM, BANDWIDTH WEEKDAY-HH:MM, BANDWIDTH…“，其中：WEEKDAY是可选元素。它可以写成整个世界或仅使用3个第一个字符。HH:MM从00：00到23：59是一小时。</p>
<p>例1：如下时间表避免白天工作时间，早8:00限制带宽512kBytes&#x2F;sec，12:00限制提升至10M，下午13:00降至512kBytes&#x2F;sec，18:00提升至30M，在23:00开始完全禁用，网络全速运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--bwlimit <span class="string">&quot;08:00,512 12:00,10M 13:00,512 18:00,30M 23:00,off&quot;</span></span><br></pre></td></tr></table></figure>
<p>例2：周一带宽限制为512kBytes&#x2F;sec，周五结束前提升至10Mbytes&#x2F;s。周日10:00，它将设置为1Mbyte&#x2F;s。从周日的20：00起将是无限的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--bwlimit <span class="string">&quot;Mon-00:00,512 Fri-23:59,10M Sat-10:00,1M Sun-20:00,off&quot;</span></span><br></pre></td></tr></table></figure>
<p>例3：等价于例4</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--bwlimit <span class="string">&quot;Mon-00:00,512 12:00,1M Sun-20:00,off&quot;</span></span><br></pre></td></tr></table></figure>
<p>例4：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--bwlimit <span class="string">&quot;Mon-00:00,512 Mon-12:00,1M Tue-12:00,1M Wed-12:00,1M Thu-12:00,1M Fri-12:00,1M Sat-12:00,1M Sun-12:00,1M Sun-20:00,off&quot;</span></span><br></pre></td></tr></table></figure>
<p>带宽限制仅适用于数据传输。它们不适用于目录列表的带宽。注意，这些单位是字节&#x2F;秒,而不是比特&#x2F;秒。通常连接是以比特&#x2F;秒来测量的，转换时需要除以8。例如10Mbit&#x2F;s连接，那么在指定参数时需要计算10&#x2F;8&#x3D;1.25Mbyte&#x2F;s，即”–bwlimit 1.25M“</p>
<p>在Unix系统（Linux, MacOS, …）上，可以通过向rclone发送SIGUSR2信号来切换带宽限制器。它允许消除长时间运行的rclone传输的限制，并在需要时将其恢复为使用<code>--bwlimit</code>指定的值。假设只有一个rclone实例在运行，你可以像这样切换限制器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -SIGUSR2 $(pidof rclone)</span><br></pre></td></tr></table></figure>
<p>通过如下配置可以动态更改bwlimit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rclone rc core/bwlimit rate=1M</span><br></pre></td></tr></table></figure>
<h2 id="3-4-–buffer-size-x3D-SIZE"><a href="#3-4-–buffer-size-x3D-SIZE" class="headerlink" title="3.4 –buffer-size&#x3D;SIZE"></a>3.4 –buffer-size&#x3D;SIZE</h2><p>设置缓冲区大小来加速文件传输。每个-transfer都会使用这么多内存来缓冲。当使用mount或cmount时，每个打开的文件描述符将使用设置的缓冲区大小的内存进行缓冲。设置为0可禁用最小内存使用的缓冲。</p>
<h2 id="3-5-–checkers-x3D-N"><a href="#3-5-–checkers-x3D-N" class="headerlink" title="3.5 –checkers&#x3D;N"></a>3.5 –checkers&#x3D;N</h2><p>并行运行的检查器数量。检查程序在同步期间对文件进行等同性检查。对于某些存储系统（例如S3, Swift, Dropbox），这可能需要很长时间才能并行运行。默认是并行运行8个检查程序。</p>
<h2 id="3-6-c-–checksum"><a href="#3-6-c-–checksum" class="headerlink" title="3.6 -c, –checksum"></a>3.6 -c, –checksum</h2><p>通常，rclone会查看文件的修改时间和大小，以查看它们是否相等。如果设置此标志，则rclone将检查文件哈希和大小以确定文件是否相等。当远程不支持设置修改时间并且需要比仅检查文件大小更准确的同步时，这非常有用。</p>
<p>当在对象上存储相同散列类型的远程之间进行传输时，这非常有用，例如Drive和Swift。有关哪些远程控制支持哪种散列类型的详细信息，<a href="https://rclone.org/overview/">请参阅概述部分中的表</a>。</p>
<p>例如<code>rclone --checksum sync s3:/bucket swift:/bucket</code>比没有–checksum标志的运行得快的多。使用些标志时，如果远程文件不正常，rclone将不会更新远程文件的mtimes。</p>
<h2 id="3-7-–config-x3D-CONFIG-FILE"><a href="#3-7-–config-x3D-CONFIG-FILE" class="headerlink" title="3.7 –config&#x3D;CONFIG_FILE"></a>3.7 –config&#x3D;CONFIG_FILE</h2><p>指定rclone配置文件的位置。通常配置文件位于主目录中<code>.config/rclone/rclone.conf</code>，如果设置了$XDG_CONFIG_HOME，它将位于$XDG_CONFIG_HOME&#x2F;rclone&#x2F;rclone.conf</p>
<p>如果您运行rclone -h并查看–config选项帮助，您将看到默认位置的位置。使用此标志可覆盖配置位置，例如<code>rclone --config=&#39;.myconfig&quot;</code></p>
<h2 id="3-8-–contimeout-x3D-TIME"><a href="#3-8-–contimeout-x3D-TIME" class="headerlink" title="3.8 –contimeout&#x3D;TIME"></a>3.8 –contimeout&#x3D;TIME</h2><p>设置连接超时时间。TIME为时间格式，5秒参数为5s，10分钟为10m或3h30m。连接超时是rclone等待连接进入远程对象存储系统的时间。默认为1m（1分钟）</p>
<h2 id="3-9-–dedupe-mode-MODE"><a href="#3-9-–dedupe-mode-MODE" class="headerlink" title="3.9 –dedupe-mode MODE"></a>3.9 –dedupe-mode MODE</h2><p>运行重复数据删除命令模式。模式分为interactive, skip, first, newest, oldest, rename。缺省为interactive（交互式）</p>
<h2 id="3-10-–disable-FEATURE-FEATURE-…"><a href="#3-10-–disable-FEATURE-FEATURE-…" class="headerlink" title="3.10 –disable FEATURE, FEATURE, …"></a>3.10 –disable FEATURE, FEATURE, …</h2><p>禁用以逗号分隔的可选功能列表。例如：禁用服务器端move和服务器copy的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--disable move, copy</span><br></pre></td></tr></table></figure>
<p>查看可以禁用哪些功能的列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--disable help</span><br></pre></td></tr></table></figure>
<p>请<a href="https://rclone.org/overview/#features">参阅概览功能</a>和<a href="https://rclone.org/overview/#optional-features">可选功能</a>，了解哪个功能能做到什么。<br>此标志可用于调试和特殊情况（例如Google Drive将服务器端copy总量限制为100GB&#x2F;天）</p>
<h2 id="3-11-n-–dry-run"><a href="#3-11-n-–dry-run" class="headerlink" title="3.11 -n, –dry-run"></a>3.11 -n, –dry-run</h2><p>进行试运行而不进行永久性更改。使用它来查看rclone在没有实际操作的情况下会做什么。设置同步命令以删除目标中的文件时很有用。</p>
<h2 id="3-12-–ignore-checksum"><a href="#3-12-–ignore-checksum" class="headerlink" title="3.12 –ignore-checksum"></a>3.12 –ignore-checksum</h2><p>通常，rclone会检查传输文件的校验和是否匹配，如果没有，则会在传输时出现”损坏“错误。您可以使用些选项跳过该检查。您应该只在遇到”传输损坏“错误消息时才使用它，并且您确定可能要传输可能已损坏的数据。</p>
<h2 id="3-13-–ignore-existing"><a href="#3-13-–ignore-existing" class="headerlink" title="3.13 –ignore-existing"></a>3.13 –ignore-existing</h2><p>使用此选项将使rclone无条件地跳过目标上存在的所有文件，无论这些文件的内容如何。虽然这不是一般推荐的选项，但在文件因加密而发生变化的情况下，它可能很有用。但是，如果传输中断，则无法纠正部分传输。</p>
<h2 id="3-14-–ignore-size"><a href="#3-14-–ignore-size" class="headerlink" title="3.14 –ignore-size"></a>3.14 –ignore-size</h2><p>通常，rclone会查看文件的修改时间和大小，以查看它们是否相等。如果设置此标志，则rclone将仅检查修改时间。如果设置–checksum，那么它只检查checksum。它还会导致rclone跳过验证传输后大小相同。</p>
<p>这对于向OneDrive传输文件和从OneDrive传输文件非常有用，OneDrive偶尔会误报图像文件的大小([有关详细信息，请参阅#399])[<a href="https://github.com/ncw/rclone/issues/399]">https://github.com/ncw/rclone/issues/399]</a></p>
<h2 id="3-15-i-–ignore-times"><a href="#3-15-i-–ignore-times" class="headerlink" title="3.15 -i, –ignore-times"></a>3.15 -i, –ignore-times</h2><p>使用此选项将导致rclone无条件地上载所有文件，而不管目标上的文件状态如何。通常，rclone会跳过任何具有相同修改时间且大小相同的文件（如果使用–checksum，则具有相同的checksum）。</p>
<h2 id="3-16-–immutable"><a href="#3-16-–immutable" class="headerlink" title="3.16 –immutable"></a>3.16 –immutable</h2><p>将源文件和目标文件视为不可变并禁止修改。设置此选项后，将根据请求创建和删除文件，但永远不会更新现有文件。如果源和目标之间的现有文件不匹配，则rclone将给出错误源和目标存在但不匹配：修改了不可变文件。</p>
<p>请注意，只有传输文件的命令（例如sync、copy、move）才会受到此行为影响，并且只允许修改。文件仍然可以被明确删除（例如delete、purge）或隐式删除（例如sync、move）。如果需要避免删除和修改，请使用copy -immutable。</p>
<p>这用作不可变或仅附加数据集（特别是备份存档）的附加保护层，其中修改意味着损坏并且不应传播。</p>
<h2 id="3-17-–leave-root"><a href="#3-17-–leave-root" class="headerlink" title="3.17 –leave-root"></a>3.17 –leave-root</h2><p>在rmdirs中，即使它是空的，它也不会删除根目录。</p>
<h2 id="3-18-–log-file-x3D-FILE"><a href="#3-18-–log-file-x3D-FILE" class="headerlink" title="3.18 –log-file&#x3D;FILE"></a>3.18 –log-file&#x3D;FILE</h2><p>将输出记录输出至FILE。默认情况下，此选项无效。这对于跟踪同步和-v标志的问题非常有用。有关详细信息，请参阅<a href="https://rclone.org/docs/#logging">“日志记录部分”</a>。</p>
<p>请注意，如果您使用logrotate程序来管理rclone的日志，那么您应该使用copytruncate选项，因为rclone没有旋转日志的信号。</p>
<h2 id="3-19-–log-format-LIST"><a href="#3-19-–log-format-LIST" class="headerlink" title="3.19 –log-format LIST"></a>3.19 –log-format LIST</h2><p>日志格式选项是以逗号来分隔的列表。date, time, microseconds, longfile, shortfile, UTC。默认为“date,time”</p>
<h2 id="3-20-–log-level-LEVEL"><a href="#3-20-–log-level-LEVEL" class="headerlink" title="3.20 –log-level LEVEL"></a>3.20 –log-level LEVEL</h2><p>设置rclone的日志级别：默认的日志级别为NOTICE（警告）</p>
<ol>
<li>DEBUG（调试）：等效于-vv。它输出大量的调试信息及有用的bug报告，并真正打出rclone正在做什么。</li>
<li>INFO（信息）：等效于-v。它全出差于每个传输的信息，默认情况下每分钟打印一次STATS。</li>
<li>NOTICE（警告）：如果没有提供日志标志，则为默认日志级别。当工作时它输出的信息有限，只输出警告及重要的信息。</li>
<li>ERROR（错误）：等效于-q。它只输出错误消息。</li>
</ol>
<h2 id="3-21-–low-level-retries-NUMBNER"><a href="#3-21-–low-level-retries-NUMBNER" class="headerlink" title="3.21 –low-level-retries NUMBNER"></a>3.21 –low-level-retries NUMBNER</h2><p>这个选项可以控制rclone的低级重试次数，它用于重试失败的操作，通常是一个HTTP请求。例如，这可能是上传大文件的一部分。你将在日志中看到带有-v标志的低级重试。<br>这不应该从正常操作中的默认值更改。但是，如果您进行了大量的低级重试，则可能希望减小该值，以便rclone更快的进行高级重试，请参阅–retries标志。</p>
<p>禁用低次重试，使用命令<code>--low-level-retries 1</code></p>
<h2 id="3-22-–max-backlog-x3D-N"><a href="#3-22-–max-backlog-x3D-N" class="headerlink" title="3.22 –max-backlog&#x3D;N"></a>3.22 –max-backlog&#x3D;N</h2><p>设定检测或传输用于sync、copy或move的最大的的排队等候的文件积压。你可以任意设定它，它只会在队列使用的时候占用内存。需要注意的是，当使用积压时，它将以数字N单位kb的内存顺序完成。</p>
<p>设置N的值越大则rclone可以能够更准确地计算待处理文件的数量，并能够更精准地预估完成时间。N值越小则rclone同步至远程列表的越快。</p>
<h2 id="3-23-–max-delete-x3D-N"><a href="#3-23-–max-delete-x3D-N" class="headerlink" title="3.23 –max-delete&#x3D;N"></a>3.23 –max-delete&#x3D;N</h2><p>设置rclone不要删除超过N个文件。如果超出限制，那么返回错误信息并且rclone将停止正在进行的操作。</p>
<h2 id="3-24-–max-depth-x3D-N"><a href="#3-24-–max-depth-x3D-N" class="headerlink" title="3.24 –max-depth&#x3D;N"></a>3.24 –max-depth&#x3D;N</h2><p>设置除了purge（清空）命令之外所有命令的递归深度。例如：<code>rclone --max-depth 1 ls remote:path</code>命令，它只能看到远程设定目录中的顶级目录文件，使用<code>--max-depth 2</code>则意味着您将看到两层目录级别中的所有文件，依次类推。</p>
<p>由于历史的原因，lsd命令默认使用<code>--max-depth</code>为1，您可以使用命令行标志覆盖它。也可以使用<code>--max-depth 1</code>命令来禁用递归操作。需要注意的是，如果与sync并使用–delete-excluded一起使用，则会将未递归的文件视为已经排除，并将在目标上删除。如果你不确定会发生什么，请先使用–dry-run进行测试。</p>
<h2 id="3-25-–max-transfer-x3D-SIZE"><a href="#3-25-–max-transfer-x3D-SIZE" class="headerlink" title="3.25 –max-transfer&#x3D;SIZE"></a>3.25 –max-transfer&#x3D;SIZE</h2><p>设定传输的最大值，rclone当达到指定的大小时，它将停止传输，并将退出代码标记为8。默认为关闭。</p>
<h2 id="3-26-–modify-window-x3D-TIME"><a href="#3-26-–modify-window-x3D-TIME" class="headerlink" title="3.26 –modify-window&#x3D;TIME"></a>3.26 –modify-window&#x3D;TIME</h2><p>检查文件是否已被修改时，这是文件可以具有的最大允许时间差，仍然被视为等效。默认值为1ns，除非被远程控制覆盖。 例如，OS X仅将修改时间存储到最近的秒，因此如果您正在读取和写入OSX文件系统，则默认情况下这将是1秒。此命令行标志允许您覆盖该计算的默认值。</p>
<h2 id="3-27-–no-gzip-encoding"><a href="#3-27-–no-gzip-encoding" class="headerlink" title="3.27 –no-gzip-encoding"></a>3.27 –no-gzip-encoding</h2><p>不要设置Accept-Encoding：gzip。 这意味着rclone不会自动向服务器请求压缩文件。如果您已将服务器设置为使用Content-Encoding返回文件：gzip但您上传了压缩文件，则非常有用。没有必要在正常操作中设置它，这样做会降低rclone的网络传输效率。</p>
<h2 id="3-28-–no-update-modtime"><a href="#3-28-–no-update-modtime" class="headerlink" title="3.28 –no-update-modtime"></a>3.28 –no-update-modtime</h2><p>使用此标志时，如果远程文件不正常，rclone将不会更新远程文件的修改时间。如果远程与其他工具同步（例如Google Drive客户端），则可以使用此功能。</p>
<h2 id="3-29-P-–progress"><a href="#3-29-P-–progress" class="headerlink" title="3.29 -P, –progress"></a>3.29 -P, –progress</h2><p>此标志使rclone更新终端中静态块中的统计信息，提供传输的实时概述。任何日志消息都将在静态块上方滚动。 日志消息会将静态块向下推到终端的底部。通常每500mS更新一次，但可以使用–stats标志覆盖此期间。这可以与–stats-one-line标志一起使用，以实现更简单的显示。注意：在Windows上，在修复此错误之前，所有非ASCII字符都将替换为。 当–progress正在使用时。</p>
<h2 id="3-30-q-–quiet"><a href="#3-30-q-–quiet" class="headerlink" title="3.30 -q, –quiet"></a>3.30 -q, –quiet</h2><p>通常，rclone输出统计信息和完成消息。 如果设置此标志，它将尽可能少地输出。</p>
<h2 id="3-31-–retries-int"><a href="#3-31-–retries-int" class="headerlink" title="3.31 –retries int"></a>3.31 –retries int</h2><p>如果失败多次失败，则重试整个同步（默认值为3）。一些遥控器可能不可靠，一些重试有助于获取由于错误而未被转移的文件。使用–retries 1禁用重试。</p>
<h2 id="3-32-–retries-sleep-x3D-time"><a href="#3-32-–retries-sleep-x3D-time" class="headerlink" title="3.32 –retries-sleep&#x3D;time"></a>3.32 –retries-sleep&#x3D;time</h2><p>这将设置–retries指定的每次重试之间的间隔默认值为0.使用0禁用。</p>
<h2 id="3-33-–size-only"><a href="#3-33-–size-only" class="headerlink" title="3.33 –size-only"></a>3.33 –size-only</h2><p>通常，rclone会查看文件的修改时间和大小，以查看它们是否相等。 如果设置此标志，则rclone将仅检查大小。这可以用于从Dropbox传输文件，这些文件已经被桌面同步客户端修改，该客户端没有像rclone那样设置修改时间的校验和。</p>
<h2 id="3-34-–stats-x3D-TIME"><a href="#3-34-–stats-x3D-TIME" class="headerlink" title="3.34 –stats&#x3D;TIME"></a>3.34 –stats&#x3D;TIME</h2><p>传输数据（sync, copy, copyto, move, moveto）的命令将定期打印数据传输统计信息以显示其进度。默认值为1m，使用0禁用。如果设置统计间隔，则所有命令都可以显示统计信息。这在运行其他命令，检查或安装时非常有用。</p>
<p>默认情况下，统计信息记录在INFO级别，这意味着它们不会以默认日志级别显示NOTICE。使用–stats-log-level NOTICE或-v使它们显示。有关日志级别的详细信息，请参阅<a href="https://rclone.org/docs/#logging">“日志记录”</a>部分。</p>
<p>请注意，在macOS上，你可以发送SIGINFO(通常是终端中的ctrl-T)以立即打印统计信息。</p>
<h2 id="3-35-–stats-file-name-length-integer"><a href="#3-35-–stats-file-name-length-integer" class="headerlink" title="3.35 –stats-file-name-length integer"></a>3.35 –stats-file-name-length integer</h2><p>默认情况下，-stats输出将截断超过40个字符的文件名和路径。 这相当于提供–stats-file-name-length 40.使用–stats-file-name-length 0禁用由stats打印的文件名截断。</p>
<h2 id="3-36-–stats-log-level-string"><a href="#3-36-–stats-log-level-string" class="headerlink" title="3.36 –stats-log-level string"></a>3.36 –stats-log-level string</h2><p>日志级别显示–stats输出。 这可以是DEBUG，INFO，NOTICE或ERROR。 默认值为INFO。 这意味着在默认的日志记录级别，即注意，统计信息将不会显示 - 如果您希望它们使用–stats-log-level NOTICE。 有关日志级别的详细信息，请参阅<a href="https://rclone.org/docs/#logging">“日志记录”</a>部分。</p>
<h2 id="3-37-–stats-one-line"><a href="#3-37-–stats-one-line" class="headerlink" title="3.37 –stats-one-line"></a>3.37 –stats-one-line</h2><p>指定此值后，rclone会将统计信息压缩为一行，仅显示最重要的统计信息。</p>
<h2 id="3-38-–stats-unit-x3D-bits-bytes"><a href="#3-38-–stats-unit-x3D-bits-bytes" class="headerlink" title="3.38 –stats-unit&#x3D;bits|bytes"></a>3.38 –stats-unit&#x3D;bits|bytes</h2><p>默认情况下，数据传输速率将以bytes&#x2F;s打印。此选项允许以bit&#x2F;s打印数据速率</p>
<h2 id="3-39-–suffix-x3D-SUFFIX"><a href="#3-39-–suffix-x3D-SUFFIX" class="headerlink" title="3.39 –suffix&#x3D;SUFFIX"></a>3.39 –suffix&#x3D;SUFFIX</h2><p>这仅适用于–backup-dir。 如果未设置，则–backup-dir将使用其原始名称移动文件。 如果已设置，则文件将添加SUFFIX。有关详细信息，请参阅–backup-dir。</p>
<h2 id="3-40-–syslog"><a href="#3-40-–syslog" class="headerlink" title="3.40 –syslog"></a>3.40 –syslog</h2><p>在功能强大的操作系统（不是Windows或Plan9）上，将所有日志输出发送到syslog。这对于在脚本或rclone挂载中运行rclone非常有用。</p>
<h2 id="3-41-–syslog-facility-string"><a href="#3-41-–syslog-facility-string" class="headerlink" title="3.41 –syslog-facility string"></a>3.41 –syslog-facility string</h2><p>如果使用–syslog，则设置syslog工具（例如KERN，USER）。 请参阅man syslog以获取可能的设施列表。 默认设施是DAEMON。</p>
<h2 id="3-42-–tpslimit-float"><a href="#3-42-–tpslimit-float" class="headerlink" title="3.42 –tpslimit float"></a>3.42 –tpslimit float</h2><p>每秒限制HTTP事务。 默认值为0，用于表示每秒无限制的事务数。例如，要将rclone限制为每秒10个HTTP事务使用–tpslimit 10，或者每2秒限制1个事务使用–tpslimit 0.5。当rclone每秒的事务数导致云存储提供程序出现问题时（例如，禁止您或限制速率），请使用此选项。这对于rclone mount来控制使用它的应用程序的行为非常有用。另见–tpslimit-burst。</p>
<h2 id="3-43-–tpslimit-burst-int"><a href="#3-43-–tpslimit-burst-int" class="headerlink" title="3.43 –tpslimit-burst int"></a>3.43 –tpslimit-burst int</h2><p>–tpslimit的最大交易次数。 （默认1）<br>通常–tpslimit将完成指定的每秒事务数。 但是，如果你提供–tps-burst，那么rclone可以在空闲时保存一些事务，从而提供一个高达所提供参数的突发。例如，如果你提供–tpslimit-burst 10那么如果rclone已经空闲超过10 *  -tpslimit那么它可以在它们再次受限之前非常快地完成10个事务。<br>这可用于提高–tpslimit的性能，而不会更改每秒的长期平均事务数。</p>
<h2 id="3-44-–track-renames"><a href="#3-44-–track-renames" class="headerlink" title="3.44 –track-renames"></a>3.44 –track-renames</h2><p>默认情况下，rclone不会跟踪重命名的文件，因此如果您在本地重命名文件然后将其同步到远程文件，rclone将删除远程文件上的旧文件并上传新副本。</p>
<p>如果您使用些标志，并且远程支持服务器端副本或服务器端移动，并且源和目标具有兼容的哈希，则这将在同步操作期间跟踪重命名并执行服务器端重命名。文件将按大小和哈希匹配，如果两者都不匹配，则将考虑重命名。</p>
<p>如果目标不支持服务器端复制或移动，则rclone将回退到默认行为并将错误级别消息记录到控制台。注意：–track-renames不支持加密。</p>
<h2 id="3-45-–delete-before-during-after"><a href="#3-45-–delete-before-during-after" class="headerlink" title="3.45 –delete-(before, during, after)"></a>3.45 –delete-(before, during, after)</h2><p>此选项允许您指定在同步文件夹时删除目标上的文件时间。在开始传输任何新文件或更新文件之前，指定值–delete-before将删除目标上存在的所有文件，但不删除源文件。这使用两次通过文件系统，一次用于删除，一次用于复制。</p>
<p>指定–delete-during将在检查和上载文件时删除文件。这是最快的选项，使用的内存最少。</p>
<p>指定–delete-after（默认值）将延迟删除文件，直到成功传输所有新的&#x2F;更新的文件。要删除的文件将在复制传递中收集，然后在复制传递成功完成后删除。要删除的文件保存在内存中，因此此模式可能会占用更多内存。这是最安全的模式，因为如果之后没有错误，它只会删除文件。如果在删除开始之前出现错误，那么由于存在IO错误，您将收不到删除文件的消息。</p>
<h2 id="3-46-–fast-list"><a href="#3-46-–fast-list" class="headerlink" title="3.46 –fast-list"></a>3.46 –fast-list</h2><p>任何涉及目录列表的事件（例如sync, copy, ls ）时，rclone通常会列出一个目录并在使用更多目录列表处理任何子目录之前对其进行处理。这可以并行化，前且使用最少的内存可以非常快速地工作。</p>
<p>但是，某些云存储可以在一个（或少量）事务中列出目录下的所有文件。它些往往是基于bucket的云存储（例如S3, B2, GCS, Swift, Hubic）。</p>
<p>如果使用–fast-list标志，则rclone将使用些方法列出目录。这将对列表产生以下影响：</p>
<ul>
<li>它将使用更少的交易</li>
<li>它将使用更多内存，rclone必须将整个列表加载到内存中</li>
<li>它可能更快，因为它使用更少的事务</li>
<li>它可能会更慢，因为它无法并行化</li>
<li>rclone应始终使用和不使用–fast-list提供相同的结果</li>
</ul>
<p>如果您为交易付费并且可以将整个同步列表放入内存中，则建议使用–fast-list。如果你有一个非常大的同步，那么不要使用–fast-list否则你将耗尽内存。如果你在不支持的的云存储上使用–fast-list，那么rclone将忽略它。</p>
<h2 id="3-47-–timeout-x3D-TIME"><a href="#3-47-–timeout-x3D-TIME" class="headerlink" title="3.47 –timeout&#x3D;TIME"></a>3.47 –timeout&#x3D;TIME</h2><p>此参数将设置IO空闲超过。如果传输已经开始但是在这么长时间内变为空闲，则认为它已断开并断开连接。默认为5分钟，设置0为禁用。</p>
<h2 id="3-48-–transfers-x3D-N"><a href="#3-48-–transfers-x3D-N" class="headerlink" title="3.48 –transfers&#x3D;N"></a>3.48 –transfers&#x3D;N</h2><p>并行运行的文件传输数。如果云存储提供大量超时，或者如果你有足够的带宽和快速的云存储，那么将它设置为较小的数字有时会很有用。默认设置是并行运行4个文件传输。</p>
<h2 id="3-49-u-–update"><a href="#3-49-u-–update" class="headerlink" title="3.49 -u, –update"></a>3.49 -u, –update</h2><p>该参数会强制rclone跳过目标上存在的任何文件，并且修改时间比源文件更新。如果现有目标文件的修改时间与源文件的修改时间相等，则在大小不同时将更新。不支持MOD时间的云存储上，检查的时间将是上传的时间。这意味着如果上传到其中一个云存储，rclone将跳过目标上存在的任何文件，并且上传的时间比源文件的修改时间更新。当转移到不直接支持MOD时间的云存储时，这很有用，因为它比–size-only检查更准确，比使用–checksum更快。</p>
<h2 id="3-50-–use-server-modtime"><a href="#3-50-–use-server-modtime" class="headerlink" title="3.50 –use-server-modtime"></a>3.50 –use-server-modtime</h2><p>一些云存储是不保留文件修改时间的（例如：Swift, S3）。在此类的云存储上，rclone将原始的modtime存储为对象的附加元数据。默认情况下，当操作modtime时，它将进行API调用以检索元数据。<br>使用此参数，可以禁用额外的API调有用，而是依赖服务器的修改时间。通常情况下，本地同步远程数据，只要知道本地文件比服务器文件的时间更新就足够了，因此它可以加快进程并减少所需的API调用次数。</p>
<h2 id="3-51-v-w-–verbose"><a href="#3-51-v-w-–verbose" class="headerlink" title="3.51 -v, -w, –verbose"></a>3.51 -v, -w, –verbose</h2><p>使用参数-v，则rclone会返回每个传输文件的少量重要事件；</p>
<p>使用参数-vv，则rclone会返回每个传输文件执行每一步的详细的信息。</p>
<h2 id="3-52-V-–VERSION"><a href="#3-52-V-–VERSION" class="headerlink" title="3.52 -V, –VERSION"></a>3.52 -V, –VERSION</h2><p>显示rclone版本信息</p>
<h1 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h1><p>rclone有4个级别的日志记录，ERROR、NOTICE、INFO和DEBUG。默认情况下，rclone会记录到标准错误。这意味着您可以重定向标准错误并仍然可以看到rclone命令的正常 输出（例如rclone ls）。</p>
<ul>
<li>增加-q标志，则rclone将仅生成错误消息</li>
<li>增加-v标志，rclone将成生错误，通知和信息消息</li>
<li>增加-vv标志，rclone将生成错误，通知，信息和调试消息<br>您还可以使用–log-level标志控制日志级别。如果使用–log-file&#x3D;FILE选项，rclone会将Error，info和Debug消息以及标准错误重定向到FILE。</li>
</ul>
<p>如果使用–syslog标志，则rclone将登录到syslog，而–syslog-facility控制它使用的设施。</p>
<p>Rclone将所有日志消息的前缀加上大写字母的前缀，例如INFO，这样可以轻松地为不同类型的信息grep日志文件。</p>
<h1 id="4-rclone-mount"><a href="#4-rclone-mount" class="headerlink" title="4. rclone mount"></a>4. rclone mount</h1><h2 id="4-1-OneDrive映射至本地"><a href="#4-1-OneDrive映射至本地" class="headerlink" title="4.1 OneDrive映射至本地"></a>4.1 OneDrive映射至本地</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rclone mount One:XXX /volumes/XXX --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --<span class="built_in">umask</span> 000 --daemon</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sudo进阶</title>
    <url>/2021/08/25/sudo%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h3 id="什么是sudo"><a href="#什么是sudo" class="headerlink" title="什么是sudo"></a>什么是sudo</h3><p>sudo是用来执行需要提升权限的命令。</p>
<span id="more"></span>

<h3 id="Sudo配置"><a href="#Sudo配置" class="headerlink" title="Sudo配置"></a>Sudo配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># visudo</span></span><br></pre></td></tr></table></figure>

<ol>
<li><h4 id="sudo执行命令的流程"><a href="#sudo执行命令的流程" class="headerlink" title="sudo执行命令的流程"></a>sudo执行命令的流程</h4><ul>
<li>当用户执行sudo时，系统会主动寻找<code>/etc/sudoers</code>文件，判断该用户是否有执行sudo权限</li>
<li>确认用户具有可执行的权限后，让用户输入自己的密码确认</li>
<li>若密码输入成功，则开始执行sudo后续的命令</li>
</ul>
</li>
<li><h4 id="不需要密码的情况"><a href="#不需要密码的情况" class="headerlink" title="不需要密码的情况"></a>不需要密码的情况</h4><ul>
<li><p>root执行sudo时不需要输入密码（sudoers文件中有配置root ALL&#x3D;(ALL)ALL这样一条规则）</p>
</li>
<li><p>要切换的身份与执行者的身份相同，不需要输入密码</p>
</li>
<li><p><code>/etc/sudoers</code>文件设置为允许用户在不输入该用户密码的情况下使用所有命令</p>
<p>如设置允许wheel用户组中的用户在不输入该用户的密码的情况下使用所有命令</p>
<p><code>%wheel ALL=(ALL) NOPASSWD:ALL</code></p>
</li>
</ul>
</li>
<li><h4 id="etc-sudoers文件解释"><a href="#etc-sudoers文件解释" class="headerlink" title="/etc/sudoers文件解释"></a><code>/etc/sudoers</code>文件解释</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## cat /etc/sudoers</span></span><br><span class="line"><span class="comment">## 下面是规则配置：什么用户在哪台服务器上可以执行哪些命令（sudoers文件可以在多个系统上共享）</span></span><br><span class="line"><span class="comment">## Syntax:</span></span><br><span class="line"><span class="comment">##语法</span></span><br><span class="line"><span class="comment">##      user    MACHINE=COMMANDS</span></span><br><span class="line"><span class="comment">##  用户 登录的主机=（可以变换的身份） 可以执行的命令 </span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## The COMMANDS section may have other options added to it.</span></span><br><span class="line"><span class="comment">## 命令部分可以附带一些其它的选项 </span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## Allow root to run any commands anywhere</span></span><br><span class="line"><span class="comment">## 允许root用户执行任意路径下的任意命令</span></span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line"></span><br><span class="line"><span class="comment">## Allows members of the &#x27;sys&#x27; group to run networking, software,</span></span><br><span class="line"><span class="comment">## service management apps and more.</span></span><br><span class="line"><span class="comment"># %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS</span></span><br><span class="line"><span class="comment">## 允许sys中户组中的用户使用NETWORKING等所有别名中配置的命令</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## Allows people in group wheel to run all commands</span></span><br><span class="line"><span class="comment"># %wheel        ALL=(ALL)       ALL</span></span><br><span class="line"><span class="comment">## 允许wheel用户组中的用户执行所有命令 </span></span><br><span class="line"><span class="comment">## Same thing without a password</span></span><br><span class="line"><span class="comment">## 允许wheel用户组中的用户在不输入该用户的密码的情况下使用所有命令</span></span><br><span class="line"><span class="comment"># %wheel        ALL=(ALL)       NOPASSWD: ALL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Allows members of the users group to mount and unmount the</span></span><br><span class="line"><span class="comment">## cdrom as root</span></span><br><span class="line"><span class="comment">## 允许users用户组中的用户像root用户一样使用mount、unmount、chrom命令</span></span><br><span class="line"><span class="comment"># %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Allows members of the users group to shutdown this system</span></span><br><span class="line"><span class="comment"># %users  localhost=/sbin/shutdown -h now</span></span><br><span class="line"><span class="comment">## 允许users用户组中的用户像root用户一样使用shutdown命令</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="sudo执行命令的流程-1"><a href="#sudo执行命令的流程-1" class="headerlink" title="sudo执行命令的流程"></a>sudo执行命令的流程</h4><h3 id="sudo会话"><a href="#sudo会话" class="headerlink" title="sudo会话"></a>sudo会话</h3><p>sudo默认在输入一次密码后15分钟内不会再次要求密码。15分钟后，你会再次被要求输入密码。</p>
<h3 id="sudo重要的参数"><a href="#sudo重要的参数" class="headerlink" title="sudo重要的参数"></a>sudo重要的参数</h3><ol>
<li><h4 id="k参数"><a href="#k参数" class="headerlink" title="-k参数"></a><code>-k</code>参数</h4></li>
</ol>
<p>考虑下这种情况：输入密码后你刚刚运行了几个sudo命令。现在，如你所知，sudo会话默认保持15分钟。假设在这会话期间，你需要让某些人访问你的终端，但你不想让他们可以使用sudo，你将会怎么做？</p>
<p><code>-k</code>的参数，就是允许用户取消sudo权限。</p>
<ol start="2">
<li><h4 id="s参数"><a href="#s参数" class="headerlink" title="-s参数"></a><code>-s</code>参数</h4><p>有时你的工作要求你运行一堆需要root权限的命令，你不想每次都输入密码。你也不想通过改变&#x2F;etc&#x2F;sudoers文件调整sudo会话的过期时限。这种情况可以使用<code>sudo -s</code></p>
<p><code>-s</code>命令行参数给你一个有root权限的shell，但那不是root环境，还是执行的你自己的<code>.bashrc</code></p>
</li>
<li><h4 id="i参数"><a href="#i参数" class="headerlink" title="-i参数"></a><code>-i</code>参数</h4><p><code>-i</code>参数跟我们讨论过的<code>-s</code>参数相像。然而，还是有点区别。一个重要的区别是<code>-i</code>给你的是root环境，意味着你的（用户的）<code>.bashrc</code>被忽略。这就像没有显式地用root登录也能成为root。此外，你也不用输入root用户密码。</p>
</li>
</ol>
<blockquote>
<p>重要：请注意su命令也能让你切换用户（默认切换到root)。这个命令需要你输入root密码。为了避免这一点，你可以使用sudo执行它（<code>sudo su</code>），这样你只需要输入你的登录密码。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>为USBInjectAll.kext创建自定义SSDT</title>
    <url>/2018/11/07/%E4%B8%BAUSBInjectAll-kext%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89SSDT/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在10.11版本中，Apple完全重写了USB驱动程序。新驱动程序似乎在很大程序上使用了ACPI，比以前的驱动程序更大。这给ACPI（DSDT)的正确性带来了更多的压力。如果不正确，存在的端口可能不会被新的驱动程序启用。</p>
<p>事实上，即使是Apple自己的产品也被发现是不正确的，因此Apple公司发明了一种方法用来一个端口注入器来覆盖DSDT。在事件属性被注入来定义可用端口时，这些属性将被使用而不是ACPI。</p>
<p>内置的端口注入器也可以干扰USB接口，因为一个给定型号的Mac的USB拓朴不太可能与你的PC相同。要解决这些问题，可能需要采取一些步骤。</p>
<p>注意本指南适用于英特尔USB3。第三方USB3，例如Asmedia，NEC&#x2F;Renasas还是有问题的。这些控制器没有解决方案。对于不支持的USB3控制器（例如，不是英特尔生产的，不是睿思科技生产的）可以试试最新的<a href="https://github.com/RehabMan/OS-X-Generic-USB3">GenericUSBXHCI.kext</a></p>
<span id="more"></span>

<h2 id="工具-x2F-解决方案的概述"><a href="#工具-x2F-解决方案的概述" class="headerlink" title="工具&#x2F;解决方案的概述"></a>工具&#x2F;解决方案的概述</h2><ul>
<li>选择正确的BIOS选项</li>
<li>在DSDT中使用EHCx-&gt;EH0x重命名</li>
<li>通过XHC到EHCI上，使用FakePCIID_XHCIMux路由（route）USB2设备</li>
<li>用一个自定义的端口注入器或自定义SSDT为USBInjectAll.kext注入端口</li>
<li>使用USBInjectAll.kext来注入端口</li>
<li>在运行OSX时，给DSDT打补丁来模拟Windows的一个版本</li>
</ul>
<h2 id="BIOS选项"><a href="#BIOS选项" class="headerlink" title="BIOS选项"></a>BIOS选项</h2><p>USB选制器的配置通常依赖于BIOS设置。对于大多数个人电脑，你应该设置XHCI为“auto”或”和”smart auto”。这些设置通常会影响与XHCI控制器初始化、USB2路由、USB3端口启用。</p>
<h2 id="禁用默认的注射器"><a href="#禁用默认的注射器" class="headerlink" title="禁用默认的注射器"></a>禁用默认的注射器</h2><p>第一步是确保默认的注入器没有效果。有这两类注入器：</p>
<ul>
<li>控制器（Controller）注入器：这些匹配Mac型号（SMBIOS)和ACPI中的控制器名称（EHC1&#x2F;EHC2&#x2F;XHC1）。</li>
<li>集线器（Hub）端口注入器：这些匹配Mac型号和locationID（基于控制器和端口的地址）。</li>
</ul>
<p>第一类端口注入器很容易通过DSDT补丁来禁用。对于大多数个人电脑（PCs），XHCI控制器（USB3）被命名为“XHC”，因此它不会与使用“XHC1”的内置注入器匹配。EHC1和EHC2通常被mac电脑和个人电脑（PCs）用来识别这两个EHCI控制器（USB2）。通过将EHC1重命名为EH01和将EHC2重命名为EH02，您可以有效地禁用与您所使用的SMBIOS匹配的内置端口注入器。重命名可以通过你打了补丁的DSDT中的<code>find/replace</code>来完成，或者通过Clover的config.plist&#x2F;ACPI&#x2F;DSDT&#x2F;Patches。<br>此类方法可以有效地驱动USB端口，但是对于macOS的每次更新，可通需要创建新的端口限制补丁。</p>
<p>因此，使用端口限制补丁不是一个长期的解决方案。对于可靠的USB，您必须为<a href="https://bitbucket.org/RehabMan/os-x-usb-inject-all/downloads/">USBInjectAll.kext</a>实现自定义SSDT，以便在XHC上配置端口。自定义SSDT方式使得不依赖于任何端口限制补丁，它不仅允许您避免端口限制补丁，而且禁用未使用的USB端口可以具有一定的省电属性，并且可以避免睡眠，重启或关闭时的错误。</p>
<h1 id="自定义SSDT"><a href="#自定义SSDT" class="headerlink" title="自定义SSDT"></a>自定义SSDT</h1><p>自定义SSDT过程包括如下步骤：</p>
<ol>
<li>端口准备</li>
<li>端口发现</li>
<li>为USBInjectAll.kext创建自定义SSDT</li>
<li>测试&#x2F;验证</li>
</ol>
<p><a href="https://bitbucket.org/RehabMan/os-x-maciasl-patchmatic/downloads/">MaciASL工具</a>，确保MaciASL-&gt;Preferences-&gt;iASL中选择了ACPI 6.2a</p>
<h2 id="端口准备"><a href="#端口准备" class="headerlink" title="端口准备"></a>端口准备</h2><p>为了能够正确的为给定的PC配置正确的自定义SSDT，我们必须首先发现所启用的所有端口。一量我们知道了使用哪些端口，我们就可以关闭未使用的端口。首先，先用第一类注入方法也就是在Clover的config.plist&#x2F;ACPI&#x2F;DSDT&#x2F;Patches中注入补丁的方法，注入EXHCx重命名和端口限制补丁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;ACPI&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;DSDT&lt;/key&gt;</span><br><span class="line">        &lt;dict&gt;</span><br><span class="line">            &lt;key&gt;Patches&lt;/key&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;dict&gt;</span><br><span class="line">                    &lt;key&gt;Comment&lt;/key&gt;</span><br><span class="line">                    &lt;string&gt;change EHC1 to EH01&lt;/string&gt;</span><br><span class="line">                    &lt;key&gt;Find&lt;/key&gt;</span><br><span class="line">                    &lt;data&gt;RUhDMQ==&lt;/data&gt;</span><br><span class="line">                    &lt;key&gt;Replace&lt;/key&gt;</span><br><span class="line">                    &lt;data&gt;RUgwMQ==&lt;/data&gt;</span><br><span class="line">                &lt;/dict&gt;</span><br><span class="line">                &lt;dict&gt;</span><br><span class="line">                    &lt;key&gt;Comment&lt;/key&gt;</span><br><span class="line">                    &lt;string&gt;change EHC2 to EH02&lt;/string&gt;</span><br><span class="line">                    &lt;key&gt;Find&lt;/key&gt;</span><br><span class="line">                    &lt;data&gt;RUhDMg==&lt;/data&gt;</span><br><span class="line">                    &lt;key&gt;Replace&lt;/key&gt;</span><br><span class="line">                    &lt;data&gt;RUgwMg==&lt;/data&gt;</span><br><span class="line">                &lt;/dict&gt;</span><br><span class="line">                &lt;dict&gt;</span><br><span class="line">                    &lt;key&gt;Comment&lt;/key&gt;</span><br><span class="line">                    &lt;string&gt;change XHC1 to XHC&lt;/string&gt;</span><br><span class="line">                    &lt;key&gt;Find&lt;/key&gt;</span><br><span class="line">                    &lt;data&gt;WEhDMQ==&lt;/data&gt;</span><br><span class="line">                    &lt;key&gt;Replace&lt;/key&gt;</span><br><span class="line">                    &lt;data&gt;WEhDXw==&lt;/data&gt;</span><br><span class="line">                &lt;/dict&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">        &lt;/dict&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">    &lt;key&gt;KernelAndKextPatches&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;KextsToPatch&lt;/key&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;dict&gt;</span><br><span class="line">                &lt;key&gt;Comment&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;change 15 port limit to 26 in XHCI kext&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;MatchOS&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;10.11.x&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Name&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;com.apple.driver.usb.AppleUSBXHCIPCI&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Find&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g72M/v//EA==&lt;/data&gt;</span><br><span class="line">                &lt;key&gt;Replace&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g72M/v//Gw==&lt;/data&gt;</span><br><span class="line">            &lt;/dict&gt;</span><br><span class="line">            &lt;dict&gt;</span><br><span class="line">                &lt;key&gt;Comment&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;change 15 port limit to 26 in XHCI kext&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;MatchOS&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;10.12.x&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Name&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;com.apple.driver.usb.AppleUSBXHCIPCI&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Find&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g710////EA==&lt;/data&gt;</span><br><span class="line">                &lt;key&gt;Replace&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g710////Gw==&lt;/data&gt;</span><br><span class="line">            &lt;/dict&gt;</span><br><span class="line">            &lt;dict&gt;</span><br><span class="line">                &lt;key&gt;Comment&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;change 15 port limit to 26 in XHCI kext&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;MatchOS&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;10.13.0,10.13.1,10.13.2,10.13.3&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Name&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;com.apple.driver.usb.AppleUSBXHCIPCI&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Find&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g32MEA==&lt;/data&gt;</span><br><span class="line">                &lt;key&gt;Replace&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g32MGw==&lt;/data&gt;</span><br><span class="line">            &lt;/dict&gt;</span><br><span class="line">            &lt;dict&gt;</span><br><span class="line">                &lt;key&gt;Comment&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;disable port limit in XHCI kext (credit PMHeart)&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;MatchOS&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;10.13.4,10.13.5&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Name&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;com.apple.driver.usb.AppleUSBXHCI&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Find&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g32UDw+DlwQAAA==&lt;/data&gt;</span><br><span class="line">                &lt;key&gt;Replace&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g32UD5CQkJCQkA==&lt;/data&gt;</span><br><span class="line">            &lt;/dict&gt;</span><br><span class="line">            &lt;dict&gt;</span><br><span class="line">                &lt;key&gt;Comment&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;change 15 port limit to 26 in XHCI kext (credit FredWst)&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;MatchOS&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;10.13.4,10.13.5&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Name&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;com.apple.driver.usb.AppleUSBXHCI&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Find&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g32UDw+DlwQ=&lt;/data&gt;</span><br><span class="line">                &lt;key&gt;Replace&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g32UGg+DlwQ=&lt;/data&gt;</span><br><span class="line">            &lt;/dict&gt;</span><br><span class="line">            &lt;dict&gt;</span><br><span class="line">                &lt;key&gt;Comment&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;disable port limit in XHCI kext (credit RehabMan, based prior PMHeart patch)&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;MatchOS&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;10.13.6&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Name&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;com.apple.driver.usb.AppleUSBXHCI&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Find&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g32IDw+DpwQAAA==&lt;/data&gt;</span><br><span class="line">                &lt;key&gt;Replace&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g32ID5CQkJCQkA==&lt;/data&gt;</span><br><span class="line">            &lt;/dict&gt;</span><br><span class="line">            &lt;dict&gt;</span><br><span class="line">                &lt;key&gt;Comment&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;disable port limit in XHCI kext (credit PMHeart)&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;MatchOS&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;10.14.x&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Name&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;com.apple.driver.usb.AppleUSBXHCI&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;Find&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g/sPD4MDBQAA&lt;/data&gt;</span><br><span class="line">                &lt;key&gt;Replace&lt;/key&gt;</span><br><span class="line">                &lt;data&gt;g/sPkJCQkJCQ&lt;/data&gt;</span><br><span class="line">            &lt;/dict&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>
<p>禁用了端口限制之后，您应该使用IORegistryExplorer检查端口是否在EHCI和XHCI控制器上为您的芯片组注入了所有预期端口。</p>
<h2 id="端口发现"><a href="#端口发现" class="headerlink" title="端口发现"></a>端口发现</h2><p>为了发现SSDT中需要哪些端口，我们将使用IORegistryExplorer,利用测试USB2和USB3设备测试每个端口，IORegistryExplorer可以跟踪对IOKit对象的更改来确定实际使用的端口（现有对象为黑色，绿色为新对象，红色的为断开连接的对象）。<br><span style="font-weight: bolder;">注意：接下来的所有的测试都要在IOService中进行</span><br>通过插入USB2设备和USB3设备测试每个端口，如果在插入和删除设备时仔细查看，可以看到哪些端口分配给哪个物理端口。<br><span style="font-weight: bolder;">注意：如果您有USB3集线器，则可以更轻松地测试每个端口。由于USB3集线器连接USB3端口的USB2引脚（并且仅可以在USB2端口中使用），并且无需正确弹出操作，因些您会发现使用USB3的速度更快集线器而不是一组USB2&#x2F;USB3记忆棒。在下面的示例中，我使用USB3集线器来测试端口。</span></p>
<p>不要使用IORegistryExplorer.app中的搜索框，只需在左侧窗格中查看ioreg树的正确部分（根据需要滚动以查找适用于您的硬件的EH01&#x2F;EH02&#x2F;XHC）。请注意，要正确测试每个端口，您可能需要将任何USB键盘或鼠标设备移动到不同的端口，以便您可以使用USB2和USB3(或USB3集线器)测试每个端口。</p>
<h2 id="为USBInjectAll-kext创建自定义SSDT"><a href="#为USBInjectAll-kext创建自定义SSDT" class="headerlink" title="为USBInjectAll.kext创建自定义SSDT"></a>为USBInjectAll.kext创建自定义SSDT</h2><p>USBInjectAll.kext以数据驱动方式编码。在kext代码本身中没有任何硬编码。所有数据都包含在info.plist中。当USBInjectAll.kext启动，匹配EH01&#x2F;EH02&#x2F;XHC或连接到EH01&#x2F;EH02端口1的内部集线器时，它会查询info.plist中与其连接的设备相关的配置数据并注入它找到的数据那里。但是SSDT可用于覆盖info.plist中的数据。</p>
<p>SSDT-UIAC-ALL.dsl中提供了一个模板，该模板覆盖了USBInjectAll.kext info.plist中已有的所有数据。您可以将SSDT-UIAC-ALL.dsl编译为SSDT-UIAC-ALL.aml（文件另存为，格式为MaciASL中的ACPI机器语言二进制文件）并将其置于ACPI&#x2F;patched中，尽管info.plist中的所有数据都可以将被SSDT覆盖，不会观察到任何净更改，因为SSDT-UIAC-ALL.dsl中的数据与USBInjectAll.kext info.plist中已有的数据相同。</p>
<p>为了实现我们的更改，我们必须修改SSDT-UIAC-ALL.dsl，使其仅包含我们需要的端口</p>
<p>步骤如下：</p>
<ul>
<li>使用<a href="https://github.com/RehabMan/OS-X-USB-Inject-All/raw/master/SSDT-UIAC-ALL.dsl">SSDT-UIAC-ALL.dsl</a>作为模板</li>
<li>删除不适用于目标硬件的配置节点</li>
<li>从不需要的各个部分中删除端口</li>
<li>更改UsbConnector值以匹配物理硬件&#x2F;端口</li>
</ul>
<p>第一步是从SSDT-UIAC-ALL.dsl中删除不适用于目标硬件和USB配置的配置数据。<br>例如，如果EH01 &#x2F; EH02或相关USB集线器（在PR11 &#x2F; PR21上）没有活动端口，则可以取消EH01 &#x2F; EH02 &#x2F; HUB1 &#x2F; HUB2的配置数据。 在Skylake的情况下，它没有EHCI控制器，因此可以在不需要太多考虑的情况下移除EH01 &#x2F; EH02 &#x2F; HUB1 &#x2F; HUB2配置。 如果您通过BIOS或ACPI（稍后介绍）禁用EHCI，情况也是如此。 并且您可以消除任何与您的XHC设备ID不匹配的XHC配置。 在ioreg中查找您的XHC设备ID。I</p>
]]></content>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程核心（第2版）</title>
    <url>/2018/07/30/python%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83/</url>
    <content><![CDATA[<h1 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h1><h2 id="什么是Python"><a href="#什么是Python" class="headerlink" title="什么是Python"></a>什么是Python</h2><p>Python是一门优雅而健壮的编程语言，它继承了传统编译语言的强大性和通用性，同时也借鉴了简单脚本和解释语言的易用性。它可以帮你完成工作，而且一段时间以后，你还能看明白自己写的这段代码。你会对自己如此快地学会它和它强大的功能感到十分的惊讶，更不用堤你已经完成的工作了。</p>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>贵铎.范.罗萨姆（Guido van Rossum）于1989年底始创了Python，那时，他还在荷兰的CWI（Gentrum voor Wiskunde en Information, 国家数学和计算机科学研究院）。1991年初，Python发布了第一个公开发行版。这一切究竟是如何开始的呢？像C、C++、Lisp、Java和Perl一样，Python来自于某个研究项目，项目中的那些程序员利用手边现有的工具辛苦的工作着，他们设想并开发出了更好的解决办法。</p>
<span id="more"></span>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><p>本章主题</p>
<div class="note primary"><ul>
<li>语句和语法</li>
<li>变量赋值</li>
<li>标识符和关健字</li>
<li>基本风格指南</li>
<li>内存管理</li>
<li>第一个Python程序</li>
</ul>
</div>
<h2 id="语句和语法"><a href="#语句和语法" class="headerlink" title="语句和语法"></a>语句和语法</h2><p>Python语句中有一些基本规则和特殊字符：</p>
<ul>
<li>井号（#）表示之后的字符为Python注释</li>
<li>换行（\）是标准的行分隔符（通常一个语句一行）</li>
<li>反斜线（\）继续上一行</li>
<li>分号（;）将两个语句连接在一行中</li>
<li>冒号（:）将代码块的头和体分开</li>
<li>语句（代码块）有缩进块的方式体现</li>
<li>Python文件以模块的形式组织</li>
</ul>
<h3 id="注释（-）"><a href="#注释（-）" class="headerlink" title="注释（#）"></a>注释（#）</h3><p>Python注释语句从#字符开始，注释可以在一行的任何地方开始，解释器会忽略掉该行#之后的所有内容。</p>
<h3 id="继续（-）"><a href="#继续（-）" class="headerlink" title="继续（\）"></a>继续（\）</h3><p>Python语句，一般使用换行分陋，也就是说一行一个语句。一行过长的语句可以使用反斜杠（\）分解成几行，如下例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># check conditions</span></span><br><span class="line"><span class="keyword">if</span> (weather_is_hot ==<span class="number">1</span>) <span class="keyword">and</span> \</span><br><span class="line">(shark_warnings == <span class="number">0</span>):</span><br><span class="line">send_goto_beach_mesg_to_pager() </span><br></pre></td></tr></table></figure>
<p>三个引号包括下的字符串也可以跨行书写，如下例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># display a string with triple quotes</span></span><br><span class="line"><span class="built_in">print</span> ```hi there, this <span class="keyword">is</span> a long message <span class="keyword">from</span> you</span><br><span class="line">that goes over multiple line... you will find</span><br><span class="line">out soon that triple quotes <span class="keyword">in</span> Python allows</span><br><span class="line">this kind of fun! it <span class="keyword">is</span> like a day on the beach!<span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="多个语句构成代码组（：）"><a href="#多个语句构成代码组（：）" class="headerlink" title="多个语句构成代码组（：）"></a>多个语句构成代码组（：）</h3><p>缩进相同的一组语句构成一个代码块，我们称之代码组。像if、while、def和class这样的复合语句。首行以关键字开始，以冒号（:） 结束，该行之后的一行或多行代码构成代码组。我们将首行及后面的代码组称为一个子句。</p>
<h3 id="代码组由不同的缩进分隔"><a href="#代码组由不同的缩进分隔" class="headerlink" title="代码组由不同的缩进分隔"></a>代码组由不同的缩进分隔</h3><p>Python中规定，同一代码组的代码行必须严格左对齐（左边有同样多的空格或同样多的制表符）。<br>因此核心的风格：缩进四个空格宽度，避免使用制表符</p>
<h3 id="同一行书写多个语句（"><a href="#同一行书写多个语句（" class="headerlink" title="同一行书写多个语句（;)"></a>同一行书写多个语句（;)</h3><p>分号（;）允许你将多个语句写在同一行上，语句之间用分号隔开，而这些语句也不能在这行开始一个新的代码块。这里有一例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys; x = &#x27;foo&#x27; ; sys.stdout.write(x + &#x27;\n&#x27;)</span><br></pre></td></tr></table></figure>
<p>必须指出一点，同一行上书写多个语句会大大降低代码的可读性，Python虽然允许但不提倡你这么做。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>每一个Pyhton脚本文件都可以被当成一个模块。模块以磁盘文件的形式存在。当一个模块变得过大，并且驱动了太多功能的话。就该考虑拆一些代码出来别外建一个模块。模块里的代码可以是一段直接执行的脚本，也可以是一堆类似库函数的代码，从而可以被别的模块导入（import）调用。</p>
<h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>Python语言中，等号（&#x3D;）是主要的赋值运算符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">anInt = -12</span><br><span class="line">aString = &#x27;cart&#x27;</span><br><span class="line">aFloat = -3.1415 * (5.0 ** 2)</span><br><span class="line">anotherString = &#x27;shop&#x27; + &#x27;ping&#x27;</span><br><span class="line">aList = [3.14e10, &#x27;2nd elmt of a list&#x27;, 8.82-4.371j]</span><br></pre></td></tr></table></figure>
<p>“多元”赋值<br>另一种将多个变量同时赋值的方法我们称为多元赋值。这不是官方Python术语，而是我们将”mul-tuple”连在一起自造的。因为采用这种方式赋值时，等号两咪的对象都是元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;a string&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line"><span class="string">&#x27;a string&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>到现在为止，你已经看了不少Python代码的例子。我们本节主题是变量和内存管理的细节，包括：</p>
<ul>
<li>变量无须事先声明<ul>
<li>变量无须指定类型</li>
<li>程序员不用关心内存管理</li>
<li>变量名会被“回收”</li>
<li>del语句能够直接释放资源</li>
</ul>
</li>
</ul>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>大多数编译型语言，变量在使用前必须先声明，其中C语言更加苛刻：变量声明必须位于代码块的最开始，且在任何其他语句之前。其它语言，像C++和java，允许“随时随地”声明变量，比如，变量声明可以在代码块中间，不过仍然必须在变量被使用前声明变量的名字和类型。在Python中，无需此类显式变量声明语句，变量在第一次被赋值时自动声明。和其他大多数语言一样，变量只有被创建和赋值后才能被使用。</p>
<h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><p>还要注意一点，Python中不但变量名无需事先声明，而且也无需类型声明。<b>Python语言中，对象的类型和内存占用都是都是运行时确定的。</b>尽管代码被编译成字节码，Python仍然是一种解释型语言。在创建时，也就是赋值时，解释器会根据语法和右侧的操作数来决定新对象的类型。在对象创建后，一个该对象的应用会被赋值给左侧的变量。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>作为一个负责任的程序员，我们知道在为变量分配内存时，是在借用系统资源，在用完之后，应该释放借用的系统资源。Python解释器承担了内存管理的复杂任务，这大大简化了应用程序的编写。你只需要关心你要解决的问题，至于底层的事情放心交给Python解释器去做就行了。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>要保持追踪内存中的对象，Python使用了引用计数这一简单技术。也就是说Pthon内部记录着所有使用中的对象各有多少引用。一个内部跟踪变量，称为一个引用计数器。至于每个对象各有多少个引用，简称引用计数。当对象被创建时，就创建了一个引用计数，当这个对象不再需要时，也就是说，这个对象的引用计数变为0时，它被垃圾回收。</p>
<p><b>增加引用计数</b><br>当对象被创建（将其引用）赋值给变量时，该对象的引用计数就被设置为1.<br>当同一个对象（的引用）又被赋值给其它变量时，或作为参数传递给函数，方法或类实例时，或者被赋值为一个窗口对象的成员时，该对象的一个新的引用，或者称作别名，就被创建（则该对象的引用计数自动加1）。<br><img src="/3-2.png" alt="有两个引用的同一对象" title="有两个引用的同一对象"><br>请看以下声明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3.14</span></span><br><span class="line">y = x</span><br></pre></td></tr></table></figure>
<p>语句<code>x=3.14</code>创建了一个浮点数对象并将其引用赋值给x。x是第一个引用，因此，该对象的引用计数被设置为1。语句y&#x3D;x创建了一个指向同一对象的别名y。事实上并没有为Y创建一个新对象，而是该对象的引用计数加了1次（变成了2）。这是对象引用计数增加的方式之一。还有一些其它的方式也能增加对象的引用计数，比如该对象作为参数被函数调用或这个对象被加入到某个容器对象当中时。<br>总之，对象的引用会被计数，包含如下情况：</p>
<ul>
<li>对象被创建<code>x = 3.14</code></li>
<li>或另外的别名被创建<code>y = x</code></li>
<li>或被作为参数传递给函数（新的本地引用）<code>foobar(x)</code></li>
<li>或成为容器对象的一个元素<code>myList = [123, x, &#39;xyz&#39;]</code></li>
</ul>
<p><b>减少引用计数</b><br>当对象的引用被销毁时，引用计数会减小。最明显的例子就是当引用离开其作用范围时，这种情况最经常出现在函数运行结束时，所有局部变量都被自动销毁，对象的引用计数也就随之减少。<br>当变量被赋值给另外一个对象时，原对象的引用计数也会自动减1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">foo = <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line">bar = foo</span><br><span class="line">foo = <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>当字符中对象被创建并赋值给foo时，它的引用计数是1，当增加了一个别名bar时，引用计数变成了2.不对当foo被重新赋值给整数对象123时，xyz对象的引用计数自动减1，又重新变成了1.<br>其它造成对象的引用计数减少的方式包括使用del语句删除一个变量，或者当一个对象被移出一个窗口对象时（或该容器对象本身的引用计数变成了0时）。总结一下，一个对象的引用计数在以下情况会减少：</p>
<ul>
<li>一个本地引用离开了其作用范围。比如foobar()函数结束时。</li>
<li>对象的别名被显式的销毁<code>del y # or del x</code></li>
<li>对象的一个别名被赋值给其它的对象<code>x = 123</code></li>
<li>对象被从一个窗口对象中移除<code>myList.remove(x)</code></li>
<li>窗口对象本身被销毁<code>del myList # or goes out-of-scope</code></li>
</ul>
<p><b>del 语句</b><br>Del语句会删除对象一个引用，它的语法是：<br><code>del obj1[,obj2[,...objN]]</code><br>例如，在上例中执行<code>del y</code>会产生两个结果：</p>
<ol>
<li>从现在的名字空间中删除y</li>
<li>x的引用计数减一</li>
</ol>
<p>引申一步，执行del x会删除该对象的最后一个引用，也就是该对象的引用计数会减为0，这会导致该对象从此“无法访问”或“无法抵达”。从此该起，该对象就成为垃圾回收机制的回收对象。注意任何追踪或调试程序会给一个对象增加一个额外的引用，这会推迟该对象被回收的时间。</p>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>不再被使用的内存会被一种称为垃圾收集的机制释放。象上面说的，虽然解释器跟踪对象的引用计数，但垃圾收集器负责释放内存。垃圾收集器是一块独立代码，它用来寻找引用计数为0的对象。它也负责检查那些虽然引用计数大于0但也应该被销毁的对象。特定情形会导致循环引用。<br>一个循环引用发生在当你有至少两个对象互相引用时，也就是说所有的引用都消失时，这些引用仍然存在，这说明只靠引用计数是不够的。Python的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。当一个对象的引用计数变为0，解释器会暂停，释放掉这个对象和仅有这个对象可访问（可以达）的其它对象。作为引用计数的补充，垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。在这种情况下，解释器会暂停下来，试图清理所有未引用的循环。</p>
<h1 id="Python对象"><a href="#Python对象" class="headerlink" title="Python对象"></a>Python对象</h1><h2 id="Python对象-1"><a href="#Python对象-1" class="headerlink" title="Python对象"></a>Python对象</h2><p>Python使用对象模型来存储数据。构造任何类型的值都是一个对象。尽管Python通常当成一种“面向对象的编程语言”，但你完全能够写出不使用任何类和实例的实用脚本。不过Python的对象语法和架构鼓励我们使用这些特性，下面让我们仔细研究一下Python对象。<br>所有的Python对象都拥有三个特性：身份，类型和值</p>
<ul>
<li><b>身份：</b>每一个对象都有一个唯一的身份标识自己，任何对象的身份可以使用内建函数id()来得到。这个值可以被认为是该对象的内存地址。你极少会用到这个值，也不用太关心它究竟是什么。</li>
<li><b>类型：</b>对象的类型决定了该对象可以保存什么类型的值，可以进行什么样的操作，以及遵循什么样的规则。您可以用内建函数type()查看Python对象的类型。因为在Python中类型也是对象，所以type()返回的是对象而不是简单的字符串。</li>
<li><b>值：</b>对象表示的数据项</li>
</ul>
<p>上面三个特性在对象创建的时候就被赋值，除了值之外，其他的两个特性都是只读的。对于新式类型和类，对象的类型也是可以改变的，不过并不推荐初学者这样做。</p>
<p>如果对象支持更新操作，那么它的值就可以改变，否则它的值也是只读的。对象的值是滞可以更改被称为对明的可改变性（mutability），我们会在后面的4.7小节中讨论这个问题。只要一个对象还没有被销毁，这些特性就一直存在。</p>
<p>Python有一系列的基本（内建）数据类型，必要时也可以创建自定义类型来满足你对应用程序的需求。绝大多数应用程序通常使用标准类型，对特定的数据存储则通过创建和实例化类来实现。</p>
<p><span style="font-weight: bold;">对象属性</span></p>
<p>某些Python对象有属性、值或相关联的可执行代码，比如方法（method）。Python用句点（.）标记法来访问属性。属性包括相应对象的名字等，在2.14小节中曾做过介绍。最常用的属性是函数和方法，不过有一些Python类型也有数据属性。含有数据属性的对象包括（但不限于）：类、类实列、模块、复数和文件。</p>
<h2 id="标准类型"><a href="#标准类型" class="headerlink" title="标准类型"></a>标准类型</h2><ul>
<li>数字（分为几个子类型，其中有三个是整型）</li>
<li>Integer 整型</li>
<li>Boolean 布尔型</li>
<li>Long integer 长整型</li>
<li>Floating point real number 浮点型</li>
<li>Complex number 复数型</li>
<li>String 字符串</li>
<li>List 列表</li>
<li>Tuple 元组</li>
<li>Dictionary 字典</li>
</ul>
<h2 id="其他内建类型"><a href="#其他内建类型" class="headerlink" title="其他内建类型"></a>其他内建类型</h2><ul>
<li>类型</li>
<li>Null对象（None）</li>
<li>文件</li>
<li>集合&#x2F;固定集合</li>
<li>函数&#x2F;方法</li>
<li>模块</li>
<li>类</li>
</ul>
<p>这些是当你做Python开发时可能会用到的一个数据类型。我们在这里讨论Type和None类型的使用，除此之外的其他类型在其他章节中讨论。</p>
<h3 id="类型对象和type类型对象"><a href="#类型对象和type类型对象" class="headerlink" title="类型对象和type类型对象"></a>类型对象和type类型对象</h3><p>在本章我们要讨论所有的Python类型，虽然看上去把类型本身也当成对象有点特别，我们还是要在这里提一提。你一定还记得，对象的一系列固有行为和特性（比如支持哪些运算，具有哪些方法）必须事先定义好。从这个角度看，类型正是保存这些信息的最佳位置。描述一种类型所需要的信息不可能用一个字符串来搞定，所以类型不能是一个简单的字符串，这些信息不能也不应该和数据保存在一起，所以我们将类型定义成对象。</p>
<p>下面我们来正式介绍内建函数type()。通过调用type()函数你能够得到特定对象的类型信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">42</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>我们仔细研究一下这个例子，请注意看type函数有趣的返回值。我们得到了一个简洁的输出结果<code>&lt;type &#39;int&#39;&gt;</code>。不过你应当意识到它并不是一个简单地告诉你42是个整型的字符串。你看到的<code>&lt;type &#39;int&#39;&gt;</code>实际上是一个类型对象，碰巧它输出了一个字符串来告诉你它是个int型对象。</p>
<p>现在你该问自己了，那么类型对象的类型是什么？来，我们试验一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">type</span>(<span class="number">42</span>))</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>没错，所有类型对象的类型都是type，它也是所有Python类型的根和所有Python标准类的默认元类（metaclass）。你现在有点搞不明白，没关系，随着我们逐步深入地学习类和类型，你就会慢慢理解。</p>
<p>随着Python2.2中类型和类的统一，类型对象在面向对象编程和日常对象使用中扮演着更加重要的角色。从现在起，类就是类型，实例是对应类型的对象。</p>
<h3 id="None-Python的NULL对象"><a href="#None-Python的NULL对象" class="headerlink" title="None, Python的NULL对象"></a>None, Python的NULL对象</h3><p>Python有一个特殊的类型，被称作NULL对象或者NoneType，它只有一个值，那就是None。它不支持任何运算也没有任何内建方法。如果非常熟悉C语言，就会知道和None类型最接近的C类型就是void，None类型的值和C的NULL值非常相似（其他类似的对象和值包括Perl的undef和Java的void类型与null值）。<br>None没有什么有用的属性，它的布尔值总是False。</p>
<div class="note primary"><p><span style="font-weight: bold;">核心笔记：布尔值</span><br>所有标准对象均可用于布尔测试，同类型的对象之间可以比较大小。每个对象天生具有布尔True或False值。空对象、值为零的任何数字或者NULL对象None的布尔值都是False。<br>下列对象的布尔值是False</p>
<ul>
<li>None</li>
<li>False(布尔类型)</li>
<li>所有的值为零的数</li>
<li>0（整型）</li>
<li>0.0（浮点型）</li>
<li>0L（长整型）</li>
<li>0.0+0.0j(复数)</li>
<li>“”（空字符串）</li>
<li><code>[]</code>（空列表）</li>
<li><code>（）</code>（空元组）</li>
<li><code>{}</code>（空字典）</li>
</ul>
<p>值不是上面列出来的任何值的对象的布尔值都是True，例如non-empty、non-zero等。用户创建的类实例如果定义了nonzero(<strong>nonzero</strong>())或length(<strong>len</strong>())且值为0，那么它们的布尔值就是False。</p>
</div>

<h2 id="内部类型"><a href="#内部类型" class="headerlink" title="内部类型"></a>内部类型</h2><ul>
<li>代码</li>
<li>帧</li>
<li>跟踪记录</li>
<li>切片</li>
<li>省略</li>
<li>Xrange</li>
</ul>
<p>我们在这里简要介绍一下这些内部类型，一般的程序员通常不会直接和这些对象打交道。不过为了这一章的完整性，我们还是在这里介绍一下它们。请参阅源代码或者Python的内部文档和在线文档来获得更详尽的信息。</p>
<p>你如果对异常感到迷惑的话，可以告诉它们是用类来实现的。在老版本的Python中，异常是用字符串来实现的。</p>
<h3 id="代码对象"><a href="#代码对象" class="headerlink" title="代码对象"></a>代码对象</h3><p>代码对象是编译过的Python源代码片码，它是可执行对象。通过调用内建函数compile()可以得到代码对象。代码对象可以被exec命令或eval()内建函数来执行。在第14章将详细研究代码对象。</p>
<p>代码对象本身不包含任何执行环境信息，它是用户自定义函数的核心，在被执行时动态获得上下文。（事实上代码对象是函数的一个属性）一个函数除了有代码对象属性以外，还有一些其他函数必须的属性，包括函数名、文档字符串、默认参数、及全局命名空间等。</p>
<h3 id="帧对象"><a href="#帧对象" class="headerlink" title="帧对象"></a>帧对象</h3><p>帧对象表示Python的执行栈帧。帧对象包含Python解释器在运行时所需要知道的所有信息。它的属性包括指向上一帧的链接，正在被执行的代码对象（参见上文），本地及全局名称空间字典及当前指令等。每次函数调用产生一个新的帧，每一个帧对象者会相应创建一个C栈帧。用到帧对象的一个地方是跟踪记录对象。</p>
<h3 id="跟踪记录对象"><a href="#跟踪记录对象" class="headerlink" title="跟踪记录对象"></a>跟踪记录对象</h3><p>当你的代码出错时，Python就会引发一个异常。如果异常未被捕获和处理，解释器就会退出脚本运行，显示类似下面的诊断信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (innermost last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line N?, <span class="keyword">in</span> ?？？</span><br><span class="line">ErrorName：error reason</span><br></pre></td></tr></table></figure>
<p>当异常发生时，一个包含针对异常的栈跟踪信息的跟踪记录对象被创建。如果一个异常有自己的处理程序，处理程序就可以访问这个跟踪记录对象。</p>
<h3 id="切片对象"><a href="#切片对象" class="headerlink" title="切片对象"></a>切片对象</h3><p>当使用Python扩展的切片语法时，就会创建切片对象。扩展的切片语法允许对不同的索引切片操作，包括步进切片、多维切片和省略切片。多维切片语法sequence[start1:end1,start2:end2]，或使用省略号，seequence[…,start1:end1]。切片对象也可以由内建函数slice()来生成。步进切片允许利用第3个切片元素进行步进切片，它的语法为sequence[起始索引:结束索引:步进值]。Python很早就支持扩展步进切片语法了，但直到Python2.3以前都必须依靠C语言的API或JPython才能工作。下面是几个步进切片的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foostr = <span class="string">&#x27;abcde&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foostr[::-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;edcba&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foostr[::-<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;eca&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foolist = [<span class="number">123</span>, <span class="string">&#x27;xba&#x27;</span>, <span class="number">342.23</span>, <span class="string">&#x27;abc&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foolist[::-<span class="number">1</span>]</span><br><span class="line">[<span class="string">&#x27;abc&#x27;</span>, <span class="number">342.23</span>, <span class="string">&#x27;xba&#x27;</span>, <span class="number">123</span>]</span><br></pre></td></tr></table></figure>

<h3 id="省略对象"><a href="#省略对象" class="headerlink" title="省略对象"></a>省略对象</h3><p>省略对象用于扩展切片语法中，起记号作用。这个对象在切片语法中表示省略号。类似Null对象None，省略对象有一个唯一的名字Ellipsis，它的布尔值始终为True。</p>
<h3 id="XRange对象"><a href="#XRange对象" class="headerlink" title="XRange对象"></a>XRange对象</h3><p>调秀内建函数xrange()会生成一个Xrange对象，xrange()是内建函数range()的兄弟版本，用于需要节省内存使用或range()无法完成的超大数据集场合。在第8章你可以找到更多关于range()和xrange()的使用信息。</p>
<h2 id="标准类型操作符"><a href="#标准类型操作符" class="headerlink" title="标准类型操作符"></a>标准类型操作符</h2><h3 id="对象值的比较"><a href="#对象值的比较" class="headerlink" title="对象值的比较"></a>对象值的比较</h3><p>比较操作符用来判断同类型对象是否相等，所有的内建类型均支持比较运算，比较运算返回布尔值True或False。如果你正在使用的是早于Python2.3版本，因为这些版本还没有布尔类型，所以会看到比较结果为整型值1（代表True）或0（代表False）</p>
<p>注意，实际进行的比较运算因类型而异。换言之，数字类型根据数值的大小和符号比较，字符串按照字符序列值进行比较，等等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> == <span class="number">2</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2.46</span> &lt;= <span class="number">8.33</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span>+<span class="number">4j</span> &gt;= <span class="number">2</span>-<span class="number">3j</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abc&#x27;</span> == <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abc&#x27;</span> &gt; <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abc&#x27;</span> &lt; <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">3</span>, <span class="string">&#x27;abc&#x27;</span>] == [<span class="string">&#x27;abc&#x27;</span>, <span class="number">3</span>]</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">3</span>, <span class="string">&#x27;abc&#x27;</span>] == [<span class="number">3</span>, <span class="string">&#x27;abc&#x27;</span>]</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>不同于很多其他语言，多个比较操作可以在同一行上进行，求值顺序为从左到右。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &lt; <span class="number">4</span> &lt; <span class="number">7</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> &gt; <span class="number">3</span> ==<span class="number">3</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> &lt; <span class="number">3</span> &lt; <span class="number">5</span> != <span class="number">2</span> &lt; <span class="number">7</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>我们会注意到比较操作是针对对象的值进行的，也就是说比较的是对象的数值而不是对象本身。在后面的部分我们会研究对象身份的比较。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>expr1 &lt; expr2</td>
<td>expr1 小于 expr2</td>
</tr>
<tr>
<td>expr1 &gt; expr2</td>
<td>expr1 大于 expr2</td>
</tr>
<tr>
<td>expr1 &lt;&#x3D; expr2</td>
<td>expr1 小于等于 expr2</td>
</tr>
<tr>
<td>expr1 &gt;&#x3D; expr2</td>
<td>expr1 大于等于 expr2</td>
</tr>
<tr>
<td>expr1 &#x3D;&#x3D; expr2</td>
<td>expr1 等于 expr2</td>
</tr>
<tr>
<td>expr1 !&#x3D; expr2</td>
<td>expr1 不等于 expr2（C风格）</td>
</tr>
<tr>
<td>expr1 &lt;&gt; expr2</td>
<td>expr1 不等于 expr2（ABC&#x2F;Pascal风格）</td>
</tr>
</tbody></table>
<p>Python3.0已经不支持<code>&lt;&gt;</code>，建议你一直使用<code>!=</code>操作符。</p>
<h3 id="对象身份比较"><a href="#对象身份比较" class="headerlink" title="对象身份比较"></a>对象身份比较</h3><p>作为对值比较的补充，Python也支持对象本身的比较。对象可以被赋值到另一个变量（通过引用）。因为每个变量都指向同一个（共享的）数据对象，只要任何一个引用发生改变，该对象的其他的引用也会随之改变。</p>
<p>为了方便大家理解，最好先别考虑变量的值，而是将变量名看作对象的一个链接，让我们来看以下三个例子：</p>
<p><span style="font-weight: bold;">例1：foo1和foo2指向相同的对象</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">foo1 = foo2 = <span class="number">4.3</span></span><br></pre></td></tr></table></figure>
<p><img src="/4-1.png" alt="图4-1" title="foo1和foo2指向相同的对象"></p>
<p>当你从值的观点看这条语句时，它表现的只是一个多重赋值，将4.3这个值赋给了foo1和foo2这两个变量。这当然是对的，不过它还有另一层含义。事实是一个值为4.3的数字对象被创建，然后这个对象的引用被赋值给foo1和foo2，结果就是foo1和foo2指向同一个对象。图4-1演示了一个对象两个引用。</p>
<p><span style="font-weight: bold;">例2：foo1和foo2指向相同的对象</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">foo1 = <span class="number">4.3</span></span><br><span class="line">foo2 = foo1</span><br></pre></td></tr></table></figure>
<p>这个例子非常类似上一个，一个值为4.3的数值对象被创建，然后赋给一个变量，当执行foo2 &#x3D; foo1时，foo2被指向foo1所指向的同一个对象，这是因为Python通过传递引用来处理对象。foo2就成为原始值4.3的一个新的引用。这样foo1和foo2就都指向了同一个对象。示意图也图4-1一样。</p>
<p><span style="font-weight: bold;">例3：foo1和foo2指向不同的对象</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">foo1 = <span class="number">4.3</span></span><br><span class="line">foo2 = <span class="number">1.3</span> + <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p><img src="/4-2.png" alt="图4-2" title="foo1和foo2指向不同的对象"><br>这个例子有所不同。首先一个数字对象被创建，然后赋值给foo1。然后第二个数值对象被创建并赋值给foo2。尽管两个对象保存的是同样大小的值，但事实上系统中保存的都是两个独立的对象，其中foo1是第一个对象的引用，foo2则是第二个对象的引用。上图演示给我们这里有两个不同的对象，尽管这两个对象有同样大小的数值。我们为什么在示意图中使用盒子？没错，对象就像一个装有内容的盒子。娄一个对象被赋值到一个变量，就像在这个盒子上贴了一个标签，表示创建了一个引用。每当这个对象有了一个新的引用，就会在盒子上新贴一张标签。当一个引用被销毁时，这个标签就会被撕掉。当所有的标签都被撕掉时，这个盒子就会被回收。那么，Python是怎么知道这个盒子有多少个标签呢？</p>
<p>每个对象都天生具有一个计数器，记录它自己的引用次数。这个数目表示有多少个变量指向该对象。这也就是我们之前提到的引用计数。Python提供了is和is not操作行来测试两个变量是否指向同一个对象。像下面这样执行一个测试。<br><code>a is b</code><br>这个表达式等价于下面的表达式。<br><code>id(a) == id(b)</code><br>对象身份比较操作符拥有同样的优先级。在下面的例子里，我们创建了一个变量，然后将第二个变量指向同一个对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">5</span>, <span class="string">&#x27;hat&#x27;</span>, -<span class="number">9.3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> <span class="keyword">not</span> b </span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">2.5e-5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">2.5e-5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">5</span>, <span class="string">&#x27;hat&#x27;</span>, -<span class="number">9.3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b </span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> <span class="keyword">not</span> b </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>is与not标识符都是Python关键字</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>obj1 is obj2</td>
<td>obj1和obj2是同一个对象</td>
</tr>
<tr>
<td>obj1 is not obj2</td>
<td>obj1和obj2不是同一个对象</td>
</tr>
</tbody></table>
<div class="note primary"><p><span style="font-weight: bold;">核心笔记：实践</span><hr/><br>在上面的例子中，你会注意到我们使用的浮点型而不是整型。为什么会这样？整型对象和字符串对象是不可变对象，所以Python会很高效地缓存它们。它会造成我们认为Python应该创建新对象时，它却没有创建新对象的假象。请看下面例子。<br><code>&gt;&gt;&gt;</code> a &#x3D; 1<br><code>&gt;&gt;&gt;</code> id(a)<br>8402824<br><code>&gt;&gt;&gt;</code> b &#x3D; 1<br><code>&gt;&gt;&gt;</code> id(b)<br>8402824<br><code>&gt;&gt;&gt;</code> c &#x3D; 1.0<br><code>&gt;&gt;&gt;</code> id(c)<br>8651220<br><code>&gt;&gt;&gt;</code> d &#x3D; 1.0<br><code>&gt;&gt;&gt;</code> id(d)<br>8651204<br>在上面的例子中，a和b指向了相同的整型对象，但是c和d并没有指向相同的浮点型对象。如果我们是纯粹主义都，我们会希望a与b能和c与d一样，因为我们本意就是为了创建两个整型对象，而不是像b&#x3D;a这样的结果。<br>Python仅缓存简单整型，因为它认为在Python应用程序中这些小整型会经常被用到。当我们在写作本书的时候，Python缓存的整型范围是（-1,100），不过这个范围是会改变的，所以请不要在你的应用程序使用这个特性。<br>Python2.3中决定，在预定义缓存字符串表之外的字符串，如果不再有任何引用指向它，那这个字符串将不会被缓存。也就是说，被缓存的字符串将不会像以前那样永生不灭，对象回收器一样可以回收不再被使用的字符串。从Python1.5起提供的用于缓存字符的内建函数intern()也已经不再推荐使用，即将被废弃。</p>
</div>

<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔逻辑操作符and、or和not都是Python关键字，这些操作符的优先级按从高到低的顺序列于下表。not操作符拥有最高优先级，只比所有比较操作符低一级。and和or操作符则相应地再低一级。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>not expr</td>
<td>expr的逻辑非（否）</td>
</tr>
<tr>
<td>expr1 and expr2</td>
<td>expr1和expr2的逻辑与</td>
</tr>
<tr>
<td>expr1 or expr2</td>
<td>expr1和expr2的逻辑或</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = <span class="number">3.1415926536</span>, -<span class="number">1024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x &lt; <span class="number">5.0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> ( x &lt; <span class="number">5.0</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(x &lt; <span class="number">5.0</span>) <span class="keyword">or</span> (y &gt; <span class="number">2.718281828</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(x &lt; <span class="number">5.0</span>) <span class="keyword">and</span> (y &gt; <span class="number">2.718281828</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> (x <span class="keyword">is</span> y)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>前面我们提到过Python支持一个表达式进行多种比较操作，其实这个表达式本质上是由多个隐式的and连接起来的多个表达式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &lt; <span class="number">4</span> &lt; <span class="number">7</span>     <span class="comment"># 与&quot;(3 &lt; 4) and (4 &lt; 7)&quot;一样</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="标准类型内建函数"><a href="#标准类型内建函数" class="headerlink" title="标准类型内建函数"></a>标准类型内建函数</h2><p>除了这些运算符，我们刚才也看到，Python提供了一些内建函数用于这些基本对象类型：cmp(), repr(), str(), type()和等同于repr()函数的反引号（``）运算符。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>cmp(obj1, obj2)</td>
<td>比较obj1和obj2，根据比较结果返回整数i <br> i&lt;0 if obj1&lt;obj2 <br> i&gt;0 if obj1&gt;obj2 <br> i&#x3D;&#x3D;0 if obj1&#x3D;&#x3D;obj2</td>
</tr>
<tr>
<td>repr(obj) 或 `obj`</td>
<td>返回一个对象的字符串表示</td>
</tr>
<tr>
<td>str(obj)</td>
<td>返回对象适合可读性好的字符串表示</td>
</tr>
<tr>
<td>type(obj)</td>
<td>得到一个对象的类型， 并返回相应的type对象</td>
</tr>
</tbody></table>
<h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p>在Python2.2以前，type()是内建函数，不过从那时起它变成了一个“工厂函数”。现在你仍然可以将type()仅仅当成一个内建函数来看，type()用法如下：<br><code>type(object)</code><br>type()接受一个对象做为参数，并返回它的类型。它的返回值是一个类型对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">4</span>)  <span class="comment">#int type</span></span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;hello world&#x27;</span>)  <span class="comment">#string type</span></span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;string&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">type</span>(<span class="number">4</span>))  <span class="comment"># type type</span></span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的例子里，我们通过内建函数type()得到一个整型和一个字符串的类型；为了确认一下类型本身也是类型，我们对type()的返回值再次调用type()。注意type()有趣的输出，它看上去不像一个典型的Python数据类型，比如一个整型或一个字符串，一些东西被一个大于号和一个小号包裹着。这种语法是为了告诉你它是一个对象。每个对象都可以实现一个可打印的字符串表示。不过并不总是这样，对那些不容易显示的对象。每个对象都可以实现一个可打印的字符串表示。不过并不总是这样，对那些不容易显示的对象来说，Python会以一个相对标准的格式表示这个对象，格式通常是这种形式：<code>&lt;object_something_or_another&gt;</code>，以这种形式显示的对象通常会提供对象类别、对象id或位置，或者其他合适的信息。</p>
<h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp()"></a>cmp()</h3><p>内建函数cmp()用于比较两个对象obj1和obj2，如果obj1小于obj2，则返回一个负整数，如果obj1大于obj2则返加一个正整数，如果obj1等于obj2，则返回0。它的行为非常类似于C语言的strcmp()函数。比较是在对象之间进行的，不管是标准类型对象还是用户自定义对象。如果是用户自定议对象，cmp()会调用该类的特殊方法__cmp__()。在第13章会详细介绍类的这些特殊方法。下面是几个使用cmp()内建函数的对数值和字符串对象进行比较的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = -<span class="number">4</span>, <span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(a,b)</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(b,a)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = -<span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(a,b)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(a,b)</span><br><span class="line">-<span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(b,a)</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(a,b)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="str-和repr-及-运算符"><a href="#str-和repr-及-运算符" class="headerlink" title="str()和repr()及``运算符"></a>str()和repr()及``运算符</h3><p>内建函数str()和repr()或反引号运算符（``）可以方便的以字符串方式获取对象的内容、类型、数据属性信息。str()函数得于的字符串可读性如，而repr（）函数得到的字符串通常可以用来重新获得该对象，通常情况下obj&#x3D;&#x3D;eval(repr(obj))这个等式是成立的。这两个函数授受一个对象做为其参数，返回适当的字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">4.53</span>-<span class="number">2j</span>)</span><br><span class="line"><span class="string">&#x27;(4.53-2j)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">2e10</span>)</span><br><span class="line"><span class="string">&#x27;20000000000.0&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>([<span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>])</span><br><span class="line"><span class="string">&#x27;[0, 5, 9, 9]&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>([<span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>])</span><br><span class="line"><span class="string">&#x27;[0, 5, 9, 9]&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>`[<span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>]`</span><br><span class="line"><span class="string">&#x27;[0, 5, 9, 9]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>尽管str()，repr()和``运算在特性和功能方面都非常相似，事实上repr()和``做的是完全一样的事情，它们返回的是一个对象“官方”字符串表示，也就是说绝大多数情况下可以通过求值运算（eval()）重新得到该对象，但str()则有所不同。str()致力于生成一个对象的可读性好的字符串表示，它返回结果通常无法用于eval()求值，但很适用于print语句输出。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;也就是说repr()输出对Python比较友好，而str()的输出对人比较友好。虽然如此，很多情况下这三者输出仍然都是完全一样的。<br>&lt;%note primary%&gt;<br><span style="font-weight: bold;">核心笔记：为什么我们有了repr()不需要``</span><br>在Python学习过程中，你偶尔会遇到某个操作符和某个函数是做同样一件事情。这所以如此是因为某些场合函数会比操作符更适合使用。举个例子，当处理类似函数这样的可执行对象或根据不同的数据项调用不同的函数处理时，函数就比操作符用起来方便。另一个例子就是双星号（<strong>）乘方运算和POW()内建函数，x</strong>y和pow(x,y)执行的都是x的y次方<b>需要注意一点是python社区不鼓励使用``</b><br>&lt;%endnote%&gt;</p>
<h3 id="type-和isinstance"><a href="#type-和isinstance" class="headerlink" title="type()和isinstance()"></a>type()和isinstance()</h3><p>Python不支持方法或函数重载，因此你心须自己保证调用的就是你想要的函数或对象。幸运的是，我们前面提到的type()内建函数可以帮助你确认这一点。一个名字里究竟保存的是什么？相当多，尤其是这是一个类型的名字时。确认接收到的类型对象的身份有很多时候都是很有用的。为了达到此目的，Python提 供了一个内建函数type()。type()返回任意Python对象的类型，而不局限于标准类型。让我们通过交互式解释器来看几个使用type()内建函数返回多种对象类型的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(s)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">100</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">0</span>+<span class="number">0j</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;complex&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">0L</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;long&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">0.0</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;float&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>([])</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(())</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(&#123;&#125;)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">type</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Foo</span>: <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">object</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Foo)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;classobj&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(foo)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;instance&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Bar)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(bar)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Bar&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>Python2.2统一了类型和类，如果你使用的是低于Python2.2的解释器，你可能看到不一样的输出结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;string&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">0L</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;long int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(&#123;&#125;)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;dictionary&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">type</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;builtin_function_or_method&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Foo)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;class&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(foo)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;instance&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>除了内建函数type()，还有一个有用的内建函数叫做ininstance()。我们会在第13章（面向对象编程）正式研究这个函数，不过在这里我们还是要简要介绍一下如何利用它来确认一个对象的类型。</p>
<p><span style="font-weight: bold;">1. 举例</span></p>
<p>在例4.1中我们提供了一段脚本来演示在运行时环境使用ininstance()和type()函数。随后我们讨论type()的使用，以及怎么将这个例子移植为改用isinstance()。运行typechk.py，我们会得到以下输出。<br><span style="font-weight: bold;color: blue"><br>-69 is a number of type: int<br>9999999999999999999 is a number of type: long<br>98.6 is a number of type: float<br>(-5.2+1.9j) is a number of type: complex<br>xxx is not a number at all!!<br></span></p>
<p><span style="font-weight: bold;">例4.1 检查类型（typechk.py）</span><br>函数displayNumType()接受一个数值参数，它使用内建函数type()来确认数值的类型（或不是一个数值类型）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">displayNumType</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span> num, <span class="string">&#x27;is&#x27;</span>,</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(num, (<span class="built_in">int</span>, long, <span class="built_in">float</span>, <span class="built_in">complex</span>)):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;a number of type:&#x27;</span>, <span class="built_in">type</span>(num).__name__</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;not a number at all!!&#x27;</span></span><br><span class="line"></span><br><span class="line">displayNumType(-<span class="number">69</span>)</span><br><span class="line">displayNumType(<span class="number">99999999999999999999L</span>)</span><br><span class="line">displayNumType(<span class="number">98.6</span>)</span><br><span class="line">displayNumType(-<span class="number">5.2</span>+<span class="number">1.9j</span>)</span><br><span class="line">displayNumType(<span class="string">&#x27;xxx&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><span style="font-weight: bold;">2. 例子进阶</span><br>（1）原始：这个完成同样功能的函数与本书第一版中的例子已经大不相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">displayNumType</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span> num, <span class="string">&quot;is&quot;</span>,</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(num) == <span class="built_in">type</span>(<span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;an integer&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span>(num) == <span class="built_in">type</span>(<span class="number">0L</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;a long&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span>(num) == <span class="built_in">type</span>(<span class="number">0.0</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;a float&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span>(num) == <span class="built_in">type</span>(<span class="number">0</span>+<span class="number">0j</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;a complex number&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;not a number at all!!&#x27;</span></span><br></pre></td></tr></table></figure>
<p>由于Python奉行简单但是比较慢的方式，所以我们必须这么做，看一眼我们原来的条件表达式：<br><code>if type(num) == type(0)... </code></p>
<p>（2）减少函数调用的次数</p>
<p>如果我们仔细研究一下我们的代码，会看到我们调用了两次type()。要知道每次调用函数都会付出性能代价，如果我们能减少函数的调用次数，就会提高程序的性能。<br>利用在本章我们前面提到的types模块，我们还有另一种比较对象类型的方法，那就是将检测得到的类型与一个已知类型进行比较。如果这样，我们就可以直接使用type对象而不用每次计算出这个对象来。那么我们现在修改一下代码，改为只调用一次type()函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="built_in">type</span>(num) == types.IntType...</span><br></pre></td></tr></table></figure>

<p>(3) 对象值比较VS对象身份比较</p>
<p>在这一章的前面部分我们讨论了对象的值比较和身份比较，如果你了解其中的关键点，你就会发现人们的代码在性能上还不是最优的。在运行时期，只有一个类型对象来表示整型类型。也就是说，type(0)，type(42)，type(-100)都是同一个对象&lt;type ‘int’&gt;（types.IntType也是这个对象）。</p>
<p>如果它们是同一个对象，我们为什么还要浪费时间去获得并比较它们的值呢（我们已经知道它们是相同的了）？所以比较对象本身是一个更好地方案。下面是改进后的代码。<br><code>if type(num) is types.IntType... # or type(0)</code><br>这样做有意义吗？我们用对象身份的比较来替代对象值的比较。如果对象是不同的，那意味着原来的变量一定是不同类型的（因为每一个类型只有一个类型对象），我们就没有必要去检查（值）了。一次这样的调用可能无关紧要，不过当很多类似的代码遍布在你的应用程序中的时候，就有影响了。</p>
<p>（4）减少查询次数<br>这是一个对前一个例子较小的改进，如果你的程序像我们的例子中做很多次比较的话，程序的性能就会有一些差异。为了得到整型的对象类型，解释器不得不首先查找types这个模块的名字，然后在该模块的字典中查找IntType。通过使用from-import，你可以减少一次查询。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> IntType</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(num) <span class="keyword">is</span> IntType...</span><br></pre></td></tr></table></figure>

<p>(5) 惯例和代码风格</p>
<p>Python2.2对类型和类的统一导致ininstance()内建函数的使用率大大增加。我们将在第13章（面向对象编程）正式介绍ininstance()，在这里我们简单浏览一下。</p>
<p>这个布尔函数接受了一个或多个对象作为其参数，由于类型和类现在都是一回事，int现在既是一个类型又是一个类。我们可以使用ininstance()函数来让我们的if语句更方便，并具有更好的可读性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(num, <span class="built_in">int</span>)...</span><br></pre></td></tr></table></figure>
<p>在判断对象类型时也使用ininstance()已经被广为接受，我们上面的typechk.py脚本最终与改成了使用ininstance()函数。值得一提的是，ininstance()接受一个类型对象的元组作为参数，这样我们就不必像使用type()时那样写一堆if-elif-else判断了。</p>
<h3 id="Python类型操作符和内建函数总结"><a href="#Python类型操作符和内建函数总结" class="headerlink" title="Python类型操作符和内建函数总结"></a>Python类型操作符和内建函数总结</h3><p>下表列出了所有操作符和内建函数，其中操作符顺序是按优先级从高到低排列的。同一种灰度的操作符拥有同样的优先级。注意在operator模块中有这些（和绝大多数Python）操作符相应的同功能的函数可供使用。</p>
<table>
<thead>
<tr>
<th>操作符&#x2F;函数</th>
<th>描述</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>cmp(obj1, obj2)</td>
<td>比较两个对象</td>
<td>int</td>
</tr>
<tr>
<td>repr(obj)</td>
<td>对象的字符串表示</td>
<td>str</td>
</tr>
<tr>
<td>str(obj)</td>
<td>对象的字符串表示</td>
<td>str</td>
</tr>
<tr>
<td>type(obj)</td>
<td>检测对象的类型</td>
<td>type</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>bool</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>bool</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于或等于</td>
<td>bool</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于或等于</td>
<td>bool</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>等于</td>
<td>bool</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
<td>bool</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
<td>bool</td>
</tr>
<tr>
<td>is</td>
<td>是</td>
<td>bool</td>
</tr>
<tr>
<td>is not</td>
<td>不是</td>
<td>bool</td>
</tr>
<tr>
<td>not</td>
<td>逻辑反</td>
<td>bool</td>
</tr>
<tr>
<td>and</td>
<td>逻辑与</td>
<td>bool</td>
</tr>
<tr>
<td>or</td>
<td>逻辑或</td>
<td>bool</td>
</tr>
</tbody></table>
<h2 id="类型工厂函数"><a href="#类型工厂函数" class="headerlink" title="类型工厂函数"></a>类型工厂函数</h2><p>Python2.2统一了类型和类，所有的内建类型现在也都是类，在这基础之上，原来的所谓内建转换函数像int()、type()、list()等，现在都成了工厂函数。也就是说虽然他们看上去有点像函数，实质上他们是类。当你调用它们时，实际上是生成了该类型的一个实例，就像工厂生产货物一样。<br>下面这些大家熟悉的工厂函数在之前的Python版里被称为内建函数。</p>
<ul>
<li>int(), long(), float(), complex()</li>
<li>str(), unicode(), basestring()</li>
<li>list(), tuple()</li>
<li>type()</li>
</ul>
<p>以前没有工厂函数的其他类型，现在也都有了工厂函数。除此之外，那些支持新式类的全新的数据类型，也添加了相应的工厂函数。下面列出了这些工厂函数。</p>
<ul>
<li>dict()</li>
<li>bool()</li>
<li>set(), frozenset()</li>
<li>object()</li>
<li>classmethod()</li>
<li>staticmethod()</li>
<li>super()</li>
<li>property()</li>
<li>file()</li>
</ul>
<h2 id="标准类型的分类"><a href="#标准类型的分类" class="headerlink" title="标准类型的分类"></a>标准类型的分类</h2><p>如果让我们最啰嗦地描述标准类型，我们也许会称它们是Python的“基本内建数据对象原始类型”。</p>
<ul>
<li>“基本”是指这些类型都是Python提供的标准或核心类型。</li>
<li>“内建”是由于这些类型是Python默认就提供的。</li>
<li>“数据”是因为他们用于一般数据存储。</li>
<li>“对象”是因为对象是数据和功能的默认抽象。</li>
<li>“原始”是因为这些类型提供的是最底层的粒度数据存储。</li>
<li>“类型”是因为他们就是数据类型。</li>
</ul>
<p>不过，上面这些描述实际上并没有告诉你每个类型如何工作，以及它们能发挥什么作用。事实上，几个类型共享某一些的特性，比如功能的实现手段，另一些类型则在访问数据值方面有一些共同之处。我们感兴趣的还有这些类型的数据如何更新，以及它们能提供什么样的存储。有3种不同的模型可以帮助我们对基本类型进行分类，每种模型都展示给我们这些类型之间的相互关系。这些模型可以帮助我们更好的理解类型之间的相互关系以及他们的工作原理。</p>
<h3 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h3><p>我们对类型进行分类的第一种方式，就是看看这种类型的对象能保存多少个对象。Python的类型，就像绝大多数其他语言一样，能容纳一个或多个值。一个能保存单个字面对象的类型，我们称它为原子或标量存储；那些可容纳多个对象的类型，我们称之为容器存储（容器对象有时会在文档中被称为复合对象，不过这些对象并不仅仅指类型，还包括类似类实例这样的对象）。容器类型又带来一个新问题，那就是它是否可以容纳不同类型的对象。所有的Python容器对象都能够容纳不同类型的对象。下表按存储模型对Python的类型进行了分类。</p>
<p>字符串看上去像一个容器类型，因为它“包含”字符（并且经常多于一个字符），不过由于Python并没有字符类型，所以字符串是一个自多包含的文字类型。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>Python类型</th>
</tr>
</thead>
<tbody><tr>
<td>标量&#x2F;原子类型</td>
<td>数值（所有的数值类型），字符串（全部是文字）</td>
</tr>
<tr>
<td>容器类型</td>
<td>列表、元组、字典</td>
</tr>
</tbody></table>
<h3 id="更新模型"><a href="#更新模型" class="headerlink" title="更新模型"></a>更新模型</h3><p>另一种对标准类型进行分类的方式就是，针对每一个类型问一个问题：“对象创建成功之后，它的值可以进行更新吗？”在前面我们介绍Python数据类型时曾经提到，某些类型允许他们的值进行更新，而另一些则不允许。可变对象允许他们的值被更新，而不可变对象则不允许他们的值被更改。下表列出了支持更新和不支持更新的类型。</p>
<p>看完这个表之后，你可能马上冒出一个问题：“等等，你说数值和字符串对象是不可改变的？”看看下面的例子！”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&#x27;Python numbers and strings&#x27;</span></span><br><span class="line">x = <span class="string">&#x27;are immutable?!? What gives?&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>“在我看来，这可不像是不可变对象的行为！”没错，是这样，不过你还没有搞清楚幕后的真相。上面的例子中，事实上是一个新的对象被创建，然后它取代了旧对象。就是这样，请多读一遍这段。</p>
<p>新创建的对象被关联到原来的变量名，旧对象被丢弃，垃圾回收器会在适当的时机回收这些对象。你可以通过内建函数id()来确认对象的身份在两次赋值前后发生了变化。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>Python类型</th>
</tr>
</thead>
<tbody><tr>
<td>可变类型</td>
<td>列表、字典</td>
</tr>
<tr>
<td>不要变类型</td>
<td>数字、字符串、元组</td>
</tr>
</tbody></table>
<p>下面我们在上面的例子里加上id()调用，就会清楚地看到对象实际上已经被替换了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;Python numbers and strings&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">16191392</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;are immutable?!? what gives?&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">16191232</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">id</span>(i)</span><br><span class="line"><span class="number">7749552</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = i + <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">id</span>(i)</span><br><span class="line"><span class="number">7749600</span></span><br></pre></td></tr></table></figure>
<p>你看到的身份数字很可能和我不同，每次执行这些数字也会不同，这是正常的。这个数字与该对象当时分配的内存地址密切相关。因此不同的机器、不同的妨行时间都会生成不同的对象身份。另一类对象，列表可以被修改而无须替换原始对象，请看下面的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = [<span class="string">&#x27;ammounia&#x27;</span>, <span class="number">83</span>, <span class="number">85</span>, <span class="string">&#x27;lady&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="string">&#x27;ammonia&#x27;</span>, <span class="number">83</span>, <span class="number">85</span>, <span class="string">&#x27;lady&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="number">2</span>]</span><br><span class="line"><span class="number">85</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="built_in">id</span>(aList)</span><br><span class="line"><span class="number">135443480</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="number">2</span>] = aList[<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="number">3</span>] = <span class="string">&#x27;stereo&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="string">&#x27;ammonia&#x27;</span>, <span class="number">83</span>, <span class="number">86</span>, <span class="string">&#x27;stereo&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(aList)</span><br><span class="line"><span class="number">135443480</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList.append(<span class="string">&#x27;gaudy&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList.append(aList[<span class="number">2</span>] +<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="string">&#x27;ammonia&#x27;</span>, <span class="number">83</span>, <span class="number">86</span>, <span class="string">&#x27;stereo&#x27;</span>, <span class="string">&#x27;gaudy&#x27;</span>, <span class="number">87</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(aList)</span><br><span class="line"><span class="number">135443480</span></span><br></pre></td></tr></table></figure>
<p>注意列表的值无论怎么改变，列表的ID始终保持不变。</p>
<h3 id="访问模型"><a href="#访问模型" class="headerlink" title="访问模型"></a>访问模型</h3><p>尽管前面两种模型分类方式在介绍Python时都很有用，它们还不是区分数据类型的首要模型。对这种目的，我们使用访问模型。也就是说根据访问我们存储的数据方式对数据类型进行分类。在访问模型中共有三种访问方式：直接存取、顺序和映射。下表按访问方式对数据类型进行了分类。</p>
<p>对非容器类型可以直接访问。所有的数值类型都归到这一类。</p>
<p>序列类型是指容器内的元素按从0开始的索引顺序访问。一次可以访问一个元素或多个元素，也就是大家所了解的切片（slice）。字符串、列表和元组都归到这一类。我们前面提到过，Python不支持字符类型，因此，虽然字符串是简单文字类型，但因为它有能力按照顺序访问子字符串，所以也将它归到序列类型。</p>
<p>映射类型类似序列的索引属性，不过它的索引并不使用顺序的数字偏移量取值，它的元素无序存放，通过一个唯一的链来访问，这就是映射类型，它容纳的是哈希键-值对的集合。</p>
<p>我们在以后的章节中将主要使用访问模型，详细介绍各种访问模型的类型，以及某个分类的类型之间有哪些相同之处（比如操作符和内建函数），然后讨论每种Python标准类型。所有类型的特殊操作符、内建函数及方法都会在相应的章节特别说明。</p>
<p>为什么要对同样的数据类型再三分类呢？首先，我们为什么要分类？因为Python提供了高级的数据结构，我们需要将那些原始的类型和功能强大的扩展类型区分开来。另一原因就是这有助于搞清楚某种类型应该具有什么行为。举例来说，如果我们基本上不用问自己“列表和元组有什么区别？”或“什么是可变类型和不可变类型？”这些问题的时候，我们也就达到了目的。最后，某些分类中的所有类型具有一些相同的特性。一个优秀的工匠应该知道他或她的工具箱里都有哪些宝贝。</p>
<center><span style="font-weight: bold;">表4.8  以访问模型为标准的类型分类</span></center>

<table>
<thead>
<tr>
<th>分类</th>
<th>Python类型</th>
</tr>
</thead>
<tbody><tr>
<td>直接访问</td>
<td>数字</td>
</tr>
<tr>
<td>顺序访问</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td>映射访问</td>
<td>字典</td>
</tr>
</tbody></table>
<center><span style="font-weight: bold;">表4.9    标准类型分类</span></center>

<table>
<thead>
<tr>
<th>数 据 类 型</th>
<th>存 储 模 型</th>
<th>更 新 模 型</th>
<th>访 问 模 型</th>
</tr>
</thead>
<tbody><tr>
<td>数字</td>
<td>标量</td>
<td>不可更改</td>
<td>直接访问</td>
</tr>
<tr>
<td>字符串</td>
<td>标量</td>
<td>不可更改</td>
<td>顺序访问</td>
</tr>
<tr>
<td>列表</td>
<td>容器</td>
<td>可更改</td>
<td>顺序访问</td>
</tr>
<tr>
<td>元组</td>
<td>容器</td>
<td>不可更改</td>
<td>顺序访问</td>
</tr>
<tr>
<td>字典</td>
<td>容器</td>
<td>可更改</td>
<td>映射访问</td>
</tr>
</tbody></table>
<p>另一个问题就是，“为什么要用这么多不同的模型或从不同的方面来分类？”所有这些数据类型看上去是很难分类的。它们彼此都有着错综复杂的关系，所有类型的共同之处最好能揭示出来，而且我们还想揭示每种类型的独到之处。没有两种类型横跨所有的分类（当然，所有的数值子类型做到了这一点，所以我们将它们归纳到一类当中）。最后，我们确信搞清所有类型之间的关系会对你的开发工作有极大的帮助。你对每种类型的了解越多，你就越能在自己的程序中使用恰当的类型以达到最佳的性能。</p>
<p>我们提供了一个汇总表（表4.9）。表中列出了所有的标准类型和我们使用的三个模型，以及每种类型归入的分类。</p>
<h2 id="不支持的类型"><a href="#不支持的类型" class="headerlink" title="不支持的类型"></a>不支持的类型</h2><p>在我们深入了解各个标准类型之前，我们在本章的结束列出了Python目前还不支持的数据类型</p>
<ul>
<li>char或byte</li>
<li>指针</li>
<li>int vs short vs long</li>
<li>float vs double</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><span style="font-weight: bold;">4-1. Python对象。与所有Python对象有关的三个属性是什么？请简单的描述一下。</span><br>Python对象的三个属性是：ID（身份）、Type（类型）、值（值），身份通过内建函数id()得到，类型通过type()返回对象，除了值以外其余两项都是只读的。</p>
<p><span style="font-weight: bold;">4-2. 类型。不可更改（immutable）指的是什么？Python的哪些类型是可更改的（mutable）,哪些不是？</span><br>可变类型：列表、字典；不可变类型：数字、字符串、元组</p>
<p><span style="font-weight: bold;">4-3. 类型。哪些Python类型是按照顺序访问的，它们和映射类型的不同是什么？</span><br>按顺序访问的类型：字符串、列表、元组，映射类型：字典。映射类型容纳的是哈希键-值对的集合，而序列类型是容器内元素按从0开始的索引顺序访问。</p>
<p><span style="font-weight: bold;">4-4. type()。内建函数type()做什么？type()返回的对象是什么？</span><br>通过调用type()函数你能够得到特定对象的类型信息。所有类型对象的类型都是type，它也是所有Python类型的根和所有Python标准类的默认元类。</p>
<p><span style="font-weight: bold;">4-5. str()和repr()。内建函数str()与repr()之间的不同是什么？哪一个等价于反引号（``）操作符？</span><br>str()与repr()都是标准类型内建函数，它们都返回一个对象的字符串表示。str()在Python2.2中更改了工厂函数。str()返回一个可打印的字符串。repr()可以通过求值运算eval()来重新得到该对象。repr()等价于反引号（``）操作符。</p>
<p><span style="font-weight: bold;">4-6. 对象相等。你认为type(a) &#x3D;&#x3D; type(b)和type(a) is type(b)之间的不同是什么？为什么会选择后者？函数isinstance()与这有什么关系？</span><br>type(a) &#x3D;&#x3D; type(b) 等价于 type(a) is type(b)，选择后者可以减少函数的调用及查询速度。<br>函数isinstance()用来确认一个对象类型，用来判断对象类型，它可以接受一个类型对象的元组做为参数。type()用于检测对象类型。</p>
<p><span style="font-weight: bold;">4-7. 内建函数dir()。在第2章的几个练习中，我们用内建函数dir()做了几个实验，它接受一个对象，然后给出相应的属性。请对types模块做相同的实验。记下你熟悉的类型，包括你对这些类型的认只，然后记下你还不熟悉的类型。在学习Python的过程中，你要逐步将“不熟悉”的类型变得“熟悉”起来。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(b)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(c)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;float&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(d)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(e)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p><span style="font-weight: bold;">4-8. 列表和元组。列表和元组的相同点是什么？不同点是什么？</span><br>列表与元组都是由索引为0开始标记数据类型，列表可以改写，元组不可以改写</p>
<p><span style="font-weight: bold;">4-9. 实践，给以下赋值：<br>a &#x3D; 10 <br>b &#x3D; 10 <br> c &#x3D; 100 <br> d &#x3D; 100 <br> e &#x3D; 10.0 <br> f &#x3D; 10.0 <br> 请问下面各表达式的输出是什么？为什么？<br>(a) a is b <br>(b) c is d <c> e is f </span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> d </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e <span class="keyword">is</span> f</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><div class="note primary"><ul>
<li>数字简介</li>
<li>整型</li>
<li>布尔型</li>
<li>标准整型</li>
<li>长整型</li>
<li>浮点型实数</li>
<li>复数</li>
<li>操作符</li>
<li>内建函数</li>
<li>其他数字类型</li>
<li>相关模块</li>
</ul>
</div>

<p>本章的主题是Python中的数字。我们会详细介绍每一种数字类型，它们适用的各种操作符，以及用于处理数字的内建函数。在本章的末尾，我们简单介绍了几个标准库中用于处理数字的模块。</p>
<h2 id="数字简介"><a href="#数字简介" class="headerlink" title="数字简介"></a>数字简介</h2><p>数字提供了标量贮存和直接访问。它是不可更改类型，也就是说变更数字的值会生成新的对象。当然，这个过程无论对程序员还是对用户都是透明的，并不会影响软件的开发方式。</p>
<p>Python支持多种数字类型：整型、长整型、布尔型、双精度浮点型、十进制浮点型和复数。</p>
<h3 id="如何创建数值对象并用其赋值（数字对象）"><a href="#如何创建数值对象并用其赋值（数字对象）" class="headerlink" title="如何创建数值对象并用其赋值（数字对象）"></a>如何创建数值对象并用其赋值（数字对象）</h3><p>创建数值对象和给变量赋值一样同样简章。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">anInt = <span class="number">1</span></span><br><span class="line">aLong = -<span class="number">99999999999999999999L</span></span><br><span class="line">aFloat = <span class="number">3.14159265358979323846264338322795</span></span><br><span class="line">aComplex = <span class="number">1.23</span>+<span class="number">4.56J</span></span><br></pre></td></tr></table></figure>
<h3 id="如何更新数字对象"><a href="#如何更新数字对象" class="headerlink" title="如何更新数字对象"></a>如何更新数字对象</h3><p>通过给数字对象（重瓣）赋值，您可以“更新”一个数值对象。我们之所以给更新这两个字加上引号，是因为实际上并没有更新该对象的原始数值。这是因为数值对象是不可改变对象。Python的对象模型与常规对象模型有些不同。你所认为的更新实际上是生成了一个新的数值对象，并得到它的引用。</p>
<p>在学习编程的过程中，我们一直接受这样的教育：变量就像一个盒子，里面装着变量的值。在Python中，变量更像一个指针指向装变量值的盒子。对不可改变类型来说，你无法改变盒子的内容，你可以将指针指向一个新盒子。每次将另外的数字赋给变量的时候，实际上是创建了一个新的对象并把它赋给变量（不仅仅是数字，对于所有的不可变类型，都是如此）。</p>
<h3 id="如何删除数字对象"><a href="#如何删除数字对象" class="headerlink" title="如何删除数字对象"></a>如何删除数字对象</h3><p>按照Python的法则，你无法真正删除一个数值对象，你仅仅是不现使用它而已。如果你确实想删除一个数值对象的引用，使用<code>del</code>语句即可。删除对象的引用之后，你就不能再使用这个引用（变量名），除非你给它赋一个新值。如果试图使用一个已经被删除的对象引用，会引发NameError异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> anInt</span><br><span class="line"><span class="keyword">del</span> aLong, aFloat, aComplex</span><br></pre></td></tr></table></figure>
<p>好了，既然你已经了解如何创建和更新数值对象，那么来看一下Python的4种主要数字类型。</p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>Python有几种整型类型。布尔类型是只有两个值的整型。常规整型是绝大多数现代系统都能识别的整型。Python也有长整型类型。然而，它表示的数值大小远超过C语言的长整型。下面我们先来了解一下这些类型，然后再来研究那些用于Python整型类型的操作符和内建函数。</p>
<h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>Python从版本2.3开始支持布尔类型。该类型的取值范围只有两个值，也就是布尔值True和布尔值False。我们会在本章的末尾一节5.7.1详细讲解布尔对象。</p>
<h3 id="标准整型"><a href="#标准整型" class="headerlink" title="标准整型"></a>标准整型</h3><p>Python的标准整型类型是最通用的数字类型。在大多数32位机器上，标准整型类型的取值范围是$-2^{31}$到$2^{31}-1$，也就是-2 147 483 648 ~ 2 147 483 647。如果在64位机器上使用64位编译器编译Python，那么在这个系统上的整型将是64位。下面是一些Python标准整型类型对象的例子。<br><code>0101    84    -237    0x80    017    -680    -0x92</code></p>
<p>Python标准整型等价于C的（有符号）长整型。整型一般以十进制表示，但是Python也支持八进制或十六进制来表示整型。如果八进制整型以数字“0”开始，十六进制整型则以“0x”或“0X”开始。</p>
<h3 id="长整型"><a href="#长整型" class="headerlink" title="长整型"></a>长整型</h3><p>关于Python长整型类型我们必须要提的是，请不要将它和C或其他编译型语言的长整型类型混淆。那些语言的长整型典型的取值范围是32位或64位。Python的长整型类型能表达的数值仅仅与你的机器支持的（虚拟）内存大小有关，换句话说，Python能轻松表达很大的整型。</p>
<p>长整型类型是标准整型类型的超集，当你的程序需要使用比标准整型类型更大的整型时，长整型类型就有用武之地了。在一个整型值后面加个L（大写或小写都可以），表示这个整型是长整型。这个整型可以是十进制、八进制、或十六进制。下面是一些长整型的例子。<br><code>1638L    -0x4E8L    017L-21474836481    052144364L    2997924581    0xDECADEDEADBEEFBADFEEDDEAL    -5432101234L</code></p>
<div class="note primary"><p><span style="font-weight: bold;">核心风格：用大写字母“L”表示长整型</span><hr /><br>尽管Python也支持用小写字母L标记长整型，但是我们郑重推荐您仅使用大写的“L”，这样能有效避免数字1和小写L的混淆。Python在显示长整型类型数值的时候总是用大写“L”，目前整型和长整型正在逐渐缓慢的统一，您只有在对长整型调用repr()函数时才有机会看到“L”，如果对长整型对象调用str()函数就看不到L。举例如下：</p>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aLong = <span class="number">9999999999l</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aLong</span><br><span class="line"><span class="number">9999999999L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> aLong</span><br><span class="line"><span class="number">9999999999</span></span><br></pre></td></tr></table></figure>

<h3 id="整型和长整型的统一"><a href="#整型和长整型的统一" class="headerlink" title="整型和长整型的统一"></a>整型和长整型的统一</h3><p>这两种整型类型正在逐渐统一为一种。在Python2.2以胶，标准整型类型对象超出取值范围会溢出（比如上面提到的大于$2^{32}$的数），但是从Python2.2以后就再也没有这样的错误了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 2.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9999</span> ** <span class="number">8</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">OverflowError: integer exponentiation</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 2.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9999</span> ** <span class="number">8</span> </span><br><span class="line"><span class="number">99920027994400699944002799920001L</span></span><br><span class="line"><span class="comment"># 移除这个错误是第一步。下一步修改位移位，左称位导致出界（导致0值）在过去是经常可能发生的事。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> &lt;&lt; <span class="number">32</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="comment"># 在Python2.3中，这个操作产生一个警告，不过在2.4版本中移除了这个警告，并且这步操作生成了一个直正的长整型。</span></span><br><span class="line"><span class="comment"># Python2.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> &lt;&lt; <span class="number">32</span></span><br><span class="line"><span class="number">8589934592L</span></span><br><span class="line"><span class="comment"># Python2.7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> &lt;&lt; <span class="number">32</span></span><br><span class="line"><span class="number">8589934592</span></span><br></pre></td></tr></table></figure>
<p>不远的将来，至少普通用户会几乎感觉不到长整型的存在。必要时整型会悄悄自动转换为长整型。</p>
<h2 id="双精度浮点型"><a href="#双精度浮点型" class="headerlink" title="双精度浮点型"></a>双精度浮点型</h2><p>Python中的浮点型类似C语言中的double类型，是双精度浮点型，可以用直接的十进制或科学计数法表示。每个浮点型占8个字节（64位），完全遵守IEEE754号规范（52M&#x2F;11E&#x2F;1S），其中52个位用于表示底，11个位用于表示指数（可表示的范围大约是$\pm10^{308.25}$）,剩下的一个位表示符号。这看上去相当完美，然而，实际精度依赖于机器架构和创建Python解释器的编译器。</p>
<p>浮点型值通常都有一个小数点和一个可选的后缀e(大写或小写，表示科学计数法)。在e和指数之间可以用正（+）或负（-）表示指数的正负（正数的话可以省略符号）。下面是一些典型的浮点型值的例子。<br><code>0.0    -777.    1.6    -5.555567119    96e3 * 1.0</code><br><code>4.3e25     9.384e-23    -2.172818    float(12)    1.000000001</code><br><code>3.1416    4.2E-10    -90.     6.022e23    -1.609E-19</code></p>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>在很久以前，数学家们被下面这样的等式困扰。<br>$$x^2 &#x3D; -1$$</p>
<p>这是因为任何实数（无论正数还是负数）乘以自己总是会得到一个非负数。一个数怎么可以乘以自己却得到一个负数？没有这样的实数存在。就这样，直到18世纪，数学家们发明了一个虚拟的数i（或者是j，看你读的是哪本教科书了）。<br>$$j&#x3D;\sqrt{-1}$$</p>
<p>基于这个特殊的数（或者称之为概念），数学从此有了一个新的分支。现在虚数已经广泛应用于数值和科学计算应用程序中。一个实数和一个虚数的组合构成一个复数。一个复数是一对有序浮点型$(x,y)$，表示为$x+yj$,其中x是实数部分，y是虚数部分。</p>
<p>复数渐渐在日常运算、机械、电子等行业获得了广泛的应用。由于一些研究人员不断重复制造用于复数运算的工具，在很久以前的Python1.4版本里，复数终于成为一个真正Python数据类型。</p>
<p>下面是Python语言中的有关复数的几个概念。</p>
<ul>
<li>虚数不能单独存在，它们总是和一个值为0.0的实数部分一起来构成一个复数。</li>
<li>复数由实数部分和虚数部分构成。</li>
<li>表示虚数的语法：real+imagj</li>
<li>实数部分和虚数部分都是浮点型</li>
<li>虚数部分必须有反缀j或J</li>
</ul>
<p>下面是一些复数的例子：<br><code>64.375+1j    4.23-8.5j    0.23-8.55j    1.23e-045+6.7e+089j</code><br><code>6.23+1.5j    -1.23-875J  0+1j    9.80665-8.31441J    -.0224+0j</code> </p>
<h3 id="复数的内建属性"><a href="#复数的内建属性" class="headerlink" title="复数的内建属性"></a>复数的内建属性</h3><p>复数对象拥有数据属性（参见4.1.1节），分别为该复数的实部和虚部。复数还拥有conjugate方法，调用它可以返回该复数的共轭复数对象（两头牛背上的架子称为轭，轭使两头牛同步行走。共轭即为按一定的规律相配的一对–译者注）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aComplex = -<span class="number">8.333</span>-<span class="number">1.47j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aComplex</span><br><span class="line">(-<span class="number">8.333</span>-<span class="number">1.47j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aComplex.real</span><br><span class="line">-<span class="number">8.333</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aComplex.imag</span><br><span class="line">-<span class="number">1.47</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aComplex.conjugate()</span><br><span class="line">(-<span class="number">8.333</span>+<span class="number">1.47j</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属  性</th>
<th>描  述</th>
</tr>
</thead>
<tbody><tr>
<td>num.real</td>
<td>该复数的实部</td>
</tr>
<tr>
<td>num.imag</td>
<td>该复数的虚部</td>
</tr>
<tr>
<td>num.conjugate()</td>
<td>返回该复数的共轭复数</td>
</tr>
</tbody></table>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>数值类型可进行多种运算。从标准操作符到数值操作符，甚至还有专门的整型操作符。</p>
<h3 id="混合模式操作符"><a href="#混合模式操作符" class="headerlink" title="混合模式操作符"></a>混合模式操作符</h3><p>也许你还记得，过去将两个数相加时，你必须努力保证操作数是合适的类型。自然地，加法总是使用+号，然而在计算机语言看来这件事没那么简单，因为数字又有很多不同的类型。</p>
<p>当两个整型相加时，+号表示整型加法，当两个浮点型相加时，+表示浮点型加法，依此类推。在Python中，甚至非数字类型也可以使用+操作符。举例来说，字符串A+字符串B并表示加法操作，它表示的是所这两个字符串连接起来，生成一个新的字符串。关键之处在于支持+操作符的每种数据类型，必须告诉Python，+操作符应该如何去工作。这也体现了重载概念的具体应用。</p>
<p>虽然我们不能让一个数字和一个字符串相加，但Python确实支持不同的数字类型相加。当一个整型和一个浮点型相加时，系统会决定使用整型加法还是浮点型加法（实际上并不存在混合运算）。Python使用数字类型强制转换的方法来解决数字类型不一致的问题，也就是说它会强制将一个操作数转换为同另一个操作数相同的数据类型。这种操作不是随意进行的，它遵循以下基本规则。</p>
<p>首先，如果两个操作数都是同一种数据类型，没有必须进行类型转换。仅当两个操作数类型不一致时，Python才会检查一个操作数是否可以转换为另一类型的操作数。如果可以，转换它并返回转换结果。由于某些转换是不可能的，比如将一个复数转换为非复数类型，将一个浮点型转换为整型等，因此转换过程必须遵守几个规则。</p>
<p>要将一个整型转换为浮点型，只要在整型后面加个“.0”就可以了。要将一个非复数转换为复数，则只需要要加上一个“0j”的虚数部分。这些类型转换的基本原则是：整型转换为浮点型，非复数转换为复数。在Python语言参考中这样描述coerce()方法：</p>
<ul>
<li>如果有一个操作数是复数，另一个操作数被转换为复数</li>
<li>否则，如果有一个操作数是浮点型，另一个操作数被转换为浮点型</li>
<li>否则，如果有一个操作数是长整型，另一个操作数被转换为长整数</li>
<li>否则，两者必然都是普通整型，无须类型转换（参见下文中的示意图）</li>
</ul>
<p>图5-1的流程图阐释了强制转换的规则。数字类型之间的转换是自动进行的，程序员无须自己编码处理类型转换。不过在确实需要明确指定对某种数据类型进行特殊类型转换的场合，Python提供了coerce()内建函数来帮助你实现这种转换（见5.6.2小节）</p>
<p>下面演示一下Python的自动数据类型转换。为了让一个整型和一个浮点型相加，必须使二者转换为同一类型。因为浮点型是超集，所以在运算开始之前，整型必须强制转为一个浮点型，运算结果也是浮点型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> + <span class="number">4.5</span></span><br><span class="line"><span class="number">5.5</span></span><br></pre></td></tr></table></figure>

<p><img src="/5-1.png" alt="图5-1" title="数值类型转换"> </p>
<h3 id="标准类型操作符-1"><a href="#标准类型操作符-1" class="headerlink" title="标准类型操作符"></a>标准类型操作符</h3><p>第4章中讲到的标准操作符都可以用于数值类型。上文中提到的混合模式运算问题，也就是不同数据类型之间的运算，在运算之前，Python内部会将两个操作数转换为同一数据类型。下面是一些数字标准运算的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5.2</span> == <span class="number">5.2</span> </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">719</span> &gt;= <span class="number">833</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span>+4e &gt;= <span class="number">2</span>-3e</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> &lt; <span class="number">5</span> &lt; <span class="number">9</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">77</span> &gt; <span class="number">66</span> == <span class="number">66</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.</span> &lt; -<span class="number">90.4</span> &lt; <span class="number">55.3e2</span> != <span class="number">3</span> &lt; <span class="number">181</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(-<span class="number">1</span> &lt; <span class="number">1</span>) <span class="keyword">or</span> (<span class="number">1</span> &lt; -<span class="number">1</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p>Python支持单目操作符正号（+）和负号（-）；双目操作符<code>+、-、*、/、%和**</code>，分别表示加法、减法、乘法、除法、取余和幂运算。从Python2.2起，还增加了一种新的整除操作符<code>//</code>。</p>
<p><span style="font-weight: bold;">1. 除法</span></p>
<p>拥有C背景的程序员一定熟悉传统除法–也就是说，对整型操作数，会执行“地板除”（floor，取比商小的最大整型。例好5除以2等于2.5，其中“2”就称为商的“地板”，即“地板除”的结果。本书中使用“地板除”的说法是为了沿用原作者的风格，译者注）。对浮点操作数会执行真正的除法。然而，对第一次学编程的人或者那些依赖精确计算的人来说，可能就需要多次调整代码才能得到自己想要的结果。</p>
<p>在未来的Python版本中，Python开发小组已经决定改变&#x2F;操作符的行为。&#x2F;的行为将变更为真正的除法，会增加一种新的运算来表示地板除。下面我们总结一下Python现在的除法规则，以及未来的除法规则。</p>
<p><span style="font-weight: bold;">传统除法</span></p>
<p>如果是整型除法，传统除法会舍去小数部分，返回一个整型（地板除）。如果操作数之一是浮点型，则执行真正的除法。包括Python语言在内的很多语言都是这种行为。请看下面的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> / <span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.0</span> / <span class="number">2.0</span></span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bold;">真正的除法</span></p>
<p>除法运算总是返回真实的商，不管操作数是整型还是浮点型。在未来版本的Python中，这将是除法运算的标准行为。现阶段通过执行from__future__import division指令，也可以做到这一点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> / <span class="number">2</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.0</span> / <span class="number">2.0</span> </span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bold;">地板除</span></p>
<p>从Python2.2开始，一个新的操作符&#x2F;&#x2F;已经被增加进来，以执行地板除：&#x2F;&#x2F;除法不管操作数为何种数值类型，总是舍去小数部分，返回数字序列中比真正的商小的最接近的数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> // <span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.0</span> // <span class="number">2.0</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">1</span> // <span class="number">2</span></span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>关于除法运算的变量，支持的人和反以的人几乎一样多。在些人认为这种变化是错误的，有些人则不想修改自己的现有代码，而剩下的人则想要真正的除法。</p>
<p>之所以会有这种变化是因为Python的核心开发团队认为Python的除法运算从一开始就设计失误。特别是，随着Python的逐渐发展，它已经成为那些从未接触过地板除的人们的首先学习语言。Python语言的创始人在他的“What’s New in Python2.2”一文中讲到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">velocity</span>(<span class="params">distance, totalTime</span>):</span><br><span class="line">    rate = distance / totalTime</span><br></pre></td></tr></table></figure>
<p>你可能会说，只要有一个参数为浮点型这个函数就能正常工作。像上面提到的那样，要确保它能正常工作需要强制将参数转换为浮点类型，也就是<code>rate = float(distance) / float(totalTime)</code>。将来除法将转变为真正的除法，上面的代码可以无需要更改正常工作。需要地板除的地方只需要改变为两个连续的除号。</p>
<p>是的，代码会受一些影响，Python团队已经创作了一系列脚本来帮助你转换旧代码，以确保它能适应新的除法行为。而且对那些强烈需要某种除法行为的人来说，Python解释器提供了Qdivision_style启动参数。-Qnew执行新的除法行为，-Qold则执行传统除法行为（默认为Qold）。你也可以帮助你的用户使用-Qwarn或-Qwarnall参数度过过渡时期。</p>
<p>关于这次变化的详细信息可以参考PEP238。如果你对这场论战感兴趣，也可以翻阅2001年的comp.lang.python归档。表5.2总结了除法操作符在不同Python版本中的行为差异。</p>
<table>
<thead>
<tr>
<th>操 作 符</th>
<th>2.1.x 及更早版本</th>
<th>2.2及更新版本 <br>（No import division）</th>
<th>2.2及更新版本 <br> (import of division)</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;</td>
<td>传统除</td>
<td>传统除</td>
<td>真正除</td>
</tr>
<tr>
<td>&#x2F;&#x2F;</td>
<td>无</td>
<td>地板除</td>
<td>地板除</td>
</tr>
</tbody></table>
<p><span style="font-weight: bold;">2. 取余</span></p>
<p>整型取余相当容易理解，浮点型取余就略复杂些。</p>
<p>商取小于等于精确值的最大整型的乘积之差。即：<code>x-(math.floor(x/y)*y)</code> 或者<br>$$x-\left[\cfrac{x}{y}\right]\times y$$<br>对于复数，取余的定义类似于浮点型，不同之处在于商仅取其实数部分，即<code>x-(math.floor((x/y).real)*y)</code>。</p>
<p><span style="font-weight: bold;">3. 幂运算</span></p>
<p>幂运算操作符和一元操作符之间的优先级关系比较特别：幂运算操作符比其左侧操作数的一元操作符优先级低，比其右侧操作数的一元操作符的优先级高，由于这个特性你会在算术操作符表中找到两个**。下面举几个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">3</span> ** <span class="number">2</span>  <span class="comment"># ** 优先级高于左侧的 -</span></span><br><span class="line">-<span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(-<span class="number">3</span>) ** <span class="number">2</span>  <span class="comment"># 加括号提高 -的优先级</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4.0</span> ** -<span class="number">1.0</span> <span class="comment"># ** 优先级低于右侧的 -</span></span><br><span class="line"><span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<p>第2种情况下解释器先计算3<strong>2再取其相反数，我们需要给“-3”加上括号来得到我们希望的结果。最后一个例子，结果是4</strong>(-1)，这是按照规定的优先级获得的结果。</p>
<p>注意1&#x2F;4作为整型除法结果是0所以以整型为底进行负数指数运算会引发一个negative power（负数指数）异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> ** -<span class="number">1</span></span><br><span class="line">Traceback (innermost last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">ValueError: integer to the negative power</span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bold;">4. 总结</span><br>表5.3总结了所有的算术操作符，从上到下，计算优先级依次降低。这里列出的所有操作符都比即将在5.5.4小节讲到的位操作符优先级高。</p>
<table>
<thead>
<tr>
<th>算术操作符</th>
<th>功    能</th>
</tr>
</thead>
<tbody><tr>
<td>expr1 ** expr2</td>
<td>表达式1表达表达式2结果</td>
</tr>
<tr>
<td>+expr</td>
<td>结果符号不变</td>
</tr>
<tr>
<td>-expr</td>
<td>对结果会号取负</td>
</tr>
<tr>
<td>expr1 ** expr2</td>
<td>表达式1表达表达式2结果</td>
</tr>
<tr>
<td>expr1 * expr2</td>
<td>表达式1乘以表达式2</td>
</tr>
<tr>
<td>expr1&#x2F;expr2</td>
<td>表达式1除以表达式2（传统除或真正除）</td>
</tr>
<tr>
<td>expr1&#x2F;&#x2F;expr2</td>
<td>表达式1地板除以表达式2</td>
</tr>
<tr>
<td>expr1%expr2</td>
<td>表达式1对表达式2取余</td>
</tr>
<tr>
<td>expr1+expr2</td>
<td>表达式1加表达式2</td>
</tr>
<tr>
<td>expr1-expr2</td>
<td>表达式1减表达式2</td>
</tr>
</tbody></table>
<p>下面是更多Python数值运算的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">442</span> - <span class="number">77</span></span><br><span class="line">-<span class="number">519</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> ** <span class="number">3</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4.2</span> ** <span class="number">3.2</span></span><br><span class="line"><span class="number">98.7183139527</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span> / <span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8.0</span> / <span class="number">3.0</span></span><br><span class="line"><span class="number">2.666666667</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span> % <span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">60.</span> -<span class="number">32.</span>) * (<span class="number">5.</span> /<span class="number">9.</span>)</span><br><span class="line"><span class="number">15.5555555556</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">14</span> * <span class="number">0x04</span></span><br><span class="line"><span class="number">56</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>0170 / <span class="number">4</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0x800</span> + 0777</span><br><span class="line"><span class="number">639</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">45L</span> * <span class="number">22L</span></span><br><span class="line"><span class="number">990L</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">16399L</span> + <span class="number">0xA94E8L</span></span><br><span class="line"><span class="number">709879L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">2147483648L</span> - <span class="number">52147483648L</span></span><br><span class="line">-<span class="number">54294967296L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">64.375_1j</span> + <span class="number">4.23</span>-<span class="number">8.5j</span></span><br><span class="line">(<span class="number">68.605</span>-<span class="number">7.5j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span>+<span class="number">1j</span> ** <span class="number">2</span>   <span class="comment"># same as 0+(1j**2)</span></span><br><span class="line">(-<span class="number">1</span>+<span class="number">0j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>+<span class="number">1j</span> ** <span class="number">2</span>   <span class="comment"># same as 1+(1j**2)</span></span><br><span class="line"><span class="number">0j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>+<span class="number">1j</span>) ** <span class="number">2</span></span><br><span class="line"><span class="number">2j</span> </span><br></pre></td></tr></table></figure>
<p>注意指数操作符的优先级高于连接实部和虚部的+号操作符。就上面最后一个例子来说，我们人为的加上了括号，这就改变运算顺序，从而得到我们想要的结果。</p>
<h3 id="位操作符（只适用于整型）"><a href="#位操作符（只适用于整型）" class="headerlink" title="位操作符（只适用于整型）"></a>位操作符（只适用于整型）</h3><p>Python整型支持标准位运算：取反（～），按位与（&amp;）、或（|）和异或（^），以及左移（&lt;&lt;）和右移（&gt;&gt;）。Python这样处理位运算。</p>
<ul>
<li>负数会被当成正数的2进制补码处理。</li>
<li>左移和右移N位等同于无溢出检查的2的N次幂运算：2**N</li>
<li>对长整型来说，位操作符使用一种经修改的2进制补码形式，使得符号位可以无限向左扩展。</li>
</ul>
<p>取反（～）运算的优先级与数字单目操作符相同，是所有位操作符中优先级最高的一个。左移和右移运算的优先级次之，但低于加减法运算。与、或、异或运算优先级最低。所有位操作符按优先级高低列在表5.4中。</p>
<table>
<thead>
<tr>
<th>位 操 作 符</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>~num</td>
<td>单目运算，对数的每一位取反，结果为-(num+1)</td>
</tr>
<tr>
<td>num1 &lt;&lt; num2</td>
<td>num1左移num2位</td>
</tr>
<tr>
<td>num1 &gt;&gt; num2</td>
<td>num1右移num2位</td>
</tr>
<tr>
<td>num1 &amp; num2</td>
<td>num1与num2按位与</td>
</tr>
<tr>
<td>num1 ^ num2</td>
<td>num1异或num2</td>
</tr>
<tr>
<td>num1  num2</td>
<td>num1与num2按位或</td>
</tr>
</tbody></table>
<p>下面是几个使用整型30， 45， 60进行位运算的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">30</span> &amp; <span class="number">45</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">30</span> | <span class="number">45</span></span><br><span class="line"><span class="number">63</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">45</span> &amp; <span class="number">60</span></span><br><span class="line"><span class="number">44</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">45</span> | <span class="number">60</span></span><br><span class="line"><span class="number">61</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>~<span class="number">30</span></span><br><span class="line">-<span class="number">30</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>~<span class="number">45</span></span><br><span class="line">-<span class="number">46</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">45</span> &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">60</span> &gt;&gt; <span class="number">2</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">30</span> ^ <span class="number">45</span></span><br><span class="line"><span class="number">51</span></span><br></pre></td></tr></table></figure>

<h2 id="内建函数与工厂函数"><a href="#内建函数与工厂函数" class="headerlink" title="内建函数与工厂函数"></a>内建函数与工厂函数</h2><h3 id="标准类型函数"><a href="#标准类型函数" class="headerlink" title="标准类型函数"></a>标准类型函数</h3><p>第4章中，我们介绍了cmp()、str()和type()内建函数。这些函数可以用于所有的标准类型。对数字对象来说，这些函数分别比较两个数的大小，将数字转换为字符串，以及返回数字对象的类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(-<span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(-<span class="number">4.333333</span>, -<span class="number">2.718281828</span>)</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(<span class="number">0xFF</span>, <span class="number">255</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">0xFF</span>)</span><br><span class="line"><span class="string">&#x27;255&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">55.3e2</span>)</span><br><span class="line"><span class="string">&#x27;5530.0&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">0xFF</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">98765432109876543210L</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;long&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">2</span>-<span class="number">1j</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;complex&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="数字类型函数"><a href="#数字类型函数" class="headerlink" title="数字类型函数"></a>数字类型函数</h3><p>Python现在拥有一系列针对数字类型的内建函数。一些函数用于数字类型转换，另一些则执行一些常用运算。</p>
<p><span style="font-weight: bold;">1. 转换工厂函数</span></p>
<p>函数int()、long()、float()和complex()用来将其他数值类型转换为相应的数值类型。从Python1.5版本开始，这些函数也接受字符串参数，返回字符串所表示的数值。从Python1.6版开始，int()和long()在转换字符串时，按受一个进制参数。如果是数字类型之间的转换，则这个进制参数不能使用。</p>
<p>从Python2.2起，有了第5个内建函数bool()。这用来将整型值1和0转换为标准布尔值True和False。从Python2.3开始，Python的标准数据类型添加了一个新成员：布尔（Boolean）类型。从此true和false现有有了常量值即True和False（不再是1和0）.要了解布尔类型的更多信息，参阅5.7.1小节。</p>
<p>另外，由于Python2.2对类型和类进行了整合（这里指Python的传统风格类和新风格类–译者注），所有这些内建函数现在都转变为工厂函数。我们普经在第4章介绍过工厂函数，所谓工厂函数就是指这些内建函数都是类对象，当你调用它们时，实际上是创建了一个类实例。</p>
<p>不过不用担心，这些函数的使用方法并没有什么改变。下面是一些使用内建函数的示例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="number">4.25555</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>long(<span class="number">42</span>)</span><br><span class="line"><span class="number">42L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>(<span class="number">4</span>)</span><br><span class="line"><span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">complex</span>(<span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>+<span class="number">0j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">complex</span>(<span class="number">2.4</span>, -<span class="number">8</span>)</span><br><span class="line">(<span class="number">2.4</span>-<span class="number">8j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">complex</span>(<span class="number">2.3e-10</span>, <span class="number">45.3e4</span>)</span><br><span class="line">(<span class="number">2.3e-10</span>+<span class="number">453000j</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类（工厂函数）</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>bool(obj)</td>
<td>返回obj对象的布尔值，也就是obj.<strong>nonzero</strong>()方法的返回值，Python2.3中改为了工厂函数</td>
</tr>
<tr>
<td>int(obj,base&#x3D;10)</td>
<td>返回一个字符串或数值对象的整型表示，类似string.atoi();从Python1.6起，引入了可选 的进制参数</td>
</tr>
<tr>
<td>long(obj,base&#x3D;10)</td>
<td>返回一个字符或数据对象的长整型表示，类假string.atol();从Python1.6起，引入了可选的进制参数</td>
</tr>
<tr>
<td>float(obj)</td>
<td>返回一个字符串或数据对象的浮点型表示，类似string.atof()</td>
</tr>
<tr>
<td>complex(str) or complex(real,inag&#x3D;0.0)</td>
<td>返回一个字符串的复数表示，或者根据给定的实数（及一个可选的虚数部分）生成一个复数的对象</td>
</tr>
</tbody></table>
<p><span style="font-weight: bold;">2. 功能函数</span></p>
<p>Python有5个运算内建函数用于数值运算：abs()、coerce()、divmod()、pow()和round()我们将对这些函数逐一浏览，并给出一些有用的例子。<br>abs()返回给定参数的绝对值。如果参数是一个复数，那么就返回math.sqrt(num.real2 + num.imag2)。下面是几个abs()函数的示例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="number">10.</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="number">1.2</span>-<span class="number">2.1j</span>)</span><br><span class="line"><span class="number">2.41867732449</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="number">0.23</span>-<span class="number">0.78</span>)</span><br><span class="line"><span class="number">0.55</span></span><br></pre></td></tr></table></figure>
<p>函数coerce()，尽管从技术上讲它是一个数据类型转换函数，不过它的行为更像一个操作符，因此我将它放到了这一小节。在5.5.1小节，我们讨论了Python如何执行数值类型转换。函数coerce()为程序员提从了不依赖Python解释器，而是自定义两个数值类型转换的方法。对一种新创建的数值类型来说，这个特性非常有用。函数coerce()仅返回一个包含类型转换完毕的两个数值元素的元组。下面是几个例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>coerce(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coerce(<span class="number">1.3</span>, <span class="number">134L</span>)</span><br><span class="line">(<span class="number">1.3</span>, <span class="number">134.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coerce(<span class="number">1</span>, <span class="number">134L</span>)</span><br><span class="line">(<span class="number">1L</span>, <span class="number">134L</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coerce(<span class="number">1j</span>, <span class="number">134L</span>)</span><br><span class="line">(<span class="number">1j</span>, (<span class="number">134</span>+<span class="number">0j</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coerce(<span class="number">1.23</span>-<span class="number">41j</span>, <span class="number">134L</span>)</span><br><span class="line">((<span class="number">1.23</span>-<span class="number">41j</span>),(<span class="number">134</span>+<span class="number">0j</span>))</span><br></pre></td></tr></table></figure>
<div class="note danger"><p>coerce()内置函数和__coerce__方法在Python3中已经被移除。coerce()将根据Python算术运行符的强制转换规则转换数字参数并且只在引入新数字类型的Python早期版本有用。没有在Python 3中的替代方式；强制转换应该被数字运行符方法代替来做。</p>
</div>

<p>divmod()内建函数把除法和取余运算结合起来，返回一个包含商和余数的元组。对整型来说，它的返回值就是地板除和取余操作的结果。对浮点型来说，返回的商部分是<code>math.floor(num1/num2)</code>，对复数来说，商部分是<code>ath.floor((num1/num2).real)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">10</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">3</span>,<span class="number">10</span>)</span><br><span class="line">(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">10</span>,<span class="number">2.5</span>)</span><br><span class="line">(<span class="number">4.0</span>, <span class="number">0.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">2.5</span>, <span class="number">10</span>)</span><br><span class="line">(<span class="number">0.0</span>, <span class="number">2.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">2</span>+<span class="number">1j</span>, <span class="number">0.5</span>-<span class="number">1j</span>)</span><br><span class="line">(<span class="number">0j</span>, (<span class="number">2</span>+<span class="number">1j</span>))</span><br></pre></td></tr></table></figure>
<p>函数pow()和双星号（<strong>）操作符都可以进行指数运算。不过二都的区别并不仅仅在于一个是操作符，一个是内建函数。<br>在Python1.5之前，并没有</strong>操作符。内建函数pow()还接受第三个可选的参数，即一个余数参数。如果有这个参数的，pow()先进行指数运算，然后将运算结果和第三个参数进行取余运算。这个特性主要用于密码运算，并且比pow(x,y) % z性能更好，这是因为这个函数的实现类似于C函数pow(x,y,z)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">pow</span>(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">pow</span>(<span class="number">3.141592</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">9.86960029446</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">pow</span>(<span class="number">1</span>+<span class="number">1j</span>, <span class="number">3</span>)</span><br><span class="line">(-<span class="number">2</span>+<span class="number">2j</span>)</span><br></pre></td></tr></table></figure>
<p>内建函数round()用于对浮点型进行四舍五入运算。它有一个可选的小数位数参数。如果不提供小数位参数，它近回与第一个参数最接近的整型（但仍然是浮点类型）。第二个参数告诉round函数将结果精确到小数点后指定位数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">3</span>)</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">3.45</span>)</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">3.4999999</span>)</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">3.4999999</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">3.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> eachNum <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="built_in">round</span>(math.pi, eachNum)</span><br><span class="line">...</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="number">3.1</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">3.142</span></span><br><span class="line"><span class="number">3.1416</span></span><br><span class="line"><span class="number">3.14159</span></span><br><span class="line"><span class="number">3.141593</span></span><br><span class="line"><span class="number">3.1415927</span></span><br><span class="line"><span class="number">3.14159265</span></span><br><span class="line"><span class="number">3.141592654</span></span><br><span class="line"><span class="number">3.1415926536</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(-<span class="number">3.5</span>)</span><br><span class="line">-<span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(-<span class="number">3.4</span>)</span><br><span class="line">-<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(-<span class="number">3.49</span>)</span><br><span class="line">-<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(-<span class="number">3.49</span>, <span class="number">1</span>)</span><br><span class="line">-<span class="number">3.5</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是round()函数是按四舍五入的规则进行取整。也就是round(0.5)得到1，round(-0.5)得到-1。猛一看int()、round()、math.floor()这几个函数好像做的是同一件事，很容易将它们弄混，是不是？下面列出它们之间的不同之处。</p>
<ul>
<li>函数int()直接截去小数部分（返回值为整数）</li>
<li>函数floor()得到最接近原数但小于原数的整型（返回值为浮点型）</li>
<li>函数round()得到最接近原数的整型（返回值为浮点型）<br>下面的例子用4个正数和4个负数作为这三个函数的参数，将返回结果列在一起做个比较（为了便于比较我们将int()函数的返回值也转换成了浮点型）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> eachNum <span class="keyword">in</span> (<span class="number">.2</span>, <span class="number">.7</span>, <span class="number">1.2</span>, <span class="number">1.7</span>, -<span class="number">.2</span>, -<span class="number">.7</span>, -<span class="number">1.2</span>, -<span class="number">1.7</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;int(%.1f)\t%+.1f&quot;</span> % (eachNum, <span class="built_in">float</span>(<span class="built_in">int</span>(eachNum)))</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;floor(%.1f)\t%+.1f&quot;</span> % (eachNum, math.floor(eachNum))</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;round(%.1f)\t%+.1f&quot;</span> % (eachNum, <span class="built_in">round</span>(eachNum))</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span> * <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p><img src="/5-2.png" alt="Alt text" title="Optional title"></p>
<table>
<thead>
<tr>
<th>函  数</th>
<th>功  能</th>
</tr>
</thead>
<tbody><tr>
<td>abs(num)</td>
<td>返回num的绝对值</td>
</tr>
<tr>
<td>coerce(num1,num2)</td>
<td>将num1和num2转换为同一类型，然后以一个元组的形式返回</td>
</tr>
<tr>
<td>divmod(num1,num2)</td>
<td>除法–取余运算的结合。返回一个元组（num1&#x2F;num2,num1%num2）。对浮点型和复数的商进行下舍入（复数仅取实数部分的商）</td>
</tr>
<tr>
<td>pow(num1,num2,mod&#x3D;1)</td>
<td>取num1的num2的次方，如果提供mod参数，则计算结果再对mod进行取余运算</td>
</tr>
<tr>
<td>round(flot,ndig&#x3D;1)</td>
<td>接受一个浮点型flt并对其四舍五入。保存ndig位小数。若不提供ndig参数，则默认小数点后0位</td>
</tr>
</tbody></table>
<h3 id="仅用于整型的函数"><a href="#仅用于整型的函数" class="headerlink" title="仅用于整型的函数"></a>仅用于整型的函数</h3><p>除了适应于所有数值类型的内建函数之外，Python还提供一些仅适用于整型的内建函数（标准整型和长整型）。这些函数分为两类，一类用于进制转换，另一类用于ASCII转换。</p>
<p><span style="font-weight: bold;">1. 进制转换函数</span></p>
<p>前面我们已经看到，除了十进制标准，Python整型也支持八进制和十六进制整型。除此之外，Python还提供了两个内建函数来返回字符串表示的八进制和十六进制整型，它们分别是oct()和hex()。它们都接受一个整型（任意进制的）对象，并返回一个对应值的字符串对象。下面是几个示例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">255</span>)</span><br><span class="line"><span class="string">&#x27;0xff&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">230948231</span>)</span><br><span class="line"><span class="string">&#x27;0x1606627L&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">65535</span>*<span class="number">2</span>)</span><br><span class="line"><span class="string">&#x27;0x1fffe&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">255</span>)</span><br><span class="line"><span class="string">&#x27;0377&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">230948231</span>)</span><br><span class="line"><span class="string">&#x27;0130063047L&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">65535</span>*<span class="number">2</span>)</span><br><span class="line"><span class="string">&#x27;0377776&#x27;</span></span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bold;">2. ASCII转换函数</span></p>
<p>Python也提供了ASCII（美国标准信息交换码）码与其序列值之间的转换函数。每个字符对应一个唯一的整数（0～255）。对所有使用ASCII表的计算机来说，这个数值是不变的。这保证了不同系统之间程序行为的一致性。函数chr()接受一个单字节整型值，返回一个字符串，其值为对应的字符。函数ord()则相反，它接受一个字符，返回其对应的整型值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;O&#x27;</span>)</span><br><span class="line"><span class="number">48</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">97</span>)</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">65</span>)</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">48</span>)</span><br><span class="line"><span class="string">&#x27;O&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>hex(num)</td>
<td>将数字转换成十六进制数并以字符串形式返回</td>
</tr>
<tr>
<td>oct(num)</td>
<td>将数字转换成八进制数并以字符串形式返回</td>
</tr>
<tr>
<td>chr(num)</td>
<td>将ASCII值的数字转换成ASCII字符，范围只能是0&lt;&#x3D;num&lt;&#x3D;255</td>
</tr>
<tr>
<td>ord(chr)</td>
<td>接受一个ASCII或Unicode字符（长度为1的字符串），返回相应的ASCII值或Unicode值</td>
</tr>
<tr>
<td>unichr(num)</td>
<td>按受Unicode码值，返回其对应的Unicode字符。所接受的码值范围依赖于你的Python是构建于UCS-2还是UCS-4</td>
</tr>
</tbody></table>
<h2 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h2><h3 id="布尔“数”"><a href="#布尔“数”" class="headerlink" title="布尔“数”"></a>布尔“数”</h3><p>从Python2.3开始，布尔类型加到了Python中来。尽管布尔值看上去是“True”和“False”，但是事实上是整型的子类，对庆与整型的1和0。下面是有关布尔类型的主要概念。</p>
<ul>
<li>有两个永不改变的值True或False</li>
<li>布尔型是整型的子类，但是不能再被继承而生成它的子类</li>
<li>没有__nonzero__()方法的对象的默认值是True</li>
<li>对于值为零的任何数字或空集（空列表、空元组和空字典等）在Python中布尔值都是False。</li>
<li>在数学运算中，Boolean值的True和False分别对应于1和0</li>
<li>以前返回整型的大部分标准库函数和内建布尔型函数现在返回布尔型。 </li>
<li>True和False现在都不是关键字，但是在Python将来的版本中会是</li>
</ul>
<p>所有Python对象都有一个内建的True或False值，对内建类型来说，这个值究竟是True还是False请参阅章节4.3.2中的核必备注。下面是使用内建类型布尔值的一些例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># intro</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="number">1</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="literal">True</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="number">0</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>([])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>((<span class="number">1</span>,))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 使用布尔数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar = foo &lt; <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> bar + <span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;%s&#x27;</span> % bar</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;%d&#x27;</span> % bar</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># 无__nonzero__()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(c)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(C)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 重载__nonzero__()使它返回False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__nonzero__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(c)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(C)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 哦，别这么干！！（无论如何不要这么干！）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span>, <span class="literal">False</span> = <span class="literal">False</span>, <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="literal">True</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="literal">False</span>) </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>你可以在Python文档和PEP285看到有关布尔类型的知识。</p>
<h3 id="十进制浮点型"><a href="#十进制浮点型" class="headerlink" title="十进制浮点型"></a>十进制浮点型</h3><p>从Python2.4起（参阅PEP327）十进制浮点制成为一个Python特性。这主要是因为下面的语句经常会让一些编写科学计算或金融应用程序的程序员发狂。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span></span><br><span class="line"><span class="number">0.1000000000000001</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<p>为什么会这样？这是因为绝大多数语言的双精度实现都遵守IEEE754规范，其中52位用于底。因此浮点值只能有52位精度，类似这样的值的二进制表示只能象上面那样被截断。0.1的二进制表示是$0.11001100110011…*2^{-3}$，因为它最接近的二进制进似值是0.0001100110011…，或1&#x2F;16+1&#x2F;32+1&#x2F;256+…</p>
<p>你可以看到，这些片段不停的重复直到舍入出错。如果我们使用十进制来做同样的事情，感觉就会好很多，看上去会有任意的精度。注意下面，你不能混用十进制浮点型和普通的浮点型。你可以通过字符串或其他十进制数创建十进制数浮点型。必须导入decimal模块以便使用Decimal类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dec = Decimal(<span class="number">.1</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">    File <span class="string">&quot;/usr/local/lib/python2.4/decimal.py&quot;</span>, line <span class="number">523</span>, <span class="keyword">in</span> __new__</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;Cannot convert float to Decimal. &quot;</span> + </span><br><span class="line">TypeError: Cannot convert <span class="built_in">float</span> to Decimal. First convert the <span class="built_in">float</span> to </span><br><span class="line">a string</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dec = Decimal(<span class="string">&#x27;.1&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dec </span><br><span class="line">Decimal(<span class="string">&quot;0.1&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> dec </span><br><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dec + <span class="number">1.0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">    File <span class="string">&quot;/usr/local/lib/python2.4/decimal.py&quot;</span>, line <span class="number">906</span>, <span class="keyword">in</span> __add__</span><br><span class="line">      other = _convert_other(other)</span><br><span class="line">    File <span class="string">&quot;/usr/local/lib/python2.4/decimal.py&quot;</span>, line <span class="number">2863</span>, <span class="keyword">in</span> </span><br><span class="line">_convert_other</span><br><span class="line">      <span class="keyword">raise</span> TypeError, <span class="string">&quot;You can interact Decimal only with int, long or Decimal data  types.&quot;</span></span><br><span class="line">TypeError: You can interact Decimal only <span class="keyword">with</span> <span class="built_in">int</span>, long <span class="keyword">or</span> Decimal data types.</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dec + Decimal(<span class="string">&#x27;1.0&#x27;</span>)</span><br><span class="line">Decimal(<span class="string">&quot;1.1&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> dec + Decimal(<span class="string">&#x27;1.0&#x27;</span>) </span><br><span class="line"><span class="number">1.1</span></span><br></pre></td></tr></table></figure>
<p>decimal模块提供了一个Decimal数据类型用于浮点数计算。相比内置的二进制浮点数实现float，这个类型有助于</p>
<ul>
<li>金融应用和其它需要精确十进制表达的场合</li>
<li>控制精度</li>
<li>控制舍入以适应法徤或者规定要求</li>
<li>确保十进制数位精度，或者</li>
<li>用户希望计算结果与手算相符的场合</li>
</ul>
<p>例如，计算70分电话费的5%税计算，十进制浮点数和二进制浮点数计算结果的差别如下。如果在分值上舍入，这个差别就很重要了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(Decimal(<span class="string">&#x27;0.70&#x27;</span>) * Decimal(<span class="string">&#x27;1.05&#x27;</span>),<span class="number">2</span>)</span><br><span class="line">Decimal(<span class="string">&#x27;0.74&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">.70</span> * <span class="number">1.05</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">0.73</span></span><br></pre></td></tr></table></figure>

<h2 id="相关模块"><a href="#相关模块" class="headerlink" title="相关模块"></a>相关模块</h2><p>在Python标准库中有不少专门用于处理数值类型对象的模块，它们增强并扩展了内建函数的功能和数值运算的功能。下表列出了几个比较核心的模懎。要详细了解这些模块，请参阅这些模块的文献或在线文档。</p>
<table>
<thead>
<tr>
<th>模  块</th>
<th>介  绍</th>
</tr>
</thead>
<tbody><tr>
<td>decimal</td>
<td>十制浮点运算类Decimal</td>
</tr>
<tr>
<td>array</td>
<td>高效数值数组（字符、整型、浮点型等）</td>
</tr>
<tr>
<td>math&#x2F;cmath</td>
<td>标准C库数学运算函数。常规数学运算在match模块，复数运算在cmath模块</td>
</tr>
<tr>
<td>operator</td>
<td>数字操作符的函数实现。比如tor.sub(m,n)等价于m-n</td>
</tr>
<tr>
<td>random</td>
<td>多种伪随机数生成器</td>
</tr>
</tbody></table>
<div class="note primary"><p><span style="font-weight: bold;">核心模块：random</span><hr/><br>当你的程序需要随机数功能时，random模块就能派上用场。该模块包含多个伪随机数发生器，它们均以当前的时间戳为随机数种子。这样只要载入这个模块就能随时开始工作。下面列出了该模块中最常用的函数<br>randint(）：两个整型参数，返回二者之间的随机整型<br>randrange()：它接受和range()函数一样的参数，随机返回range([start,]stop[,step])结果的一项<br>uniform()：几乎和randint()一样，不过它返回的是二者之间的一个浮点型（不包括范围上限）<br>random()：类似于uniform()，只不过下限恒等于0.0，上限恒等于1.0<br>choice()：随机返回给定序列的一个元素</p>
</div>

<center><span style="font-weight: bold;">表5.9总结了数值类型的所有内建函数和操作符</span></center>

<table>
<thead>
<tr>
<th>操作符&#x2F;内建函数</th>
<th align="center">描述</th>
<th align="center">整型</th>
<th align="center">长整型</th>
<th align="center">浮点型</th>
<th align="center">复 数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>取绝对值</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center"></td>
<td>number</td>
</tr>
<tr>
<td>取对应的字符</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>str</td>
</tr>
<tr>
<td>强制类型转换</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center"></td>
<td>tuple</td>
</tr>
<tr>
<td>complex()</td>
<td align="center">复数工厂函数</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>complex</td>
</tr>
<tr>
<td>divmod()</td>
<td align="center">除法及取余</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>tuple</td>
</tr>
<tr>
<td>float()</td>
<td align="center">浮点工厂函数</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>float</td>
</tr>
<tr>
<td>hex()</td>
<td align="center">整型工厂函数</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center"></td>
<td align="center"></td>
<td>str</td>
</tr>
<tr>
<td>int()</td>
<td align="center">整型工厂函数</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>int</td>
</tr>
<tr>
<td>long()</td>
<td align="center">长整型工厂函数</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>long</td>
</tr>
<tr>
<td>oct()</td>
<td align="center">八进制</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>str</td>
</tr>
<tr>
<td>ord()</td>
<td align="center">字符序数</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">（str)</td>
<td align="center"></td>
<td>int</td>
</tr>
<tr>
<td>pow()</td>
<td align="center">指数操作</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>number</td>
</tr>
<tr>
<td>round()</td>
<td align="center">四舍五入</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>float</td>
</tr>
<tr>
<td>**</td>
<td align="center">指数运算</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>number</td>
</tr>
<tr>
<td>+</td>
<td align="center">单目加</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>number</td>
</tr>
<tr>
<td>-</td>
<td align="center">单目减</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>number</td>
</tr>
<tr>
<td>~</td>
<td align="center">按位取反</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center"></td>
<td align="center"></td>
<td>int&#x2F;long</td>
</tr>
<tr>
<td>**b</td>
<td align="center">指数运算</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>number</td>
</tr>
<tr>
<td>*</td>
<td align="center">乘法运算</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>number</td>
</tr>
<tr>
<td>&#x2F;</td>
<td align="center">传统或真正除法</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>number</td>
</tr>
<tr>
<td>&#x2F;&#x2F;</td>
<td align="center">地板除</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>number</td>
</tr>
<tr>
<td>%</td>
<td align="center">取余</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>number</td>
</tr>
<tr>
<td>+</td>
<td align="center">加法</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>number</td>
</tr>
<tr>
<td>-</td>
<td align="center">减法</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td>number</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td align="center">位左移</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center"></td>
<td align="center"></td>
<td>int&#x2F;long</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td align="center">位右移</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center"></td>
<td align="center"></td>
<td>int&#x2F;long</td>
</tr>
<tr>
<td>&amp;</td>
<td align="center">接位与运算</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center"></td>
<td align="center"></td>
<td>int&#x2F;long</td>
</tr>
<tr>
<td>^</td>
<td align="center">按位异或运算</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center"></td>
<td align="center"></td>
<td>int&#x2F;long</td>
</tr>
<tr>
<td>按位或运算</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center">•</td>
<td align="center"></td>
<td align="center"></td>
<td>int&#x2F;long</td>
</tr>
</tbody></table>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>本章的练习可以先通过应用程序的形式实现。一量功能齐备并且调试通过，建议读者将自己的代码功能用函数封装起来，以便在后面的练习中重用代码。关于编程风格我在这儿提醒一下，最好不要在函数内使用print语句输出信息，而是通过return语句返回必要的值。这样调用函数的代码就可以自己处理显示方式。这样你的代码就适应性更广，更便于重用。<br/><br><span style="font-weight: bolder;">5-1. 整型。讲讲Python普通整型和长整型的区别</span><br>python整型一共有三种：布尔型，长整型和常规整型。普通型和长整型主要的区别是，能表示的数据位数的不同。<br><br><span style="font-weight: bolder;">5-2 操作符写一个函数，计算并返回两个数的乘积。写一段代码调用这个函数，并显示它的结果</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">mathJ</span>(<span class="params">x, y</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x*y </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p><br/><span style="font-weight: bolder;">5-3. 标准类型操作符。写一段脚本，输入一个测验成绩，根据下面的标准，输出他的评分成绩（A-F）<br>    A: 90<del>100<br>    B: 80</del>89<br>    C: 70<del>79<br>    D: 60</del>69<br>    F: &lt;60</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">chengJ</span>(<span class="params">x</span>):</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">if</span> x &gt;= <span class="number">90</span> <span class="keyword">and</span> x &lt;= <span class="number">100</span> :</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">return</span> A</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">if</span> x &gt;= <span class="number">80</span> <span class="keyword">and</span> x &lt;= <span class="number">89</span> :</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">return</span> B</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">if</span> x &gt;= <span class="number">70</span> <span class="keyword">and</span> x &lt;= <span class="number">79</span> :</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">return</span> C</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">if</span> x &gt;= <span class="number">60</span> <span class="keyword">and</span> x &lt;= <span class="number">69</span> :</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">return</span> D</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">else</span></span><br><span class="line"><span class="meta">... </span>       <span class="keyword">return</span> F</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">5-4. 取余。判断给定年份是否是闰年。使用下面的公式。<br>一个闰年就是指它可以被4整除，但不能被100整除，或者它既可以被4又可以被100整除。比如1992年、1996年和2000年是闰年，但1967年和1900年则不是闰年。下一个是闰年的整世纪是2400年。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">input</span>(<span class="string">&quot;Please Enter Year?&quot;</span>)</span><br><span class="line">a = <span class="built_in">divmod</span>(x,<span class="number">4</span>)</span><br><span class="line">b = <span class="built_in">divmod</span>(x,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">and</span> b[<span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">or</span> (a[<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">and</span> b[<span class="number">1</span>] == <span class="number">0</span> ):</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;%d is a leap year! &quot;</span>) % (x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;%d is not a leap year!&quot;</span>) % (x)</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">5-5. 取余。取一个任意小于1美元的金额，然后计算可以换成最少多少枚硬币。硬币有1美分、5美分、10美分、25美分4种。1美元等于100美分。举例来说，0.76美元换算结果应该是3枚25美分，1枚1美分。类似76枚1美分，2枚25美分+2枚10美分+1枚5美分+1枚1美分这样的结果都是不符合要求的。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkMoney</span>(<span class="params">money</span>):</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">isinstance</span>(money,<span class="built_in">int</span>) <span class="keyword">and</span> money &lt;= <span class="number">100</span> :</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mathQb</span>(<span class="params">x</span>):</span><br><span class="line">  mf25 = x // <span class="number">25</span>,x % <span class="number">25</span> </span><br><span class="line">  <span class="keyword">if</span> mf25[<span class="number">1</span>] &gt;= <span class="number">5</span> :</span><br><span class="line">    <span class="keyword">if</span> mf25[<span class="number">1</span>]&gt;=<span class="number">5</span> <span class="keyword">and</span> mf25[<span class="number">1</span>]&lt;<span class="number">10</span>:</span><br><span class="line">      mf5= mf25[<span class="number">1</span>] // <span class="number">5</span>, mf25[<span class="number">1</span>] % <span class="number">5</span></span><br><span class="line">      <span class="keyword">return</span> mf25[<span class="number">0</span>],<span class="number">0</span>,mf5[<span class="number">0</span>],mf5[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      mf10 = mf25[<span class="number">1</span>] // <span class="number">10</span>, mf25[<span class="number">1</span>] % <span class="number">10</span></span><br><span class="line">      <span class="keyword">if</span> mf10[<span class="number">1</span>] &gt;=<span class="number">15</span> <span class="keyword">and</span> mf10[<span class="number">1</span>] &lt;=<span class="number">19</span>:</span><br><span class="line">        mf5= mf10[<span class="number">1</span>] // <span class="number">5</span>, mf10[<span class="number">1</span>] % <span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> mf25[<span class="number">0</span>],mf10[<span class="number">0</span>],mf5[<span class="number">0</span>],mf5[<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> mf25[<span class="number">0</span>],mf10[<span class="number">0</span>],<span class="number">0</span>,mf10[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">else</span>:   </span><br><span class="line">    <span class="keyword">return</span> mf25[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>,mf25[<span class="number">1</span>] </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;退出请输入Ctrl+C......&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    money = <span class="built_in">input</span>(<span class="string">&quot;请输入小于或等于1美元的钱币：&quot;</span>)</span><br><span class="line">    check = checkMoney(money)</span><br><span class="line">    <span class="keyword">if</span> check == <span class="literal">False</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请输入一个小于100美分整数！&quot;</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dib = mathQb(money)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d分换成零钱，可以换成%d个25美分,%d个10美分,%d个5美分,%d个1美分！&quot;</span> % (money,dib[<span class="number">0</span>],dib[<span class="number">1</span>],dib[<span class="number">2</span>],dib[<span class="number">3</span>]) )</span><br></pre></td></tr></table></figure>
<p><br/><span style="font-weight: bolder;">5-6. 算术。写一个计算器程序。你的代码可以接受这样的表达式，两个操作数加一个操作符：N1操作符N2。其中N1和N2为整形或浮点型，操作符可以是<code>+、-、*、/、%、**</code>分别表示加法、减法、乘法、整型除、取余和幂运算。计算这个表达式的结果，然后显示出来。提示：可以便用字符串方法split()，但不可以使用内建函数eval()</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  s = <span class="built_in">input</span>(<span class="string">&quot;请输入算式表达式，可接受+、-、*、/、%、//、** ：&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> s.find(<span class="string">&#x27;+&#x27;</span>) != -<span class="number">1</span> :</span><br><span class="line">    aa = <span class="built_in">float</span>(s.split(<span class="string">&#x27;+&#x27;</span>)[<span class="number">0</span>]) + <span class="built_in">float</span>(s.split(<span class="string">&#x27;+&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;表达式%s的结果为：%f&#x27;</span> % (s,aa) ) </span><br><span class="line">  <span class="keyword">if</span> s.find(<span class="string">&#x27;-&#x27;</span>) != -<span class="number">1</span> :</span><br><span class="line">    aa = <span class="built_in">float</span>(s.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>]) - <span class="built_in">float</span>(s.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;表达式%s的结果为：%f&#x27;</span> % (s,aa) ) </span><br><span class="line">  <span class="keyword">if</span> s.find(<span class="string">&#x27;*&#x27;</span>) != -<span class="number">1</span> :</span><br><span class="line">    aa = <span class="built_in">float</span>(s.split(<span class="string">&#x27;*&#x27;</span>)[<span class="number">0</span>]) * <span class="built_in">float</span>(s.split(<span class="string">&#x27;*&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;表达式%s的结果为：%f&#x27;</span> % (s,aa) ) </span><br><span class="line">  <span class="keyword">if</span> s.find(<span class="string">&#x27;/&#x27;</span>) != -<span class="number">1</span> :</span><br><span class="line">    aa = <span class="built_in">float</span>(s.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>]) / <span class="built_in">float</span>(s.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;表达式%s的结果为：%f&#x27;</span> % (s,aa) ) </span><br><span class="line">  <span class="keyword">if</span> s.find(<span class="string">&#x27;%&#x27;</span>) != -<span class="number">1</span> :</span><br><span class="line">    aa = <span class="built_in">float</span>(s.split(<span class="string">&#x27;%&#x27;</span>)[<span class="number">0</span>]) % <span class="built_in">float</span>(s.split(<span class="string">&#x27;%&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;表达式%s的结果为：%f&#x27;</span> % (s,aa) ) </span><br><span class="line">  <span class="keyword">if</span> s.find(<span class="string">&#x27;//&#x27;</span>) != -<span class="number">1</span> :</span><br><span class="line">    aa = <span class="built_in">float</span>(s.split(<span class="string">&#x27;//&#x27;</span>)[<span class="number">0</span>]) // <span class="built_in">float</span>(s.split(<span class="string">&#x27;//&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;表达式%s的结果为：%f&#x27;</span> % (s,aa) ) </span><br><span class="line">  <span class="keyword">if</span> s.find(<span class="string">&#x27;**&#x27;</span>) != -<span class="number">1</span> :</span><br><span class="line">    aa = <span class="built_in">float</span>(s.split(<span class="string">&#x27;**&#x27;</span>)[<span class="number">0</span>]) ** <span class="built_in">float</span>(s.split(<span class="string">&#x27;**&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;表达式%s的结果为：%f&#x27;</span> % (s,aa) ) </span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">5-7. 营业税。随意取一个商品金额，然后根据当地营业税额度计算应该交纳的营业税。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;退出请输入Ctrl+C......&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    meony = <span class="built_in">input</span>(<span class="string">&quot;请输入一个商品价格：&quot;</span>)</span><br><span class="line">    tax = Decimal(meony) * Decimal(<span class="string">&#x27;0.17&#x27;</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;商品的价格为%s,税额为%f&quot;</span> % (meony,<span class="built_in">round</span>(tax,<span class="number">6</span>)))</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">5-8. 几何。计算面积和体积。<br>    （a) 正方形和立方体<br>    （b）圆和球<br></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqcube</span>():</span><br><span class="line">  s = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;计算正方形和立方体面积及体积请输入边长：&quot;</span>))</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;正方形和立方体的面积为：%f&quot;</span> % (s ** <span class="number">2</span>))</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;正方形和立方体的体积为：%f&quot;</span> % (s ** <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cirsph</span>():</span><br><span class="line">  r = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;计算圆和球的面积和体积请输入半径：&quot;</span>))</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;圆和球的面积为%f&quot;</span> % (math.pi*(r**<span class="number">2</span>)))</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;圆和球的体积为%f&quot;</span> % (math.pi*(r**<span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line">sqcube()</span><br><span class="line">cirsph()</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">5-9. 数值形式回答下面关于数值格式的问题：<br>(a）为什么下面的例子里17+32等于49，而017+32等于47，017+032等于41？ </span><br>     <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> + <span class="number">32</span></span><br><span class="line"><span class="number">49</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>017 + <span class="number">32</span></span><br><span class="line"><span class="number">47</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>017 + 032</span><br><span class="line"><span class="number">41</span></span><br></pre></td></tr></table></figure><br>     因为在Python中0开头的数值表示8进制数，017的八进制数为15，032的八进制数为26<br><br/><span style="font-weight: bolder;">(b) 为什么下面这个表达式我们得到的结果是134L而不是1342？</span><br>     <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">56l</span> + <span class="number">78l</span></span><br><span class="line"><span class="number">134L</span></span><br></pre></td></tr></table></figure><br>     因为l是长整型L的小写不是1<br><br/><span style="font-weight: bolder;">5-10. 转换。写一对函数来进行华氏度到摄氏度的转换。转换公式为C&#x3D;(F-32)*(5&#x2F;9)应该在这个练习中使用真正的除法，否则你会得到不正确的结果。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment"># 华氏度到摄氏度的转换。转换公式为C=(F-32)*(5/9)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calcFtoC</span>(<span class="params">f</span>):</span><br><span class="line">  c = <span class="built_in">round</span>((<span class="built_in">float</span>(f)-<span class="number">32</span>) * (<span class="number">5.0</span>/<span class="number">9.0</span>),<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;退出请按Ctrl+C键......&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  m = <span class="built_in">input</span>(<span class="string">&quot;请输入华氏度(℉):&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;华氏度为%s换算后的摄氏度为：%s℃&quot;</span> % (m,calcFtoC(m)))</span><br></pre></td></tr></table></figure>
<p><br/><span style="font-weight: bolder;"><br>5-11. 取余<br>    (a) 使用循环和算术运算，求出0～20之间的所有偶数。<br>    (b) 同上，不过这次输出所有的奇数。<br>    (c) 综合(a)和(b)，请问辨别奇数和偶数的最简单的方法是什么？<br>    (d) 使用(c)的成果，写一个函数，检测一个整型能否被另一个整型整除。先要求用户输入两个数，然后你的函数判断两者是否有整除关系，根据判断结果分别返回True和False<br></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">a, b = [], []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>):</span><br><span class="line">  <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> :</span><br><span class="line">    a.append(i)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    b.append(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;偶数为：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;奇数为：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">5-12. 系统限制。写一段脚本确认一下你的Python所能处理的整型、长整型、浮点型和复数的范围。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dir</span>(sys)</span><br><span class="line"><span class="built_in">print</span> sys.maxint</span><br><span class="line"><span class="built_in">print</span> sys.float_info</span><br><span class="line"><span class="built_in">print</span> sys.long_info</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">5-13. 转换。写一个函数把由小时和分钟表示的时间转换为只用分钟表示的时间。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minute</span>(<span class="params">hour</span>):</span><br><span class="line">    <span class="keyword">return</span> hour * <span class="number">60</span></span><br><span class="line">time = raw_input(<span class="string">&quot;请输入你的小时和分钟，请用逗号隔开：&quot;</span>)</span><br><span class="line">timelist = time.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">minutes = minute(<span class="built_in">int</span>(timelist[<span class="number">0</span>])) + <span class="built_in">int</span>(timelist[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span> minutes</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">5-14. 银行利息。写一个函数，以定期存款利率为参数，假定该账户每日计算复利，请计算并返回年回报率。</span><br>定期存款利率4%</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;年化收益率为4%&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  m = <span class="built_in">input</span>(<span class="string">&quot;请输入存款金额：&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span>  <span class="built_in">isinstance</span>(m,(<span class="built_in">int</span>,<span class="built_in">float</span>,<span class="built_in">str</span>)) == <span class="literal">True</span> :</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入正确的整型、浮点型、字符型数值！&quot;</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">yearSum = <span class="built_in">round</span>(<span class="built_in">float</span>(m) * <span class="number">0.04</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;一年的收益为：%s&quot;</span> % (yearSum))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;每日收益额为：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">366</span>) :</span><br><span class="line">  <span class="keyword">if</span> i != <span class="number">0</span> :</span><br><span class="line">    daySum = <span class="built_in">round</span>((yearSum/<span class="number">365.0</span>) * i,<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第%d天的收益额为：%f&#x27;</span> % (i,daySum))</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">5-15. 最大公约数和最小公倍数。请计算两个整型的最大公约数和最小公倍数。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  m1 = <span class="built_in">input</span>(<span class="string">&#x27;请输入第一个整数：&#x27;</span>)</span><br><span class="line">  m2 = <span class="built_in">input</span>(<span class="string">&#x27;请输入第二个整数：&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">isinstance</span>(m1,<span class="built_in">int</span>) == <span class="literal">True</span> <span class="keyword">and</span> <span class="built_in">isinstance</span>(m2,<span class="built_in">int</span>) == <span class="literal">True</span> :</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="comment">#计算最大公约数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mcd</span>(<span class="params">m1, m2</span>):</span><br><span class="line">  <span class="keyword">if</span> m1 % m2 == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> m2</span><br><span class="line">  <span class="keyword">return</span> mcd(m2, m1 % m2)</span><br><span class="line"><span class="comment">#计算最小公倍数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lcm</span>(<span class="params">m1,m2</span>):</span><br><span class="line">    <span class="keyword">return</span> m1 * m2 // mcd(m1, m2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%d与%d的最大公约数为：%d&quot;</span> % (m1, m2, mcd(m1, m2)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%d与%d的最小公倍数为：%d&quot;</span> % (m1, m2, lcm(m1, m2)))</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">5-16. 家庭财务。给定一个初始金额和月开销数，使用循环，确定剩下的金额和当月的支出数，包括最后的支出数。Payment()函数会用到初始金额和月额度，输出结果应该类似下面的格式（例子中的数字仅用于演示）。</span><br><img src="/5-16.png" alt="Alt text" title="Optional title"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Payment</span>(<span class="params">amount,expenditure</span>):</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;pym#     Paid      Blance&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;%d       $ %d      $ %d&quot;</span> %(count,expenditure,<span class="built_in">float</span>(amount))</span><br><span class="line">  </span><br><span class="line">amount = <span class="built_in">float</span>(raw_input(<span class="string">&quot;Enter opening balance:&quot;</span>))</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">  expenditure = <span class="built_in">float</span>(raw_input(<span class="string">&quot;enter monter payment:&quot;</span>))</span><br><span class="line">  amount -= expenditure</span><br><span class="line">  Payment(amount,expenditure)</span><br><span class="line">  count += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> amount &lt;= <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;No money!&quot;</span></span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">5-17. 随机数。熟读随机数模块然后解下面的题。生成一个有N个元素的由随机数n组成的列表，其中N和n的取值范围分别为（1&lt;N&lt;&#x3D;100）和（$0&lt;&#x3D;n&lt;&#x3D;2^{31}-1$）。然后再随机从这个列表中取N(1&lt;&#x3D;N&lt;&#x3D;100)个随机数出来，对它们排序，然后显示显示这个子集。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">a = random.randint(<span class="number">2</span>,<span class="number">100</span>)</span><br><span class="line">n = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a):</span><br><span class="line">  n.append(random.randrange(<span class="number">0</span>,<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(n))</span><br></pre></td></tr></table></figure>
<p><br><br><hr><br><br></p>
<h1 id="序列：字符串、列表和元组"><a href="#序列：字符串、列表和元组" class="headerlink" title="序列：字符串、列表和元组"></a>序列：字符串、列表和元组</h1><div class="note primary"><p>本章主题</p>
<ul>
<li>序列简介</li>
<li>字符串</li>
<li>列表</li>
<li>元组</li>
</ul>
</div>
<p>接下来我们要研究这样一些Pthon的类型，它们的成员有序排列的，并且可以通过下标偏移量访问到它的一个或几个成员，这类Python类型统称为序列，包括下面这些：字符串（普通字符串和unicode字符串），列表，和元组类型。</p>
<p>因为这些类型其实都是由一些字符组成的序列，那么“Hello”这个字符串的第一个字符就是“H”，第二个字符就是“e”…..，同样的，列表类型和元组类型就是其他一些Python对象所组成的序列。</p>
<p>首先我们来熟悉一下适用于所有序列类型的操作符和内建函数（BIF）再对每一种从如下方面分别介绍：</p>
<ul>
<li>简介</li>
<li>操作符</li>
<li>内建函数</li>
<li>内建函数（如果可用）</li>
<li>特性（如果可用）</li>
<li>相关模块（如果可用）<br>在本章的末尾我们会给出一个对于所有序列类型都适用的操作符和函数的参考图表，现在让我们概略看一下这些内容。<br><img src="/6-1.png" alt="图 6-1" title="序列"></li>
</ul>
<h2 id="序列简介"><a href="#序列简介" class="headerlink" title="序列简介"></a>序列简介</h2><p>序列类型有着相同的访问模式：它的每一个元素可以通过指定一个偏移量的方式得到。而多个元素可以通过切片操作方式一次得到，切片操作会在接下来的内容中讲到。下标偏移量是从0开始到总元素数-1结束–之所以要减1是因为我们是从0开始计数的。上图阐述了序列的元素是如何存储的。</p>
<h3 id="标准类型操作符-2"><a href="#标准类型操作符-2" class="headerlink" title="标准类型操作符"></a>标准类型操作符</h3><p>标准类型操作符一般都能适用于所有的序列类型。当然，如果作复合类型的对象比较的话，这样说可能需要有所保留，不过其他的操作绝对是完全适用的。</p>
<h3 id="序列类型操作符"><a href="#序列类型操作符" class="headerlink" title="序列类型操作符"></a>序列类型操作符</h3><table>
<thead>
<tr>
<th>序列操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>seq[ind]</td>
<td>获得下标为ind的元素</td>
</tr>
<tr>
<td>seq[ind1:ind2]</td>
<td>获得下标从ind1到ind2间的元素集合</td>
</tr>
<tr>
<td>seq * expr</td>
<td>序列重复expr次</td>
</tr>
<tr>
<td>seq1 + seq2</td>
<td>连接序列seq1和seq2</td>
</tr>
<tr>
<td>obj in seq</td>
<td>判断obj元素是否包含在seq中</td>
</tr>
<tr>
<td>obj not in seq</td>
<td>判断obj元素是否不包含在seq中</td>
</tr>
</tbody></table>
<p><b>成员关系操作符（in, not in）</b><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;成员关系操作符使用来判断一个元素是否属于一个序列。比如对字符串类型来说，就是判断一个字符是否属于这个字符串，对和元组类型来说，就代表了一个对象是否属于该对象序列。in、not in操作符的返回值一般来讲就是True或False，满足成员关系就返回True，否则返回False。该操作符的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj [<span class="keyword">not</span>] <span class="keyword">in</span> sequence</span><br></pre></td></tr></table></figure>
<p><b>连接操作符（+）</b><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这个操作符允许我们把一个序列和另一个相同类型的序列做连接。语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sequence1 + sequence2</span><br></pre></td></tr></table></figure>
<p>该表达式的结果是一个包含sequence1和sequence2的内容的新序列。注意，这种方式看起来似乎实现了把两个序弄内容合并的概念，但是这个操作不是最快或是说最有效的。对字符串来说，这个操作不如把所有的子字符串放到一个列表或可迭代对象中，然后调用一个join方法来把所有的内容连接在一起节约内存；类似地，对列表来说，我们推荐读者用列表类型的extend()方法来把两个或者多个列表对象合并，当你需要简单地把两个对象的内容合并，或者说不能依赖于可变对象的那些没有返回值（实际上它返回一个None）的内建方法来完成的时候时，连接操作符还是很方便的一个选择。下面的切片操作可以视作这些情况的例子。<br><b>重复操作符（*）</b><br>当你需要一个序列的多份拷贝时，重复操作符非常有用，它的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sequence * copies_int</span><br></pre></td></tr></table></figure>
<p>copies_int必须是一个整数，不能是长整数，偈连接操作符一样，该操作符返回一个新的包含多份原对象拷贝的对象。<br><b>切片操作符（[]，[:]，[::]）</b><br>简单地讲，所谓序列类型就是包含一些顺序排列的对象的一个结构，你可以简单的用方括号加一个下标的方式访问它的每一个元素，或者通过在方括号中用冒号把开始下标和结束下标分开的方式来访问一组连续的元素。下面我们将详细的讲解提到的这两种方式。这种访问序列的方式叫做切片，我们通过切片操作符就可以实现我们上面说到的操作。访问某一个数据元素的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sequence[index]</span><br></pre></td></tr></table></figure>
<p>sequence是序列的名字，index是想要访问的元素对应的偏移量，偏移量可以是正值，范围从0至偏移量的最大值（比序列长度少1），用len()函数可以得到序列长度，实际的范围是0&lt;&#x3D;inde&lt;&#x3D;len(sequence)-1，另外，也可以使用负索引，范围是-1到序例的负长度，-len(sequence),-len(sequence) &lt;&#x3D; index &lt;&#x3D; -1。正负索引的区别在于正索引以序列的开始为起点，负索列以序列的结束为起点。试图访问一个越界的索引会引发一个如下的异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>names = (<span class="string">&#x27;Faye&#x27;</span>, <span class="string">&#x27;Leanna&#x27;</span>, <span class="string">&#x27;Daylen&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> names[<span class="number">4</span>]</span><br><span class="line">Traceback (most recent call last): File <span class="string">&quot;&lt;stdin&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">IndexError: <span class="built_in">tuple</span> index out of <span class="built_in">range</span></span><br></pre></td></tr></table></figure>
<p>因为Python是面向对象的，所以你可以像下面这样直接访问一个序列的元素（不用先把它赋值给一个变量<br>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Faye&#x27;</span>, <span class="string">&#x27;Leanna&#x27;</span>, <span class="string">&#x27;Daylen&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">Leanna</span><br></pre></td></tr></table></figure>
<p>这个特性在你调用一个返回值是序列类型的函数，并且你只对返回的序列中的一个或某几个元素感兴趣时特别有用。<br>那么我们如何才能一次得到多个元素呢？其实这跟访问某一个单一元素一样简单，只要简单的给出开始和结束的索引值，并且用冒号分隔就可以了，其语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sequence[starting_index:ending_index]</span><br></pre></td></tr></table></figure>
<p>用步长索引来进行扩展的切片操作<br>序列的最后一个切片操作是扩展切片操作，它多出来的第三个索引值被用做步长参数。你可以把这个参数看成跟内建函数range()里面的步长参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;abcdefgh&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::-<span class="number">1</span>]  <span class="comment">#可以视作“翻转”操作</span></span><br><span class="line"><span class="string">&#x27;hgfedcba&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;aceg&#x27;</span></span><br></pre></td></tr></table></figure>
<p><b>切片索引的更多内容</b><br>切片索引的语法要比简单的单一元素索引灵活的多。开始和结束索引值可以超过字符串的长度。换句话说，起始索引可以小于0，而对于结束索引，即佝索引值为100的元素并不存在也不会报错，简单地说，即使用100来作为一个长度不到100的序列的结束索引也不会有什么问题，例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">&#x27;Faye&#x27;</span>, <span class="string">&#x27;Leanna&#x27;</span>, <span class="string">&#x27;Daylen&#x27;</span>)[-<span class="number">100</span>,<span class="number">100</span>]</span><br><span class="line">(<span class="string">&#x27;Faye&#x27;</span>, <span class="string">&#x27;Leanna&#x27;</span>, <span class="string">&#x27;Daylen&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>有这么一个问题：有一个字符串，我们想通过一个循环按照这样的形式显示它：每次都把位于最后的一个字符砍掉，下面是实现这个要求的一种方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;abcde&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">1</span>,-<span class="built_in">len</span>(s),-<span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span> (s[:i])</span><br><span class="line">abcd</span><br><span class="line">abc</span><br><span class="line">ab</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>可是，该如何在第一次迭代的时候显示整个字符串呢？是否有一种方法可以不用在整个循环之前加入一个额外的print语句呢？我们该如何定义一个索引，来代表整个的序列呢？事实上在以负数作为索引的例子里是没有一个直正能解决这个问题的方法的，因为-1已经是“最小”的索引了。我们不可能用0来作为索引值，因为这会切片到第一个元素之前而什么都不会显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[:<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们的方案是使用另一个小技巧：用None作为索引值，这样一来就可以满足你的需要，比如说，在你想用一个变量作为索引来从第一个到遍历最后一个元素的时候：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;abcde&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="literal">None</span>] + <span class="built_in">range</span>(-<span class="number">1</span>,-<span class="built_in">len</span>(s),-<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(s[:i])</span><br><span class="line">abcde</span><br><span class="line">abcd</span><br><span class="line">abc</span><br><span class="line">ab</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>现在这个程序符合我们的要求了。在进行下面的内容之前，必须指出，似乎还可以先创建一个只包含None的列表，然后用extend()函数把range()的输出添加到这个列表，或者先建立range()输出组成的列表然后再把None插入到这个列表的最前面，然后对这个列表进行遍历，但是可变对象的内建函数extend()根本就没有返回值，所以这个方法行不通的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> [<span class="literal">None</span>].extend(<span class="built_in">range</span>(-<span class="number">1</span>,-<span class="built_in">len</span>(s),-<span class="number">1</span>)):</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span> s[:i]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span>?</span><br><span class="line">TypeError: iteration over non-sequence</span><br></pre></td></tr></table></figure>
<p>这个错误发生的原因是[None].extend(…)函数返回None，None既不是序列类型也不是可迭代对象，这种情况下使用上面提到的列表连接操作来实现是唯一不需要添加额外代码的方法。</p>
<h3 id="内建函数（BIFs）"><a href="#内建函数（BIFs）" class="headerlink" title="内建函数（BIFs）"></a>内建函数（BIFs）</h3><p>序列本身就内含了迭代的概念，之所以会这样，是因为迭代这个概念就是从序弄，迭代器，或者其他支持迭代操作的对象中泛化得来的。由于Python的for循环可以遍环可以遍历所有的可迭代类型，在（非纯序列对象上）执行for循环时就像在一个纯序弄对象上执行一样。而且Python的很多原来只支持序弄作为参数的内建函数现在也开始支持迭代器或者类迭代器了。我们把这些烊型统称为“可迭代对象”。<br><b>类型转换</b><br>内建函数list()，str()和tuple()被用做在各种序列类型之间转换。你可以把它们理解成共他语言里面的类型转换，但是并没有进行任何的转换。它些转换实际上是工厂函数，将对象作为参数，并将其内容拷贝到新生成的对象中。下表中列出了适用于序弄类型转换的函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>list(iter)</td>
<td>把可迭代对象转换为列表</td>
</tr>
<tr>
<td>str(obj)</td>
<td>把obj对象转换成字符串（对象的字符串表示法）</td>
</tr>
<tr>
<td>unicode(obj)</td>
<td>把对象转换成Unicode字符串（使用默认编码）</td>
</tr>
<tr>
<td>basestring()</td>
<td>抽象工厂函数，其作用仅仅是为str和unicode函数提供父类，所以不能被实例化，也不能被调用</td>
</tr>
<tr>
<td>tuple(iter)</td>
<td>把一个可迭代对象转换成一个元组对象</td>
</tr>
</tbody></table>
<p>我们又用了一次“转换”这个词。不过，为什么Python里面不简单地把一个对象转换成另一个对象呢？我们知道Python对象一旦建立，我们就不能更改其身份或类型了。如果你把一个列表对象传给list()函数，便会创建这个对象的一个浅拷贝，然后将其插入新的列表中。同样地，在做连接操作和重复操作时，我们也会这样处理。</p>
<p>所谓浅拷贝就是只拷贝了对对象的索引，而不是重新建立了一个对象！如果你想完全的拷贝一个对象（包括递归，如果你的对象是一个包含在容器中的容器），你需要用到深拷贝。</p>
<p>str()函数在需要把一个对象的可打印信息输出时特别有用，不仅仅是对序列类型，对其他类型的对象同样如此。Unicode()是str()函数的unicode版本，它跟str()函数基本一样，list()和tuple()函数在列表类型和元组类型互换时非常有用，不过，虽然这些函数也适用于string类型（因为string类型也是序列的一种），但是在string类型上应用tuple()和list()函数却得不到我们通常希望的结果。</p>
<p><b>Operational</b></p>
<p>Python为序列类型提供以下可操作下表。注意len()，reversed()和sum()函数只能接受序列类型对象作为参数，而剩下的则还可以授受可迭代对象做为参数，另外，max()和min()函数也可以接受一个参数列表。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>enumerate(iter)</td>
<td>接受一个可迭代对象作为参数，返回一个enumerate对象（同时也是一个迭代器），该对象生成由iter每个元素的index值和item值组成的元组</td>
</tr>
<tr>
<td>len(seq)</td>
<td>返回seq的长度</td>
</tr>
<tr>
<td>max(iter,key&#x3D;None) or max(arg0，arg1…,key&#x3D;None)</td>
<td>返回iter或（arg0,arg1,…）中的最大值，如果指定了key，这个key必须是一个可以传给sort()方法的，用于比较的回调函数</td>
</tr>
<tr>
<td>min(iter,key&#x3D;None) or min(arg0,arg1…key&#x3D;Nne)</td>
<td>返回iter里面的最小值；或者返回（arg0,arg2,…）里面的最小值；如果指定了key，这个key必须是一个可以传给sort()方法的，用于比较的回调函数。</td>
</tr>
<tr>
<td>reversed(seq)</td>
<td>接受一个序列作为参数，返回一个以逆序访问的迭代器</td>
</tr>
<tr>
<td>sorted(iter,func&#x3D;None,key&#x3D;None,reverse&#x3D;False)</td>
<td>接受一个可迭代对象作为参数，返回一个有序的列表；可选参数func, key和reverse的含义跟list.sort()内建函数的参数含义一样。</td>
</tr>
<tr>
<td>sum(seq, init&#x3D;0)</td>
<td>返回seq和可选参数init的总和，其效果等同于reduce(operator.add,seq,init)</td>
</tr>
<tr>
<td>zip([it0,it1,…itN])</td>
<td>返回一个列表，其第一个元素是it0,it1,…这些元素的第一个元素组成的一个元组，第二个…，类推</td>
</tr>
</tbody></table>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串类型是Python里面最常见的类型。我们可以简单地通过在引号间包含字符的方式创建它。Python里面单引号和双引号的作用是相同的，这一点Python不同于其他类Shell的脚本语言，在这些脚本语言中，通常转义字符仅仅在双引号字符串中起作用，在单引号括起的字符串中不起作用。Python用“原始字符串”操作符来创建直接量字符串，所以再做区分就没什么意义了。其他的语言，比如C语言里面用单引号来标示字符，双引号标示字符串，而在Python里面没有字符这个类型。这可能是双引号和单引号在Python里面被视作一样的另一个原因。几乎所有的Python应用程序都会某种方式用到字符串类型。字符串是一种直接量或者说是一种标量，这意味着Python解释器在处理字符串时是把它作为单一值并且不会包含其他Python类型的。字符串是不可变类型，就是说改变一个字符串的元素需要新建一个新的字符串。字符串是由独立的字符组成的，并且这些字符可以通过切片操作顺序地访问。</p>
<p>Python对类型和类的概念进行了统一，Python实际上有3类字符串。通常意义的字符中（str）和Unicode字符串（Unicode）实际上都是抽象类basestring的子类。这个basestring是不能实例化的，如果你试图实例化一个basestring类，你会得到以下报错信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basestring(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">Traceback (most recent call last): File <span class="string">&quot;&lt;stdin&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: The basestring <span class="built_in">type</span> cannot be instantiated</span><br></pre></td></tr></table></figure>
<h3 id="字符串的创建和赋值"><a href="#字符串的创建和赋值" class="headerlink" title="字符串的创建和赋值"></a>字符串的创建和赋值</h3><p>创建一个字符串就像使用一个标量一样简单，当然你也可以把str()作为工厂方法来创建一个字符串并把它赋值给一个变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString = <span class="string">&#x27;Hello World!&#x27;</span>  <span class="comment"># 使用单引号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>anotherString = <span class="string">&quot;Python is cool!&quot;</span>  <span class="comment"># 使用双引号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> aString  <span class="comment"># print不带引号的Hello World!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>anotherString  <span class="comment"># 不是进行print操作，带有引号</span></span><br><span class="line"><span class="string">&#x27;Python is cool!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">str</span>(<span class="built_in">range</span>(<span class="number">4</span>))  <span class="comment"># 把一个列表转换成一个字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">&#x27;[0, 1, 2, 3]&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="如何访问字符串的值（字符和子串）"><a href="#如何访问字符串的值（字符和子串）" class="headerlink" title="如何访问字符串的值（字符和子串）"></a>如何访问字符串的值（字符和子串）</h3><p>Python里面没有字符这个类型，而是用长度为1的字符串来表示这个概念，当然，这其实也是一个子串。用方括号加一个或多于一个索引的方式来获得子串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>asString = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;H&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;ello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[<span class="number">6</span>:]</span><br><span class="line"><span class="string">&#x27;World!&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="如何改变字符串"><a href="#如何改变字符串" class="headerlink" title="如何改变字符串"></a>如何改变字符串</h3><p>你可以通过给一个变量赋值（或者重赋值）的方式“更新”一个已有的字符串，新的值可能与原有值差不多，也可能跟原有串完全不同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString = aString[:<span class="number">6</span>] + <span class="string">&#x27;Python!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString</span><br><span class="line"><span class="string">&#x27;Hello Python!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString = <span class="string">&#x27;different string altogether&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString</span><br><span class="line"><span class="string">&#x27;different string altogether&#x27;</span></span><br></pre></td></tr></table></figure>

<p>跟数字类型一样，字符串类型也是不可变的，所以你要改变一个字符串就必须通过创建一个新的字符串的方式来实现。也就是说你不能只改变一个字符串的一个字符或者一个子串，然而，驼过拼凑一个旧串的各个部分来得到一个新串是被允许，正如上面你看到的那样。</p>
<h3 id="如何删除字符和字符串"><a href="#如何删除字符和字符串" class="headerlink" title="如何删除字符和字符串"></a>如何删除字符和字符串</h3><p>再重复一遍，字符串是不可变的，所以你不能仅仅删除一个字符串里的某个字符，你能做的是清空一个空字符串，或者是把剔除了不需要的部分后的字符串组合起来形成一个新串。假设你想要从“Hello World!”里面删除小写的’l’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString = aString[:<span class="number">3</span>] + aString[<span class="number">4</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString</span><br><span class="line"><span class="string">&#x27;Helo World!&#x27;</span></span><br><span class="line"><span class="comment"># 通过赋一个空字符串或者使用del语句来清空或者删除一个字符串：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString</span><br><span class="line"><span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> aString</span><br></pre></td></tr></table></figure>

<p>在大部分应用程序里，没有必要显式的删除字符串。定义这个字符串的代码最终会结束，那时Python会自动释放这些字符串。</p>
<h2 id="字符串和操作符"><a href="#字符串和操作符" class="headerlink" title="字符串和操作符"></a>字符串和操作符</h2><h3 id="标准类型操作符-3"><a href="#标准类型操作符-3" class="headerlink" title="标准类型操作符"></a>标准类型操作符</h3><p>在这胶我们介绍了一些适用于包括标准类型在内的大部分对象的作吕作，在这里再看一下这些其中的一些操作符是怎样作用于字符串类型的，下面是几个简单 的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = <span class="string">&#x27;lmn&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str3 = <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 &lt; str2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 != str3</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 &lt; str3 <span class="keyword">and</span> str2 == <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="comment"># 在做比较操作的时候，字符串是按照ASCII值的大小来比较的。</span></span><br></pre></td></tr></table></figure>

<h3 id="序列操作符切片（-和-：-）"><a href="#序列操作符切片（-和-：-）" class="headerlink" title="序列操作符切片（[]和[：]）"></a>序列操作符切片（[]和[：]）</h3><p>在早先地章节里面我们展示了如何访问序列类型的一个或一组元素，接下来我们会把这些知识应用到字符串类型上，着重考察以下的操作：</p>
<ul>
<li>正向索引</li>
<li>反向索引</li>
<li>默认索引</li>
</ul>
<p>接下来以字符串’abcd’为例子。表里面分别列出了使用正索引和负索引来定位字符的情况。可以用长度操作符来确认该字符串的长度是4：</p>
<p><img src="/6-2.png" alt="字符串索引" title="字符串索引6-2.png">    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString = <span class="string">&#x27;abcd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(aString)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>正向索引时，索引值开始于0，结束于总长度减1（因为我们是从0开始索引的），在这个范围内，我们可以访问任意的子串。用一个参数来调用切片操作符结果是一个单一字符，而使用一个数值范围（用’:’）作为参数调用切片操作的参数会返回一串连续地字符。再强调一遍，对任何范围[start:end]，我们可以访问到包括start在内到end（不包括end）的所有字符，换句话说，假设x是[start:end]中的一个索引值，那么有：start &lt;&#x3D; x &lt; end</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;bc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"><span class="string">&#x27;cd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[<span class="number">4</span>]</span><br><span class="line">Traceback (innermost last): File <span class="string">&quot;&lt;stdin&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">IndexError: string index out of <span class="built_in">range</span></span><br></pre></td></tr></table></figure>

<p>使用不在允许范围（本倒中是0到3）内的索引值会导致错误。上面的aString[2:4]却并没有出错，那是因为实际上它返回的是索引值2和3的值。但是直接拿4作为索引访问是不被允许的。</p>
<p>在进行反向索引操作时，是从-1开始，向字符串的开始方向计数，到字符串长度的负数为索引的结束。最末一个索引（也就是第一个字符）是这样定位的<br><code>final_index = -len(aString) = -4</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[-<span class="number">3</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;bc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[-<span class="number">4</span>]</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果开始索引或者结束索引没有被指定，则分别以字符串的第一个和最后一个索引值为默认值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[<span class="number">2</span>:]</span><br><span class="line"><span class="string">&#x27;cd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[<span class="number">1</span>:]</span><br><span class="line"><span class="string">&#x27;bcd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[:-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aString[:]</span><br><span class="line"><span class="string">&#x27;abcd&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意：起始&#x2F;结束索引都没有指定的话会返回整个字符串。</p>
<h3 id="成员操作符（in-not-in）"><a href="#成员操作符（in-not-in）" class="headerlink" title="成员操作符（in, not in）"></a>成员操作符（in, not in）</h3><p>成员操作符用于判断一个字符或者一个子串（中的字符）是否出现在另一个字符串中。出现则返回True，否则返回False。注意，成员操作符不是用来判断一个字符串是否包含另一个字符串的，这样的功能由find()或者index()（还有它们的兄弟：rfind()和rindex()）函数来完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;bc&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abcd&#x27;</span>  <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;n&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abcd&#x27;</span>  <span class="literal">False</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;nm&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abcd&#x27;</span> <span class="literal">True</span></span><br><span class="line"><span class="comment"># 用下面这些string模块预定义的字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> string</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.ascii_uppercase</span><br><span class="line"><span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.ascii_lowercase</span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.ascii_letters</span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.digits</span><br><span class="line"><span class="string">&#x27;0123456789&#x27;</span></span><br></pre></td></tr></table></figure>

<p>下面例子是一个用来检查Python有效标识符的小脚本，名字是idcheck.py。我们知道，Python标识符必须以字母或下划线开阔大，后面跟字母，下划线或者数字。</p>
<p>标识符合法性检查，首先要以字母或者下划线开始，后面要跟字母，下划线或者数字。这个小例子只检查长度大于等于2的标识符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">alphas = string.letters + <span class="string">&#x27;_&#x27;</span></span><br><span class="line">nums =  string.digits</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Welcome to the Identifier Checker V1.0&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Testees must be at least 2 chars long.&#x27;</span></span><br><span class="line">inp = raw_input(<span class="string">&#x27;Identifier to test?&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(myInput) &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> myInput[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> alphas:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;&#x27;&#x27;invalid: first symbol must be</span></span><br><span class="line"><span class="string">        alphabetic &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> otherChar <span class="keyword">in</span> myInput[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> otherChar <span class="keyword">not</span> <span class="keyword">in</span> alphas + nums:</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;&#x27;&#x27;invalid: remaining</span></span><br><span class="line"><span class="string">                symbols must be alphanumeric&#x27;&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&quot;okay as an identifier&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个例子还展示了字符串连接符（+）的使用，本章的后面会讲到字符串连接符。运行几次后得到下面的输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python idcheck.py</span><br><span class="line">Welcome to the Identifier Checker v1<span class="number">.0</span></span><br><span class="line">Testees must be at least <span class="number">2</span> chars long. Identifier to test? counter</span><br><span class="line">okay <span class="keyword">as</span> an identifier</span><br><span class="line">$</span><br><span class="line">$ python idcheck.py</span><br><span class="line">Welcome to the Identifier Checker v1<span class="number">.0</span></span><br><span class="line">Testees must be at least <span class="number">2</span> chars long. Identifier to test? 3d_effects</span><br><span class="line">invalid: first symbol must be alphabetic</span><br></pre></td></tr></table></figure>

<p>核心提示：性能</p>
<p>一般来说，从性能的角度来考虑，把重复操作作为参数放到循环里面进行是非常低效的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(myString):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;character %d is:&#x27;</span>, myString[i]</span><br></pre></td></tr></table></figure>

<p>上面的循环操作把大把的时间都浪费到了重复计算字符串myString的长度上了。每次循环迭代都要运行一次这个函数。如果把这个值做一次保存，我们就可以用更为高效的方式重写我们的循环操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lenght = <span class="built_in">len</span>(myString)</span><br><span class="line"><span class="keyword">while</span> i &lt; lenght:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;character %d is:&#x27;</span>, myString[i]</span><br><span class="line"><span class="comment"># 这个方法同样适用于上面的例子</span></span><br><span class="line"><span class="comment"># for otherChar in myInput[1:]:</span></span><br><span class="line"><span class="comment"># if otherChar not in alphas + nums:</span></span><br></pre></td></tr></table></figure>

<p>在idcheck.py例中，第18行的for循环包含了一个if语句，在这个if里面执行了合并两个字符串的操作。被合并的这两个字符串从始至终就没变过，而每次都会重新进行一次计算。如果先把这两个字符串存为一个新字符串，我们就可以直接引用这个字符串而不用进行重复计算了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alphnums = alphas + nums</span><br><span class="line"><span class="keyword">for</span> otherChar <span class="keyword">in</span> myInput[<span class="number">1</span>:]:</span><br><span class="line">    <span class="keyword">if</span> otherChar <span class="keyword">not</span> <span class="keyword">in</span> alphnums:</span><br><span class="line">    .</span><br><span class="line">    .</span><br></pre></td></tr></table></figure>

<h3 id="连接符（-）运行时刻字符串连接"><a href="#连接符（-）运行时刻字符串连接" class="headerlink" title="连接符（+）运行时刻字符串连接"></a>连接符（+）运行时刻字符串连接</h3><p>我们可以通过连接操作符来从原有字符串获得一个新的字符串，如下例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Spanish&#x27;</span> + <span class="string">&#x27;Inquisition&#x27;</span></span><br><span class="line">SpanishInquisition</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Spanish&#x27;</span> + <span class="string">&#x27; &#x27;</span> + <span class="string">&#x27;Inquisition&#x27;</span></span><br><span class="line">Spanish Inquisition</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;Spanish&#x27;</span> + <span class="string">&#x27; &#x27;</span> + <span class="string">&#x27;Inquisition&#x27;</span> + <span class="string">&#x27;Made Easy&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">&#x27;Spanish Inquisition Made Easy&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> string</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.upper(s[:<span class="number">3</span>] + s[<span class="number">20</span>])  </span><br><span class="line"><span class="string">&#x27;SPAM&#x27;</span></span><br></pre></td></tr></table></figure>

<p>最后一个例子展示了用一个字符串s的两个切片来构成一个新串的操作，从“Spanish”里面切出”Spa”加上从Made里面切出来的“M”。将抽取出来字符串切片连接后作为参数传给了string.upper()方法，该方法负责把字符串的所有字符都变为大写。String模块的方法是在Python1.6里面添加进来的，所以这个操作也可以用最后一个字符串的一个单一方法调用来完成（见下面的例子）。现在已经没有必要导入string模块了。除非你需要访问该模块自己定义的字符串常量。注意：虽然对初学者来说string模块的方式更便于理解，但出于性能方面的考虑，我们还是建议你不要用string模块。原因是Python必须为每个参加连接操作的字符串分配新的内存，包括新产生的字符串。取而代之，我们推荐你像下面介绍的那样使用字符串格式化操作符（%），或者把所有的字符串放到一个列表中去，然后用一个join()方法来把它们连接在一起。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%s %s&#x27;</span> % (<span class="string">&#x27;Spanish&#x27;</span>,<span class="string">&#x27;Inquisition&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Spanish Inquisition&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27; &#x27;</span>.join((<span class="string">&#x27;Spanish&#x27;</span>,<span class="string">&#x27;Inquisition&#x27;</span>,<span class="string">&#x27;Made Easy&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">&#x27;Spanish Inquisition Made Easy&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># no need to import string to use string.upper():</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">&#x27;%s%s&#x27;</span> % (s[:<span class="number">3</span>],s[<span class="number">20</span>])).upper()</span><br><span class="line"><span class="string">&#x27;SPAM&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="编译时字符串连接"><a href="#编译时字符串连接" class="headerlink" title="编译时字符串连接"></a>编译时字符串连接</h3><p>上面的语法在运行时字符串连接的加法操作，这个用法是非常标准的。Python中还有一种并不是经常用到，更像是一种程序员的习惯用法的语法。Python的语法允许你在源码中把几个字符串连在一起写，从此来构建新字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = <span class="string">&quot;Hello&quot;</span><span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo</span><br><span class="line"><span class="string">&#x27;Helloworld&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过这种方法，你可以把长的字符串分成几部分来写，面不用加反斜杠。如上所示，你可以在一行里面混用两种分号。这种写法的好处是你可以把注释也加进来，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = urllib.urlopen(<span class="string">&#x27;http://&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;:8000&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;/cgi-bin/friends2.py&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="comment"># 如你所想，下面就是urlopen()方法所得到的真实输入：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;http://&#x27;</span><span class="string">&#x27;localhost&#x27;</span><span class="string">&#x27;:8000&#x27;</span><span class="string">&#x27;/cgi-bin/friends2.py&#x27;</span></span><br><span class="line"><span class="string">&#x27;http://localhost:8000/cgi-bin/friedns2.py&#x27;</span>  </span><br></pre></td></tr></table></figure>

<h3 id="普通字符串转化为Unicode字符串"><a href="#普通字符串转化为Unicode字符串" class="headerlink" title="普通字符串转化为Unicode字符串"></a>普通字符串转化为Unicode字符串</h3><p>如果把一个普通字符串和一个Unicode字符串做连接处理，Python会在连接操作前先把普通字符串转化为Unicode字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Hello&#x27;</span> + <span class="string">u&#x27;&#x27;</span> + <span class="string">&#x27;World&#x27;</span> + <span class="string">u&#x27;!&#x27;</span></span><br><span class="line"><span class="string">u&#x27;Hello World!&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="重复操作符（-）"><a href="#重复操作符（-）" class="headerlink" title="重复操作符（*）"></a>重复操作符（*）</h3><p>重复操作符创建一个包含了原有字符串的多个拷贝的新串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Ni!&#x27;</span> * <span class="number">3</span></span><br><span class="line"><span class="string">&#x27;Ni!Ni!Ni!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;*&#x27;</span> *<span class="number">40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>****************************************</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span> * <span class="number">20</span>, <span class="string">&#x27;Hello World!&#x27;</span>, <span class="string">&#x27;-&#x27;</span> * <span class="number">20</span></span><br><span class="line">--------------------Hello World!--------------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>who = <span class="string">&#x27;knights&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>who * <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;knightsknights&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>who</span><br><span class="line"><span class="string">&#x27;knights&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p>像其他的标准操作符一样，原变量是不被修改的。</p>
<h2 id="只适用于字行串的操作符"><a href="#只适用于字行串的操作符" class="headerlink" title="只适用于字行串的操作符"></a>只适用于字行串的操作符</h2><h3 id="格式化操作符（-）"><a href="#格式化操作符（-）" class="headerlink" title="格式化操作符（%）"></a>格式化操作符（%）</h3><p>Python风格的字符串格式化操作符。只适用于字符串类型，非常类似于C语言里面的printf()函数的字符串格式化，甚至所用的符号者一样，都用百分号（%），并且支持所有printf()式的格式化操作，语法如下：</p>
<p>左边的format_string里面同通常会在printf()函数的第一个参数里面见到的一样：包含%的格式化字符串，下表列出了可用的各种符号.arguments_to_convert参数是你要转化、显示的变量，对应于你送给printf的其他参数：</p>
<table>
<thead>
<tr>
<th>格式化字符</th>
<th>转换方式</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>转换成字符（ ASCII码值，或者长度为一的字符串）</td>
</tr>
<tr>
<td>%r</td>
<td>优先用repr()函数进行字符串转换</td>
</tr>
<tr>
<td>%s</td>
<td>优先用str()函数进行字符串转换</td>
</tr>
<tr>
<td>%d&#x2F;%i</td>
<td>转换成有符号十进制数</td>
</tr>
<tr>
<td>%u</td>
<td>转换成无符号十进制数</td>
</tr>
<tr>
<td>%o</td>
<td>转换成无符号八进制数</td>
</tr>
<tr>
<td>%x&#x2F;%X</td>
<td>(Unsigned)转换成无符号十六进制数（x&#x2F;X代表转换后的十六进制字符的大小写）</td>
</tr>
<tr>
<td>%e&#x2F;%e</td>
<td>转成科学计数法（e&#x2F;E控制输出e&#x2F;E）</td>
</tr>
<tr>
<td>%f&#x2F;%F</td>
<td>转换成浮点数（小数部分自然截断）</td>
</tr>
<tr>
<td>%g&#x2F;%G</td>
<td>%e和%f&#x2F;%E和%F的简写</td>
</tr>
<tr>
<td>%%</td>
<td>输出%</td>
</tr>
</tbody></table>
<ul>
<li>Python支持两种格式的输入参数。第一种是元组，这基本上是一种的C语言printf()风格的转换参数集；</li>
<li>Python支持的第二种形式是字典形式。字典其实是一个哈希键-值对的集合。这种形式里面，key是作为格式字符串出现，相对应的value值作为参数在进行转化时提供给格式字符串。格式字符串既可以跟print语句一起用来向终端用户输出数据，又可以用来合并字符串形成新字符串，而且还可以直接显示到GUI界面上去。</li>
</ul>
<p>其他的格式字符和方法见下表：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>定义宽度或者小数点精度</td>
</tr>
<tr>
<td>-</td>
<td>用做左对齐</td>
</tr>
<tr>
<td>+</td>
<td>在正数前面显示加（+）</td>
</tr>
<tr>
<td><code>&lt;sp&gt;</code></td>
<td>在正数前面显示空格</td>
</tr>
<tr>
<td>#</td>
<td>在八进制数前面显示零（’0’），在十六进制前面显示’0x’或者’0X’（取决于用的是’x’还是’X’）</td>
</tr>
<tr>
<td>0</td>
<td>显示的数字前面填充’0’而不是默认的空格</td>
</tr>
<tr>
<td>%</td>
<td>‘%%’输出一个单一的’%’</td>
</tr>
<tr>
<td>(var)</td>
<td>映射变量（字典参数）</td>
</tr>
<tr>
<td>m.n</td>
<td>m是显示的最小总宽度，n是小数点后的位数（如果可用的话）</td>
</tr>
</tbody></table>
<p>十六进制输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;%x&quot;</span> % <span class="number">108</span></span><br><span class="line"><span class="string">&#x27;6c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;%X&quot;</span> % <span class="number">108</span></span><br><span class="line"><span class="string">&#x27;6C&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;%#X&quot;</span> % <span class="number">108</span></span><br><span class="line"><span class="string">&#x27;0X6C&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;%#x&quot;</span> % <span class="number">108</span></span><br><span class="line"><span class="string">&#x27;0x6c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>浮点数和科学记数法形式输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%f&#x27;</span> % <span class="number">1234.567890</span></span><br><span class="line"><span class="string">&#x27;1234.567890&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%.2f&#x27;</span> % <span class="number">1234.567890</span></span><br><span class="line"><span class="string">&#x27;1234.57&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%E&#x27;</span> % <span class="number">1234.567890</span></span><br><span class="line"><span class="string">&#x27;1.234558E+03&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%e&#x27;</span> % <span class="number">1234.567890</span></span><br><span class="line"><span class="string">&#x27;1.234568e+03&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%g&#x27;</span> % <span class="number">1234.567890</span></span><br><span class="line"><span class="string">&#x27;1234.57&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%G&#x27;</span> % <span class="number">1234.567890</span></span><br><span class="line"><span class="string">&#x27;1234.57&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%e&#x27;</span> % (<span class="number">11111111111111111111L</span>)</span><br><span class="line"><span class="string">&#x27;1.111111e+21&#x27;</span></span><br></pre></td></tr></table></figure>

<p>整数和字符串输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;%+d&quot;</span> % <span class="number">4</span></span><br><span class="line"><span class="string">&#x27;+4&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;%+d&quot;</span> % -<span class="number">4</span></span><br><span class="line"><span class="string">&#x27;-4&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;we are at %d%%&quot;</span> % <span class="number">100</span></span><br><span class="line"><span class="string">&#x27;we are at 100%&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Your host is: %s&#x27;</span> % <span class="string">&#x27;earth&#x27;</span></span><br><span class="line"><span class="string">&#x27;Your host is: earth&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Host: %s\tPort:%d&#x27;</span> % (<span class="string">&#x27;mars&#x27;</span>,<span class="number">80</span>)</span><br><span class="line"><span class="string">&#x27;Host: mars Port: 80&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num = <span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;dec: %d/oct: %#o/hex: %#X&#x27;</span> % (num, num, num)</span><br><span class="line"><span class="string">&#x27;dec: 123/oct: 0173/hex: 0x7B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;MM/DD/YY = %02d/%02d/%d&quot;</span> % (<span class="number">2</span>, <span class="number">15</span>, <span class="number">67</span>)</span><br><span class="line"><span class="string">&#x27;MM/DD/YY = 02/15/67&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w, p = <span class="string">&#x27;Web&#x27;</span>, <span class="string">&#x27;page&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;http://xxx.yyy.zzz/%s/%s.html&#x27;</span> % (w, p)</span><br><span class="line"><span class="string">&#x27;http://xxx.yyy.zzz/Web/page.html&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子都是使用的元组类型的参数作转换，下面我们将把字典类型的参数提供给格式化操作符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;There are %(howmany)d % (lang)s Quotation Symbols&#x27;</span> % &#123;<span class="string">&#x27;lang&#x27;</span>:<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;homany&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="string">&#x27;There are 3 Python Quotation Symbols&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="令人称奇的调试工具"><a href="#令人称奇的调试工具" class="headerlink" title="令人称奇的调试工具"></a>令人称奇的调试工具</h3><p>字符串格式化操作符不权很酷，易用，上手快，而且是一个非常有用的调试工具，事实上所有的Python对象都有一个字符串表示形式（通过repr()函数，’’ 或str()函数来展现）.print语句自动为每个对象调用str()函数。更好的是，在定义自己的对象的，你可以利“钩子”为你的对象字符串表达形式。这样repr()，str()或’’或者print被调用时，就可以获得一个适当的字符串描述信息。即使在坏的不能再坏的情况下，repr()或者str()也不能显示一个对象的信息时，Pythonic方式的默认做法最起码能给你返回想如下格式的信息：<br>&lt;… something that is useful …&gt;</p>
<h3 id="字符串模板：更简单的替代品"><a href="#字符串模板：更简单的替代品" class="headerlink" title="字符串模板：更简单的替代品"></a>字符串模板：更简单的替代品</h3><p>字符串格式化操作符是Python里面处理这类问题的主要手段，而且以后也是如此。然而它也不是完美的，其中的一个缺点是它不是那么直观，尤其对刚从C&#x2F;C++转过来的Python新手来说更是如此，即使是现在使用字典形式转换的程序员也会偶尔出现遗漏转换类型符号的错误，比如说，用了%(lang)而不是正确的%(lang)s.为了保证字符串被正确的转换，程序员必须明确的记住转换类型参数，比如到底是要转成字符串，整数还是其他什么类型。</p>
<p>新式的字符串模板的优势是不用去记住所有的相关细节的，而是像现在shell风格的脚本语言里面那样使用美元符号（$）。</p>
<p>由于新式的字符串Template对象的引进使得string模块又重新活了过来，Template对象有两个方法，substitute()和safe_substitute()。前者更为严谨，在key缺少的情况下它会报一个KeyError的异常出来，而后者在缺少key时，直接原封不动的把字符串显示出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Template(<span class="string">&#x27;There are $&#123;howmany&#125; $&#123;lang&#125; Quotation Symbols&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> s.substitute(lang=<span class="string">&#x27;Python&#x27;</span>, howmany=<span class="number">3</span>) There are <span class="number">3</span> Python Quotation Symbols</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> s.substitute(lang=<span class="string">&#x27;Python&#x27;</span>) Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">File <span class="string">&quot;/usr/local/lib/python2.4/string.py&quot;</span>, line <span class="number">172</span>, <span class="keyword">in</span> substitute</span><br><span class="line"><span class="keyword">return</span> self.pattern.sub(sonvert, self.template)</span><br><span class="line">File <span class="string">&quot;/usr/local/lib/python2.4/string.py&quot;</span>, line <span class="number">162</span>, <span class="keyword">in</span> convert val = mapping[named]</span><br><span class="line">KeyError: <span class="string">&#x27;howmany&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> s.safe_substitute(lang=<span class="string">&#x27;Python&#x27;</span>) There are $&#123;howmany&#125; Python Quotation Symbols</span><br></pre></td></tr></table></figure>

<p>新式的字符串模板是从Python2.4开始加入的，更多的信息请查阅Python类库手册和PEP292.</p>
<h3 id="原始字符串操作符（r-x2F-R）"><a href="#原始字符串操作符（r-x2F-R）" class="headerlink" title="原始字符串操作符（r&#x2F;R）"></a>原始字符串操作符（r&#x2F;R）</h3><p>关于原始字符串的目的，在Python1.5里面已经有说明，是为了对付那些在字符串中出现的特殊字符（下面的小节会介绍这些特殊字符）。在原始字符串里，所有的字符都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。</p>
<p>原始字符串的这个特性让一些工作变得非常的方便，比如正则表达式的创建。正则表达式是一些定义了高级搜索匹配方式的字符串，通常是由代表字符，分组、匹配信息、变量名、和字符类等的特殊符号组成。正则表达式模块已经包含了足够用的符号。但当你必须插入额外的符号来使特殊字符表现的像普通字符的时候，你就陷入了“字符数字”的泥潭！这时原始字符串就会派上用场了。</p>
<p>除了原始字符串符号（引号前面的字母“r”）以外，原始字符串跟普通字符串有着几乎完全相同的语法。</p>
<p>这个’r’可以是小写也可以是大写，唯一的要求是必须紧靠在第一个引号前。</p>
<p>在三个例子的第一个例子里面，我们需要一个反斜杠加一个’n’来而不是一个换行符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">r&#x27;\n&#x27;</span></span><br><span class="line"><span class="string">&#x27;\\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">r&#x27;\n&#x27;</span></span><br><span class="line">\n </span><br></pre></td></tr></table></figure>

<p>接下来的例子里，我们打不开我们的README文件了，为什么？因为’\t’和’\r’被当成不在我们的文件名中的特殊符号，但它们实际上文件路径的中4个独立的字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;C:\windows\temp\readme.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;C:\windows\temp\readme.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">IOError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;C:\\win- dows\\temp\readme.txt&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">r&#x27;c:\windows\temp\readme.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline()</span><br><span class="line"><span class="string">&#x27;Table of Contents (please check timestamps for last update)\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure>

<p>最后我们要找一对原始的\n字符而不是换行。为了找到它，我们使用了一个简单的正则表达式，它的作用是查找通常被用来表示空白字符的反斜线-字符对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">&#x27;\\[rtfvn]&#x27;</span>,<span class="string">r&#x27;Hello World!\n&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: m.group()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">r&#x27;\\[rtfvn]&#x27;</span>,<span class="string">r&#x27;Hello World!\n&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:m.group()</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;\\n&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><h3 id="标准类型函数-1"><a href="#标准类型函数-1" class="headerlink" title="标准类型函数"></a>标准类型函数</h3><h4 id="cmp-1"><a href="#cmp-1" class="headerlink" title="cmp()"></a>cmp()</h4><p>同比较操作符一样，内建cmp()函数也根据字符串的ASCII码值进行比较</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = <span class="string">&#x27;lmn&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(str1,str2)</span><br><span class="line">-<span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(str3,str1)</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(str2,<span class="string">&#x27;lmn&#x27;</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="序列类型函数"><a href="#序列类型函数" class="headerlink" title="序列类型函数"></a>序列类型函数</h3><h4 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(str1)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>正如您期望的那样，内建函数len()返回字符串的字符数</p>
<h4 id="max-and-min"><a href="#max-and-min" class="headerlink" title="max() and min()"></a>max() and min()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = <span class="string">&#x27;lmn&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str3 = <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(str2)</span><br><span class="line"><span class="string">&#x27;n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(str3)</span><br><span class="line"><span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>

<p>虽然max()和min()函数对其他的序列类型可能更有用，但对于string类型它们能很好地运行，返回最大或最小的字符（按照ASCII码值排列），下面几个列子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(<span class="string">&#x27;ab12cd&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(<span class="string">&#x27;AB12CD&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(<span class="string">&#x27;AbabCDcd&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate()"></a>enumerate()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> i, t </span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> f </span><br><span class="line"><span class="number">1</span> o</span><br><span class="line"><span class="number">2</span> o</span><br><span class="line"><span class="number">3</span> b</span><br><span class="line"><span class="number">4</span> a</span><br><span class="line"><span class="number">5</span> r</span><br></pre></td></tr></table></figure>

<h4 id="zip"><a href="#zip" class="headerlink" title="zip()"></a>zip()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s, t = <span class="string">&#x27;foa&#x27;</span>, <span class="string">&#x27;obr&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(s, t)</span><br><span class="line">[(<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;o&#x27;</span>),(<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;b&#x27;</span>),(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="字符串类型函数"><a href="#字符串类型函数" class="headerlink" title="字符串类型函数"></a>字符串类型函数</h3><h4 id="raw-input"><a href="#raw-input" class="headerlink" title="raw_input()"></a>raw_input()</h4><p>内建的raw_input()函数使用给定字符串提示用户输入并将这个输入返回，如下例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_input = raw_input(<span class="string">&quot;Enter your name:&quot;</span>)</span><br><span class="line">Enter your name: Jonh Doe</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_input</span><br><span class="line"><span class="string">&#x27;John Doe&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(user_input)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<h4 id="str-and-unicode"><a href="#str-and-unicode" class="headerlink" title="str() and unicode()"></a>str() and unicode()</h4><p>str()和unicode()函数都是工厂函数，就是说产生所对应的类型的对象。它们接受一个任意类型的对象，然后创建该对象的可打印的或者Unicode的字符串表示，它们和basestring都可以作为参数传给isinstance() 函数来判断一个对象的类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">u&#x27;\0xAB&#x27;</span>,<span class="built_in">str</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="built_in">isinstance</span>(<span class="string">&#x27;foo&#x27;</span>, unicode)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">u&#x27;&#x27;</span>, basestring)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="built_in">isinstance</span>(<span class="string">&#x27;foo&#x27;</span>, basestring)</span><br><span class="line"><span class="literal">False</span> </span><br></pre></td></tr></table></figure>

<h4 id="char-unichr-and-ord"><a href="#char-unichr-and-ord" class="headerlink" title="char(),unichr(), and ord()"></a>char(),unichr(), and ord()</h4><p>char()函数用一个范围在range(256)内的（就是0到255）整数做参数，返回一个对应的字符。unichr()跟它一样，只不过返回的是Unicode字符。</p>
<p>ord()函数是chr()函数或unichr()函数的配对函数，它以一个字符（长度为1的字符串）做为参数，返回对应的ASCII数值，或者Unicode数值，如果所给的Unicode字符超出了你的Python定义范围，则会引发一个TypeError的异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>char(<span class="number">65</span>)</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unichr(<span class="number">12345</span>)</span><br><span class="line"><span class="string">u&#x27;\u3039&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>char(<span class="number">12345</span>)</span><br><span class="line">Traceback (most recent call last): File <span class="string">&quot;&lt;stdin&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span>?</span><br><span class="line"><span class="built_in">chr</span>(<span class="number">12345</span>)</span><br><span class="line">ValueError: <span class="built_in">chr</span>() arg <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>) </span><br></pre></td></tr></table></figure>

<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>从Python1.6起引进的Unicode字符串支持，是用来在多种双字节字符的格式、编码进行转换的，其中包括一些对这类字符串的操作管理功能。内建的字符串和正则表达式对Unicode字符串的支持，再加上string模块的辅助，Python已经可以应付大部分应用对Unicode的存储、访问、操作的需要了。我们会尽最大的努力把Python对Unicode的支持说清楚，但在这之前，让我们先讨论一些基本的术语，然后问一下自己，到底什么是Unicode？</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><table>
<thead>
<tr>
<th>名词</th>
<th>意思</th>
</tr>
</thead>
<tbody><tr>
<td>ASCII</td>
<td>美国标准信息交换码</td>
</tr>
<tr>
<td>BMP</td>
<td>基本多文种平面（第零平面）</td>
</tr>
<tr>
<td>BOM</td>
<td>字节顺序标记（标识字节顺序的字符）</td>
</tr>
<tr>
<td>CJK&#x2F;CJKV</td>
<td>中文-日文-韩文（或越南语）的缩写</td>
</tr>
<tr>
<td>Code point</td>
<td>类似于ASCII值，代表Unicode字符的值，范围在range(1114112)或者说0x000000到0x10FFFF</td>
</tr>
<tr>
<td>Octet</td>
<td>八位二进制数的位组</td>
</tr>
<tr>
<td>UCS</td>
<td>通用字符集</td>
</tr>
<tr>
<td>CS2</td>
<td>UCS的双字节编码方式（见UTF-16）</td>
</tr>
<tr>
<td>UCS4</td>
<td>UCS的四字节编码方式</td>
</tr>
<tr>
<td>UTF</td>
<td>Unicode或者UCS的转换格式</td>
</tr>
<tr>
<td>UTF-8</td>
<td>八位UTF转换格工（无符号字节序列，长度为一到四个字节）</td>
</tr>
<tr>
<td>UTF-16</td>
<td>16位UTF转换格式（无符号字节序列，通常是16位长[两字节]，见UCS2）</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="什么是Unicode？"><a href="#什么是Unicode？" class="headerlink" title="什么是Unicode？"></a>什么是Unicode？</h3><p>Unicode是计算机可以支持这个星球上多种语言的秘密武器。在Unicode之前，用的都是ASCII，ASCII码非常简单，每个英文字符都是以七位二进制数的方式存储在计算机内，其范围是32到126。当用户在文件中链入一个大写字符A时，计算机会把A的ASCII码值65写入磁盘，然后当计算机读取该文件时，它会首先把65转化成字符A然后显示到屏幕上。</p>
<p>ASCII编码的文件小巧易读。一个程序只需简单地把文件的每个字节读出来，把对应的数值转换成字符显示出来就可以了。但是ASCII字符只能表示95个可打印字符。后来的软件厂商把ASCII码扩展到了8位，这样一来它就可以多标识128个字符，可是223个字符对需要成千上万的字符的非欧洲语系的语言来说仍然太少。</p>
<p>Unicode通过使用一个或多个字节来表示一个字符的方法突破了ASCII的限制，在这样机制下，Unicode可以表示超过90000个字符。</p>
<h3 id="你是怎么用Unicode的？"><a href="#你是怎么用Unicode的？" class="headerlink" title="你是怎么用Unicode的？"></a>你是怎么用Unicode的？</h3><p>早先，Python只能处理8位的ASCII值，字符串就是简单的数据类型，为了处理一个字符串，用户必须首先创建一个字符串，然后把它作为参数传给string模块的一个函数来处理。2000年，Python1.6（和2.0）版释出，Unicode第一次在Python里面得到支持。</p>
<p>为了让Unicode和ASCII码值的字符串看起来尽可能的相像，Python的字符串从原来的简单数据类型改成了真正的对象。ASCII字符串成了StringType，而Unicdoe字符串成了UnicodeType类型。它们的行为是非常相近的。string模块里面都有相应的处理函数。string模块已经停止了更新，只保留了ASCII码的支持，string模块已经不推荐使用，在任何需要跟Unicode兼容的代码里都不要再用该模块，Python保留该模块仅仅是为了向后兼容。</p>
<p>Python里面处理Unicode字符串跟处理ASCII字符串没什么两样。Python把硬编码的字符串叫做字面上的字符串，默认所有字面上的字符串都用ASCII编码，可以通过在字符串前面加一个’u’前缀的方式声明Unicode字符串，这个’u’前缀告诉Python后面的字符串要编码成Unicode字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hello World&quot;</span> <span class="comment"># ASCII string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u&quot;Hello World&quot;</span> <span class="comment"># Unicode string</span></span><br></pre></td></tr></table></figure>

<p>内建的str()函数和chr()函数并没有升级成可以处理Unicode。它们只能处理常规的ASCII编码字符串，如果一个Unicode字符串被作作为参数传给了str()函数，它会首先被转换成ASCII字符串然后在交给str()函数。如果该Unicode字符串中包含任何不被ASCII字符串支持的字符，会导致str()函数报异常，同样地，chr()函数只能以0到255作为参数工作。如果你传给它一个超出此范围的值（比如说一个Unicode字符）它会报异常。</p>
<p>新的内建函数unicode()和unichar()可以看成Unicode版本的str()和chr()。Unicode()函数可以把任何Python的数据类型转换成一个Unicode字符串，如果是对象，并且该对象定义了__unicode__()方法，它还可以把该对象转换成相应的Unicode字符串。</p>
<h3 id="Codecs是什么？"><a href="#Codecs是什么？" class="headerlink" title="Codecs是什么？"></a>Codecs是什么？</h3><p>codec是COder&#x2F;DECoder的首字母组合，它定义了文本跟二进制的转换方式，跟ASCII那种用一个字节把字符转换成数字的方式不同，Unicode用的是多字节，这导致了Unicode支持多种不同的编码方式。比如说codec支持的四种耳熟能详的编码方式是：ASCII，ISO，8859-1&#x2F;Latin-1，UTF-8和UTF-16。</p>
<p>其中最著名的是UTF-8编码，它也用一个字节来编码ASCII字符。这让那些必须同时处理ASCII码和Unicoded码文本的程序员的工作变得非常轻松，因为ASCII字符的UTF-8编码跟ASCII编码完全相同。</p>
<p>UTF-8编码可以用1个到4个字节来表示其他语言的字符。CJK&#x2F;East这样的东亚文字一般都是用3个字节来表示，那些少用的、特殊的、或者历史遗留的字符用4个字节来表示。这给那些需要直接处理Unicode数据的程序员带来了麻烦，因为他们没有办法按照固定长度逐一读出各个字符。幸运的是我们不需要掌握直接读写Unicode数据的方法，Python已经替我们完成了相关细节，我们无须为处理多字节字符的复杂问题而担心。Python里面的其他编码不是很常用，事实上，我们认为大部分的Python程序员根本就用不着去处理其他的编码，UTF-16可能是个例外。</p>
<p>UTF-16可能是以后大行其道的一种编码格式，它容易读写，因为它把所有的字符都是用单独的一个16位字，两个字节来存储的，正因为此，这两个字节的顺序需要定义一下，一般的UTF-16编码文件都需要一个BOM（Byte Order Mark），或者你显式地定义UTF-16-LE（小端）或者UTF-16-BE（大端）字节序。</p>
<p>从技术上讲，UTF-16也是一种变长编码，但它不是很常用（人们一般不会知道或者根本不在意除了基本多文种平面BMP之外到底命名用是那种平面），尽管如此，UTF-16并不向后兼容ASCII，因此，实现它的程序很少，因为大家需要对ASCII进行支持。</p>
<h3 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h3><p>Unicode支持多种编码格式，这为程序员带来了额外的负担，每当你向一个文件写入字符串的时候，你必须定义一个编码（encoding参数）用于把对应的Unicode内容转换成你定义的格式，Python通过Unicode字符串的encode()函数解决了这个问题，该函数接受字符串中的字符为参数，输出你指定的编码格式的内容。</p>
<p>所以，每次我们写一个Unicode字符串到磁盘上我们都要用指定的编码器给他“编码”一下，相应地，当我们从这个文件读取数据时，我们必须“解码”该文件，使之成为相应的Unicode字符串对象。</p>
<p>简单的例子(uniFile.py)</p>
<p>下面的代码创建了一个Unicode字符串，用UTF-8编码器将它编码，然后写入到一个文件中去。接着把数据从文件中读回来，解码成Unicode字符串对象。最后打印出Unicode字符串，用以确认程序正确地运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">CODEC = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">FILE = <span class="string">&#x27;unicode.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">hello_out =  <span class="string">u&quot;Hello world\n&quot;</span></span><br><span class="line">bytes_out = hello_out.encode(CODEC)</span><br><span class="line">f = <span class="built_in">open</span>(FILE, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">f.write(bytes_out)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(FILE, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">bytes_in = f.read()</span><br><span class="line">f.close()</span><br><span class="line">hello_in = bytes_in.decode(CODEC)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">print</span> hello_in</span><br></pre></td></tr></table></figure>

<h3 id="把Unicode应用到实际应用中"><a href="#把Unicode应用到实际应用中" class="headerlink" title="把Unicode应用到实际应用中"></a>把Unicode应用到实际应用中</h3><p>这些处理Unicode字符串的例子简单到让人感到有点假，事实上，只要你遵守以下的规则，处理Unicode就是这么简单：</p>
<ul>
<li>程序出现字符串时一定要加个前缀u</li>
<li>不要用str()函数，用unicode()代替</li>
<li>不要用过时的string模块–如果传给它的是非ASCII字符，它会把一切搞砸</li>
<li>不到必须时不要在你的程序里面编解码Unicode字符，只在你要写入文件或数据库或者网络时，才调用encode()函数;相应地，只在你需要把数据读回来的时候才调用decode()函数</li>
</ul>
<p>这些规则可以规避90%由于Unicode字符串处理引起的bug。现在的问题是剩下的10%的问题却让你处理不了，幸亏Python提供了大量的模块、库来替你处理这些问题。它们可以让你用10行Python语句写出其他语言需要100行语句才能完成的功能，但是相应地，对Unicode支持的质量也完全取决于这些模块、库。</p>
<p>Python标准库里面的绝大部分模块都是兼容Unicode的。除了pickle模块，pickle模块只支持ASCII字符串。如果你把一个Unicode字符串交给pickle模块来unpickle，它会报异常。你必须先把你的字符串转换成ASCII字符串才可以。所以最好是避免基于文本的pickle操作。幸运地是现在二进制格式已经作为pickle的默认格式了，pickle的二进制格式支持不错。这点在你向数据库里面存东西是尤为突出，把它们作为BLOB字段存储而不是作为TEXT或者VARCHAR字段存储要好很多。万一有人把你的字段改成Unicode类型，这可以避免pickle的崩溃。</p>
<p>如果你的程序里面用到了很多第三方模块，那么你很可能在各个模块统一使用Unicode通讯方面遇到麻烦，Unicode还没成为一项必须的规定，在你系统里面的第三方模块（包括你的应用要面对的平台\系统）需要用相同的Unicode编码，否则，可能你就不能正确的读写数据。</p>
<p>作为一个例子，假设你正在构建一个用数据库来读写Unicode数据的Web应用。为了支持Unicode，你必须确保以下方面对Unicode的支持：</p>
<ul>
<li>数据库服务器（MySQL, PostgreSQL, SQL Server等等）</li>
<li>数据库适配器（MySQLdb等等）</li>
<li>Web开发框架（mod_python, cgi, Zope, Plane, Django等等）</li>
</ul>
<p>数据库方面最容易对付，你只要确保每张表都用UTF-8编码就可以了。</p>
<p>数据库适配器可能有点麻烦，有些适配器支持Unicode有些不支持，比如说MySQLdb，它并不是默认就支持Unicode模式，你必须在connect()方法里面用一个特殊的关键字use_unicode来确保你得到的查询结果是Unicode字符串。</p>
<p>mod_python里面开启对Unicode的支持相当简单，只要在request对象里面把text-encoding一项设成“utf-8”就行了。剩下的mod_python都会替你完成，Zope等其他复杂的系统可能需要更多的工作来支持Unicode。</p>
<h3 id="从现实中得来的教训"><a href="#从现实中得来的教训" class="headerlink" title="从现实中得来的教训"></a>从现实中得来的教训</h3><p><span style="color:red;font-weight:bold">失误#1：</span>你必须在一个极有限的时间内写出一个大型的应用，而且需要其他语言的支持，但是产品经理并没有明确定义这一点。你并没有考虑Unicode的兼容，直到项目快要结束…，这时候再添加Unicode的支持几乎不太可能，不是吗？</p>
<p><span style="color:blue;font-weight:bold">结果#1：</span>没能预测到最终用户对其他语言界面的需求，在集成他们用的面向其他语各的应用时以没有使用Unicode支持，更新整个系统既让人觉得枯燥和更是浪费时间。</p>
<p><span style="color:red;font-weight:bold">失误#2：</span>在源码中到处使用string模块或者str()和chr()函数</p>
<p><span style="color:blue;font-weight:bold">结果#2：</span>通过全局的查找替换把str()和chr()替换成unicode()和unichr()，但是这样一来很可能就不能再用pickle模块，要用只能把所有要pickle处理的数据存成二进制形式，这样一来就必须修改数据库结构，而修改数据库结构就意味着全部推倒重要。</p>
<p><span style="color:red;font-weight:bold">失误#3：</span>不能确定所有的辅助系统都完全地支持Unicode</p>
<p><span style="color:blue;font-weight:bold">结果#3：</span>不得不去为那些系统打补丁，而其中有些系统可能你根本就没有源码，修复对Unicode支持的bug可能会降低代码的可靠性，而且非常有可能引入新的bug。</p>
<p>总结：使应用程序完全支持Unicode，兼容其他的语言本身就是一个工程。</p>
<p>它需要详细的考虑、计划。所有涉及到的软件、系统都需要检查，包括Python的标准库和其他将要用到的第三方扩展模块。你甚至有可能需要组建一个经验丰富的团队来专门负责国际化（I18N）问题</p>
<h3 id="Python的Unicode支持"><a href="#Python的Unicode支持" class="headerlink" title="Python的Unicode支持"></a>Python的Unicode支持</h3><p><span style="font-weight:bold;">内建的unicode()函数</span></p>
<p>Unicode的工厂方法，同Unicode字符串操作符（u&#x2F;U）的工作方式很类似，它接受一个string做参数，返回一个Unicode字符串。</p>
<p><span style="font-weight:bold;">内建decode()&#x2F;encode()方法</span></p>
<p>decode()和encode()内建函数接受一个字符串做参数返回该字符串对应的解码后&#x2F;编码后的字符串。decode()和encode()都可以应用于常规字符串和Unicode字符串。decode()方法是在Python2.2以后加入的。</p>
<p><span style="font-weight:bold;">Unicode类型</span></p>
<p>Unicode字符串对象是basestring的子类、用Unicdoe（）工厂方法或直接在字符串前面加一个u或者U来创建实例。支持Unicode原始字符串，只要在你的字符串前面加一个ur或者UR就可以了。</p>
<p><span style="font-weight:bold;">Unicode序数</span></p>
<p>标准内建函数ord()工作方式相同，最近已经升级到可以支持Unicode对象了。内建的unichr()函数返回一个对应的Unicode字符（需要一个32位的值）；否则就产生一个ValueError异常</p>
<p><span style="font-weight:bold;">强制类型转换</span></p>
<p>混合类型字符串操作需要把普通字符串转换成Unicode对象</p>
<p><span style="font-weight:bold;">异常</span></p>
<p>UnicodeError异常是在exceptions模块中定义的，ValueError的子类。所有关于Unicode编解码的异常都要继承自UnicodeError。详见encode()函数。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="如何更新列表"><a href="#如何更新列表" class="headerlink" title="如何更新列表"></a>如何更新列表</h3><p>你可以通过在等号的左边指定一个索引或者索引范围的方式来更新一个或几个元素，你也可以用append()方法来追加元素到列表中去。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="number">123</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="number">4.56</span>,[<span class="string">&#x27;inner&#x27;</span>,<span class="string">&#x27;list&#x27;</span>],(<span class="number">7</span>-<span class="number">9j</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="number">2</span>]</span><br><span class="line"><span class="number">4.56</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="number">2</span>] = <span class="string">&#x27;float replacer&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="number">123</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;float replacer&#x27;</span>,[<span class="string">&#x27;inner&#x27;</span>,<span class="string">&#x27;list&#x27;</span>],(<span class="number">7</span>-<span class="number">9j</span>)]</span><br><span class="line">&gt;&gt;&gt;anotherList = [<span class="literal">None</span>,<span class="string">&#x27;something to see here&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>anotherlist.append(<span class="string">&#x27;hi,i&#x27;</span>m new here<span class="string">&quot;)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print anotherlist</span></span><br><span class="line"><span class="string">[None, &#x27;something to see here&#x27;, &quot;</span>I<span class="string">&#x27;m tiki&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="如何删除列表中的元素或者列表（本身）"><a href="#如何删除列表中的元素或者列表（本身）" class="headerlink" title="如何删除列表中的元素或者列表（本身）"></a>如何删除列表中的元素或者列表（本身）</h3><p>要删除列表中的元素，如果你确切的知道要删除元素的索引可以用del语句，否则可以用remove()方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="number">123</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;float replacer&#x27;</span>,[<span class="string">&#x27;inner&#x27;</span>,<span class="string">&#x27;list&#x27;</span>],(<span class="number">7</span>-<span class="number">9j</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> aList[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="number">123</span>,<span class="string">&#x27;float replacer&#x27;</span>,[<span class="string">&#x27;inner&#x27;</span>,<span class="string">&#x27;list&#x27;</span>],(<span class="number">7</span>-<span class="number">9j</span>)]</span><br><span class="line">&gt;&gt;&gt;aList.remove(<span class="number">123</span>)</span><br><span class="line"> [<span class="string">&#x27;float replacer&#x27;</span>,[<span class="string">&#x27;inner&#x27;</span>,<span class="string">&#x27;list&#x27;</span>],(<span class="number">7</span>-<span class="number">9j</span>)]</span><br></pre></td></tr></table></figure>
<p>你还可以通过pop()方法来删除并从列表中返回一个特定对象。</p>
<p>一般来说，程序员不需要去删除一个列表对象。列表对象出了作用域后它会自动的被析构，但是如果你想明确的删除一整个列表，你可以用del语句<br><code>del aList</code></p>
<h2 id="操作符-1"><a href="#操作符-1" class="headerlink" title="操作符"></a>操作符</h2><h3 id="标准类型操作符-4"><a href="#标准类型操作符-4" class="headerlink" title="标准类型操作符"></a>标准类型操作符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="string">&#x27;abc&#x27;</span>,<span class="number">123</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list2 = [<span class="string">&#x27;xyz&#x27;</span>,<span class="number">789</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list3 = [<span class="string">&#x27;abc&#x27;</span>,<span class="number">123</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 &lt; list2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list2 &lt; list3</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list2 &gt; list3 <span class="keyword">and</span> list1 == list3</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>在使用比较操作符时，比较数字和字符串是很明了的，但是用在列表上时就不是那么简单了，列表比较操作有些狡猾，但是合乎逻辑。比较列表时也是用的内建的cmp()函数，基本的比较逻辑是这样的：两个列表的元素分别比较，直到有一方的元素胜出，比如我们上面的例子，’abc’和’xyz’的比较直接决定了比较结果，在’abc’&lt;’xyz’时，list1 &lt; list2, list2 &gt;&#x3D; list3，元组类型在进行比较操作时跟列表遵循相同的逻辑。</p>
<h3 id="序列类型操作符-1"><a href="#序列类型操作符-1" class="headerlink" title="序列类型操作符"></a>序列类型操作符</h3><p><span style = "font-weight: bold;">切片（[][:]）</span></p>
<p>列表的切片操作跟字符串的切片操作很象，不过列表的切片操作返回的是一个对象或是几个对象的集合，而不是像字符串那样，返回一个字符或一个子串，我们定义以下几个列表用来做例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list = [<span class="number">43</span>, -<span class="number">1.23</span>, -<span class="number">2</span>, <span class="number">6.19e5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_list = [<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;jumped&#x27;</span>, <span class="string">&#x27;over&#x27;</span>, <span class="string">&#x27;candlestick&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mixup_list = [<span class="number">4.0</span>, [<span class="number">1</span>,<span class="string">&#x27;x&#x27;</span>], <span class="string">&#x27;beef&#x27;</span>, -<span class="number">1.9</span>+<span class="number">6j</span>]</span><br></pre></td></tr></table></figure>

<p>列表的切片操作也遵从正负索引规则，也有开始索引值，结束索引值，如果这两个值为空，默认也会分别指到序列的开始和结束位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list[<span class="number">1</span>]</span><br><span class="line">-<span class="number">1.23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list[<span class="number">1</span>:]</span><br><span class="line">[-<span class="number">1.23</span>, -<span class="number">2</span>, <span class="number">619000.0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list[<span class="number">2</span>:-<span class="number">1</span>]</span><br><span class="line">[-<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_list[<span class="number">2</span>]</span><br><span class="line">[<span class="string">&#x27;over&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_list[:<span class="number">2</span>]</span><br><span class="line">[<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;jumped&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mixup_list</span><br><span class="line">[<span class="number">4.0</span>, [<span class="number">1</span>,<span class="string">&#x27;x&#x27;</span>], <span class="string">&#x27;beef&#x27;</span>, -<span class="number">1.9</span>+<span class="number">6j</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mixup_list[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="string">&#x27;x&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>跟字符串类型只能用字符为元素不同，列表类型的元素可以是另一个序列类型，这就意味着你在列表的元素上也可以使用所有的序列操作符或者在其之上执行序列类型内建的各种操作。在下面的例子中，我们会展示，不仅可以在一个切片操作的结果之上再进行切片，而且还可以改变这个切片的结果，即使新对象的类型跟原对象不同也可以。你会注意到，这跟多维数组有一些类似。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mixup_list[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mixup_list[<span class="number">1</span>][<span class="number">1</span>] = -<span class="number">64.875</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mixup_list</span><br><span class="line">[<span class="number">4.0</span>, [<span class="number">1</span>,-<span class="number">64.875</span>], <span class="string">&#x27;beef&#x27;</span>, -<span class="number">1.9</span>+<span class="number">6j</span>]</span><br><span class="line"><span class="comment"># 用num_list来做的另一个例子：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list</span><br><span class="line">[<span class="number">43</span>, -<span class="number">1.23</span>, -<span class="number">2</span>, <span class="number">6.10e5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list[<span class="number">2</span>:<span class="number">4</span>] = [<span class="number">16.0</span>, -<span class="number">49</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list</span><br><span class="line">[<span class="number">43</span>, -<span class="number">1.23</span>, <span class="number">16.0</span>, -<span class="number">49</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list[<span class="number">0</span>] = [<span class="number">65535L</span>, <span class="number">2e30</span>, <span class="number">76.45</span>-<span class="number">1.3j</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list</span><br><span class="line">[[<span class="number">65535L</span>, <span class="number">2e30</span>, <span class="number">76.45</span>-<span class="number">1.3j</span>], -<span class="number">1.23</span>, <span class="number">16.0</span>, -<span class="number">49</span>]</span><br></pre></td></tr></table></figure>

<p>注意在最后一个例子中，我们是如何把列表的单一元素替换成一个列表。在列表中进行诸如remove, add和replace的操作是多么的自由了吧！还有一点要注意，如果你想以子列表的形式得到一个列表中的一个切片，那需要确保在赋值时等号的左边也是一个列表而不是一个列表的元素。</p>
<p><span style = "font-weight: bold;">成员关系操作（in, not in）</span></p>
<p>列表中（同样适用于元组），我们可以检查一个对象是否是一个列表（或者元组）的成员</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mixup_list</span><br><span class="line">[<span class="number">4.0</span>, [<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], <span class="string">&#x27;beef&#x27;</span>, (-<span class="number">1.9</span>+<span class="number">6j</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;beef&#x27;</span> <span class="keyword">in</span> mixup_list</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> mixup_list</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> mixup_list[<span class="number">1</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list</span><br><span class="line">[[<span class="number">65535L</span>, <span class="number">2e30</span>, <span class="number">76.45</span>-<span class="number">1.3j</span>], -<span class="number">1.23</span>, <span class="number">16.0</span>, -<span class="number">49</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">49</span> <span class="keyword">in</span> num_list</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">34</span> <span class="keyword">in</span> num_list</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">65536L</span>, <span class="number">2e+030</span>, (<span class="number">76.45</span>-<span class="number">1.3j</span>)] <span class="keyword">in</span> num_list</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>注意，’x’并不属于mixup_list，因为’x’本身并不是mixup_list的一个成员，而是mixup_list[1]的，mixup_list[1]也是一个列表类型。成员关系操作运算同样适用于元组类型。</p>
<p><span style = "font-weight: bold;">连接操作符（+）</span></p>
<p>连接操作符允许我们把多个列表对象合并在一起。注意，列表类型的连接操作也只能在同类型之间进行，换句话说，你不能把两个不同类型的对象连接在一起，即便他们都是序列类型也不行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list = [<span class="number">43</span>, -<span class="number">1.23</span>, -<span class="number">2</span>, <span class="number">6.19e5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_list = [<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;jumped&#x27;</span>, <span class="string">&#x27;over&#x27;</span>, <span class="string">&#x27;candlestick&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mixup_list = [<span class="number">4.0</span>, [], <span class="string">&#x27;beef&#x27;</span>, -<span class="number">1.9</span>+<span class="number">6j</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list + mixup_list</span><br><span class="line">[<span class="number">43</span>, -<span class="number">1.23</span>, -<span class="number">2</span>, <span class="number">619000.0</span>, <span class="number">4.0</span>, [<span class="number">1</span>,<span class="string">&#x27;x&#x27;</span>],<span class="string">&#x27;beef&#x27;</span>,(-<span class="number">1.9</span>+<span class="number">6j</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_list + num_list</span><br><span class="line">[<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;jumped&#x27;</span>, <span class="string">&#x27;over&#x27;</span>, <span class="string">&#x27;candlestick&#x27;</span>, <span class="number">43</span>, -<span class="number">1.23</span>, -<span class="number">2</span>, <span class="number">619000.0</span>]</span><br></pre></td></tr></table></figure>

<p>在这前我们讲过可以用extend()方法来代替连接操作符把一个列表的内容添加到另一个中去。使用extend()方法比连接操作的一个优点是它实际上是把新列表添加到原有的列表里面，而不是像连接操作那样新建一个列表。list.extend()方法也被用来做复合赋值运算，也就是Python2.0中添加的替换连接操作符（+&#x3D;）。</p>
<p>必须指出，连接操作符并不能实现向列表中添加新元素的操作。在接下来的例子中，我们展示了一个试图用连接操作向列表中添加新元素报错的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list + <span class="string">&#x27;new item&#x27;</span></span><br><span class="line">Traceback (innermost last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">TypeError: illegal argument <span class="built_in">type</span> <span class="keyword">for</span> built-<span class="keyword">in</span> operation</span><br></pre></td></tr></table></figure>

<p>这个例子之所以是错误，是因为我们在连接操作符的左右两边使用了不同类型的值，列表类型+字符串类型这样的操作是非法的。显然，我们的初衷是把一个字符串作为一个新元不素添加到列表中去，不过我们的方法不正确，幸运的是，我们有一个正确的方法：使用内建函数append()</p>
<p><code>&gt;&gt;&gt; num_list.append(&#39;new item&#39;)</code></p>
<p><span style = "font-weight: bold;">重复操作符（*）</span></p>
<p>重复操作符可能更多的应用在字符串类型中，不过，列表和元组跟字符串同属序列类型，所以需要的时候也可以使用这一操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list * <span class="number">2</span></span><br><span class="line">[<span class="number">43</span>, -<span class="number">1.23</span>, -<span class="number">2</span>, <span class="number">619000.0</span>, <span class="number">43</span>, -<span class="number">1.23</span>, -<span class="number">2</span>, <span class="number">619000.0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_list * <span class="number">3</span></span><br><span class="line">[<span class="number">43</span>, -<span class="number">1.23</span>, -<span class="number">2</span>, <span class="number">619000.0</span>, <span class="number">43</span>, -<span class="number">1.23</span>, -<span class="number">2</span>, <span class="number">619000.0</span>, <span class="number">43</span>, -<span class="number">1.23</span>, -<span class="number">2</span>, <span class="number">619000.0</span>]</span><br></pre></td></tr></table></figure>

<p>Python2.0起，也开始支持复合赋值运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hr = <span class="string">&#x27;-&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hr *= <span class="number">30</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hr</span><br><span class="line"><span class="string">&#x27;------------------------------&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="列表类型操作符和列表解析"><a href="#列表类型操作符和列表解析" class="headerlink" title="列表类型操作符和列表解析"></a>列表类型操作符和列表解析</h3><p>其实Python中没有专门用于列表类型的操作符。列表可以使用大部分的对象和序弄类型的操作符。此外，列表类型有属于自己的方法，列表才有的构建–列表解析。这种方法是结合了列表的方括弧和for循环，在逻辑上描述要创建的列表的内容。我们在后面讨论列表解析，这里仅仅展示一处简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">8</span>, -<span class="number">2</span>, <span class="number">5</span>]]</span><br><span class="line">[<span class="number">16</span>, -<span class="number">4</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h2 id="内建函数-1"><a href="#内建函数-1" class="headerlink" title="内建函数"></a>内建函数</h2><h3 id="标准类型函数-2"><a href="#标准类型函数-2" class="headerlink" title="标准类型函数"></a>标准类型函数</h3><p><span style = "font-weight: bold;">cmp()</span></p>
<p>cmp()函数是如何跟其他的类型合作的（比如列表和元组类型），这些类型不仅含有数字和字符串，而且还用列表、元组、字典之类的其他对象。甚至可以是用户自定义的对象。这种情况下cmp()函数是如何工作的呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1, list2 = [<span class="number">123</span>,<span class="string">&#x27;xyz&#x27;</span>],[<span class="number">456</span>,<span class="string">&#x27;abc&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(list1,list2)</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(list2,list1)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list3 = list2 + [<span class="number">789</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list3</span><br><span class="line">[<span class="number">456</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="number">789</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(list2,list3)</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果我们比较的是两个同类的对象，比较操作是非常直观的。比如数字和字符串，直接比较它们的值就行了。对于序列类型，比较操作稍微有点复杂，但是方式上有相似Python在两个对象基本不能比较的时候尽量做出公平的结果，比如当两个对象没有关系时或者两种类型根本就没有用于比较的函数时，这时Python只能根据“逻辑”来做出结论。</p>
<p>除了这种极端的情况之外，安全又健全的比较方法是如果有不相等的情况出现，比较操作就结束。这种算法是如何工作的呢？像我们前面简短提到过的，列表的元素是可以无限迭代的。如果它的元素都是相同类型，则用标准的比较方法来作比较。否则，如果要比较的元素类型不一致，就像我们前面提到过的那样，如果比较的对象不一致，那么要得到一个准确的或者说绝对的比较结果就有些冒险。</p>
<p>当我们比较list1和list2时，list1和list2进行逐项比较。第一个比较操作发生在两个列表的第一个元素之间，比如说，123跟456比较，因为123 &lt; 456，所以list1被认为小于list2。</p>
<p>如果比较的值相等，那么两个序弄的下一个值继续比较，直到不相等的情况出现，或者到达较短的一个序列的末尾，在这种情况下，长的序列被认为是“较大”的。这就是为什么上面的list2 &lt; list3 的原因。元组类型比较也是用这种算法。最后我们以这种算法的关键点作为本节的结束：</p>
<ol>
<li>对两个列表的元素进行比较</li>
<li>如果比较的元素是同类型的，则比较其值，返回结果。</li>
<li>如果两个元素不是同一类型的，则检查它们是否是数字<br> a. 如果是数字，执行必要的数字强制类型转换，然后比较<br> b. 如果有一方的元素是数字，则另一方的元素“大”（数字是“最小的”）<br> c. 否则，通过类型名字的字母顺序进行比较</li>
<li>如果有一个列表首先到达末尾，则另一个长一点的列表“大”</li>
<li>如果我们用尽了两个列表的元素而且所有元素都是相等的，那么结果就是平局，就是说返回一个0</li>
</ol>
<h3 id="序列类型函数-1"><a href="#序列类型函数-1" class="headerlink" title="序列类型函数"></a>序列类型函数</h3><p><span style = "font-weight: bold;">len()</span></p>
<p>对字符串来说len()返回字符串的长度，就是字符串包含的字符个数。对列表或者元组来说，它会像你想像的那样返回列表或者元组的元素个数，容器里面的每个对象被作为一个项来处理。我们下面的例子用了上面已经定义的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(num_list)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(num_list)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bold;">max() and min()</span></p>
<p>max()和min()函数在字符串操作里面用处不大，因为它们能对字符串做的只能是找出字符串中“最大”和“最小”的字符（按词典序），而对列表和元组来说，它们被定义了更多的用处，比如对只包含数字和字符串对象的列表，max()和min()函数就非常有用，重申一遍，混合对象的结构越复杂返回的结构准确性就越差。然而，在有些情况下（虽然很少）这样的操作可以返回你需要的结果，我们展示了一些使用上面定义好的列表的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(str_list)</span><br><span class="line"><span class="string">&#x27;park&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(num_list)</span><br><span class="line">[<span class="number">65535L</span>, <span class="number">2e+30</span>, (<span class="number">76.45</span>-<span class="number">1.3j</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(str_list)</span><br><span class="line"><span class="string">&#x27;candlestick&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(num_list)</span><br><span class="line">-<span class="number">49</span></span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bold;">sorted() and reversed()</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">&#x27;They&#x27;</span>, <span class="string">&#x27;stamp&#x27;</span>, <span class="string">&#x27;them&#x27;</span>, <span class="string">&#x27;when&#x27;</span>, <span class="string">&quot;they&#x27;re&quot;</span>, <span class="string">&#x27;small&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">reversed</span>(s):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> t</span><br><span class="line">...</span><br><span class="line">small they<span class="string">&#x27;re when them stamp They</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; sorted(s)</span></span><br><span class="line"><span class="string">[&#x27;</span>They<span class="string">&#x27;, &#x27;</span>small<span class="string">&#x27;, &#x27;</span>stamp<span class="string">&#x27;, &#x27;</span>them<span class="string">&#x27;, &quot;they&#x27;</span>re<span class="string">&quot;, &#x27;when&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>初学者使用字符串，应该注意是如何把单引号和双引号的使用矛盾和谐掉。同时还要注意字符串排序使用的是字典序，而不是字母序（字母’T’的ASCII码值要比字母’a’的还要靠前）</p>
<p><span style = "font-weight: bold;">enumerate() and zip()</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>albums = [<span class="string">&#x27;table&#x27;</span>, <span class="string">&#x27;robot&#x27;</span>, <span class="string">&#x27;pyramid&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, album <span class="keyword">in</span> <span class="built_in">enumerate</span>(albums):</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span> i, album</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> tales </span><br><span class="line"><span class="number">1</span> robot</span><br><span class="line"><span class="number">2</span> pyramid</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn = [<span class="string">&#x27;ian&#x27;</span>, <span class="string">&#x27;stuart&#x27;</span>, <span class="string">&#x27;david&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ln = [<span class="string">&#x27;bairnson&#x27;</span>, <span class="string">&#x27;elliott&#x27;</span>, <span class="string">&#x27;paton&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(fn, ln):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="built_in">print</span>(<span class="string">&#x27;%s %s&#x27;</span> % (i,j).title())</span><br><span class="line">...</span><br><span class="line">Ian Bairnson Stuart Elliott David Paton</span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bold;">list() and tuple()</span></p>
<p>list()函数和tuple()函数接受可迭代对象（比如另一个序列）作为参数，并通过浅拷贝数据来创建一个新的列表或元组。虽然字符串也是序列类型的。但是它们并不是经常用于list()和tuple()。更多情况下，它们用于在两种类型之间进行行转换，比如你需要把一个已有的元组转成列表类型的（然后你就可以修改它的元素了）或者相反。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = [<span class="string">&#x27;tao&#x27;</span>, <span class="number">93</span>, <span class="number">99</span>, <span class="string">&#x27;time&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aTuple = <span class="built_in">tuple</span>(aList)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList, aTuple</span><br><span class="line">([<span class="string">&#x27;tao&#x27;</span>, <span class="number">93</span>, <span class="number">99</span>, <span class="string">&#x27;time&#x27;</span>],(<span class="string">&#x27;tao&#x27;</span>, <span class="number">93</span>, <span class="number">99</span>, <span class="string">&#x27;time&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList == aTuple</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>anotherList = <span class="built_in">list</span>(aTuple)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList == anotherList</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList <span class="keyword">is</span> anotherList</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> [<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> aList, aTuple, anotherList]</span><br><span class="line">[<span class="number">10903800</span>, <span class="number">11794448</span>, <span class="number">11721544</span>]</span><br></pre></td></tr></table></figure>

<p>正如我们在本章的开头所讨论的，无论list()还是tuple()都不可能做完全的转换。也就是说，你传给tuple()的一个列表对象不可能变成一个元组，而你专给list()的对象也不可能真正的变成一个列表，虽然前后两个对象（原来的和新的对象）有着相同的数据集合（所以相等&#x3D;&#x3D;），但是变量指向的地不是同一个对象了（所以执行is操作会返回false)还要注意，即使它们的所有的值都相同，一个列表也不可能“等于”一个元组）</p>
<h3 id="列表类型内建函数"><a href="#列表类型内建函数" class="headerlink" title="列表类型内建函数"></a>列表类型内建函数</h3><p>如果你不考虑range()函数的话，Python中没有特定用于列表的内建函数。range()函数接受一个数值作为输入，输出一个符合标准的列表，列表类型对象可以使用大多数的对象和序列的内建函数，并且，列表对象有属于它们自己的方法。</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>实际上元组是跟列表非常相近的另一种容器类型。元组和列表看起来不同的一点是元组用的是圆括号而列表用的是方框号。而功能上，元组和列表相比有一个很重要的区别，元组是一种不可变类型。正因为这个原因，元组能做一些列表不能做的事情…用做一个字典的key。另外当处理一组对象时，这个组默度是元组类型。</p>
<p>通常情况下，我们会先介绍可用于大部分对象的操作符和内建函数，然后是介绍针对序列类型的。最后是总结一下仅适秀于元组类型的操作符和内建函数，不过，由于元组类型跟列表类型有着如此多的共同之处。按照这种讲法我们会重复非常多的上一节内容，为了避免太多重复信息。我们会讲解元组和列表在应用于每一组操作符和内建函数上时的区别，然后讨论一下元组的不变性以及其他独特的特性。</p>
<h3 id="如何创建一个元组并给它赋值"><a href="#如何创建一个元组并给它赋值" class="headerlink" title="如何创建一个元组并给它赋值"></a>如何创建一个元组并给它赋值</h3><p>创建一个元组并给他赋值实际上跟创建一个列表并给它赋值完全一样，除了一点，只有一个元素的元组需要在元组分割符里面加一个逗号（,）用以防止跟普通的分组操作符混淆，不要忘了它是一个工厂方法！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aTuple = (<span class="number">123</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="number">4.56</span>, [<span class="string">&#x27;inner&#x27;</span>, <span class="string">&#x27;tuple&#x27;</span>], <span class="number">7</span>-<span class="number">9j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>anotherTuple = (<span class="literal">None</span>, <span class="string">&#x27;something to see here&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> aTuple</span><br><span class="line">(<span class="number">123</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="number">4.56</span>, [<span class="string">&#x27;inner&#x27;</span>, <span class="string">&#x27;tuple&#x27;</span>], <span class="number">7</span>-<span class="number">9j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> anotherTuple</span><br><span class="line">(<span class="literal">None</span>, <span class="string">&#x27;something to see here&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>emptiestPossibleTuple = (<span class="literal">None</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> emptiestPossibleTuple</span><br><span class="line">(<span class="literal">None</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="如何访问元组中的值"><a href="#如何访问元组中的值" class="headerlink" title="如何访问元组中的值"></a>如何访问元组中的值</h3><p>元组的切片操作跟列表一样，用方括号作为切片操作符（[]），里面写上索引值或者索引范围。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aTuple[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">(<span class="string">&#x27;abc&#x27;</span>, <span class="number">4.56</span>, [<span class="string">&#x27;inner&#x27;</span>, <span class="string">&#x27;tuple&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aTuple[:<span class="number">3</span>]</span><br><span class="line">(<span class="number">123</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="number">4.56</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aTuple[<span class="number">3</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;tuple&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="如何更新元组"><a href="#如何更新元组" class="headerlink" title="如何更新元组"></a>如何更新元组</h3><p>跟数字和字符串一样，元组也是不可变类型，就是说你不能更新或者改变元组的元素，在字符串章节，我们是通过现有字符串的片段再构造一个新字符串的方式解决的，对元组同样需要这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aTuple = aTuple[<span class="number">0</span>], aTuple[<span class="number">1</span>], aTuple[-<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aTuple</span><br><span class="line">(<span class="number">123</span>, <span class="string">&#x27;abc&#x27;</span>, (<span class="number">7</span>-<span class="number">9j</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">12</span>, <span class="number">34.56</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup2 = (<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup3 = tup1 + tup2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup3</span><br><span class="line">(<span class="number">12</span>, <span class="number">34.56</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如何移除一个元组的元素以及元组本身</p>
<p>删除一个单独的元组元素是不可能的，当然，把不需要的元素丢弃后，重新组成一个元组是没有问题的。</p>
<p>要显示地删除一整个元组，只要用del语句减少对象引用计数。当这个引用计数达到0的时候，该对象就会被析构。记住，大多数时候，我们不需要显式的用del删除一个对象，一出它的作用域它就会被析构，Python编程里面用到显式删除元组的情况非常之少。<br><code>del aTuple</code></p>
<h2 id="元组操作行和内建函数"><a href="#元组操作行和内建函数" class="headerlink" title="元组操作行和内建函数"></a>元组操作行和内建函数</h2><h3 id="标准类型操作符，序列类型操作符和内建函数"><a href="#标准类型操作符，序列类型操作符和内建函数" class="headerlink" title="标准类型操作符，序列类型操作符和内建函数"></a>标准类型操作符，序列类型操作符和内建函数</h3><p>元组的对象和序列类型操作符还有内建函数跟列表的完全一样。你仍然可以对元组进行切片操作，合并操作，以有多次拷贝一个元组，还可以检查一个对象是否属于一个元组，进行元组之间的比较等。</p>
<p><span style="font-weight: bold;">创建、重复、连接操作</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = ([<span class="string">&#x27;xyz&#x27;</span>, <span class="number">123</span>], <span class="number">23</span>, -<span class="number">103.4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t * <span class="number">2</span> </span><br><span class="line">([<span class="string">&#x27;xyz&#x27;</span>, <span class="number">123</span>], <span class="number">23</span>, -<span class="number">103.4</span>, [<span class="string">&#x27;xyz&#x27;</span>, <span class="number">123</span>], <span class="number">23</span>, -<span class="number">103.4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = t + (<span class="string">&#x27;free&#x27;</span>, <span class="string">&#x27;easy&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>([<span class="string">&#x27;xyz&#x27;</span>, <span class="number">123</span>], <span class="number">23</span>, -<span class="number">103.4</span>, <span class="string">&#x27;free&#x27;</span>, <span class="string">&#x27;easy&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bold;">成员关系操作，切片操作</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">23</span> <span class="keyword">in</span> t</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">123</span> <span class="keyword">in</span> t</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">1</span>:]</span><br><span class="line">(<span class="number">23</span>, -<span class="number">103.4</span>, <span class="string">&#x27;free&#x27;</span>, <span class="string">&#x27;easy&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 内建函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(t)</span><br><span class="line">([<span class="string">&#x27;xyz&#x27;</span>,<span class="number">123</span>],<span class="number">23</span>,-<span class="number">103.4</span>,<span class="string">&#x27;free&#x27;</span>,<span class="string">&#x27;easy&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(t)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(t)</span><br><span class="line"><span class="string">&#x27;free&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(t)</span><br><span class="line">-<span class="number">103.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(t, ([<span class="string">&#x27;xyz&#x27;</span>,<span class="number">123</span>],<span class="number">23</span>, -<span class="number">103.4</span>,<span class="string">&#x27;free&#x27;</span>,<span class="string">&#x27;easy&#x27;</span>))</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(t)</span><br><span class="line">[[<span class="string">&#x27;xyz&#x27;</span>,<span class="number">123</span>],<span class="number">23</span>,-<span class="number">103.4</span>,<span class="string">&#x27;free&#x27;</span>,<span class="string">&#x27;easy&#x27;</span>]</span><br><span class="line"><span class="comment"># 操作符</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">4</span>, <span class="number">2</span>) &lt; (<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">2</span>, <span class="number">4</span>) &lt; (<span class="number">3</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">2</span>, <span class="number">4</span>) == (<span class="number">3</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">2</span>, <span class="number">4</span>) == (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="元组类型操作符和内建函数，内建方法"><a href="#元组类型操作符和内建函数，内建方法" class="headerlink" title="元组类型操作符和内建函数，内建方法"></a>元组类型操作符和内建函数，内建方法</h3><p>像列表一样，元组也没有它自己专用的运算符和内建函数。上一节中描述的列表方法都跟列表对象的可变性有关，比如说排序、替换、添加等等，因为元组是不可变的，所以这些操作对元组来说就是多余，这些方法都没有被实现。</p>
<h2 id="元组的特殊特性"><a href="#元组的特殊特性" class="headerlink" title="元组的特殊特性"></a>元组的特殊特性</h2><h3 id="不可变性给元组带来了什么影响？"><a href="#不可变性给元组带来了什么影响？" class="headerlink" title="不可变性给元组带来了什么影响？"></a>不可变性给元组带来了什么影响？</h3><p>是的，我们在好多地方使用到了“不可变性”这个单词，除了这个词的计算机学科定义和实现，从应用的角度来考虑，这个词的底线是什么？一个数据类型成为不可变的到底意味着什么？</p>
<p>在三个标准不可变类型里面–数字，字符串和元组字符串–元组是受到影响最大的，一个数据类型是不可变的，简单来讲就意味着一旦一个对象被定义了，它的值就不能再被更新，除非重新创建一个新的对象。对数字和字符串的影响不是很大，因为它们是标量类型，当它们代表的值改变时，这种结果是有意义的，是按照你所想要的方式进行访问的，而对于元组，事情就不是这样了。</p>
<p>因为元组是容器对象，很多时候你想改变的只是这个容器中的一个或者多个元素，不幸的是这是不可能的，切片操作符不能用作左值进行赋值。这和字符串没什么不同，切片操作只能用于只读的操作。</p>
<p>不可变并不是坏事，比如我们把数据传给一个不了解的API时，可以确保我们的数据不会被修改。同样地，如果我们操作从一个函数返回的元组，可以通过内建list()函数把它转换成一个列表。</p>
<h3 id="元组也不是那么”不可变”"><a href="#元组也不是那么”不可变”" class="headerlink" title="元组也不是那么”不可变”"></a>元组也不是那么”不可变”</h3><p>虽然元组是被定义成不可变的，但这并不影响它的灵活性。元组并不像我们想的那么不可变，这是什么意思？其实元组几个特定的行为让它看起来并不像我们先前声称的那么不可变。</p>
<p>比如说，既然我们可以把字符串组合在一起形成一个大字符串。即么把元组组合在一起形成一个大的元组也没有什么不对，所以，连接操作可用，这个操作一点都没有改变那些小元组。我们所作的是把它们的元素结合在一起，这里有几个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;first&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = s + <span class="string">&#x27;second&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">&#x27;first second&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t  = (<span class="string">&#x27;third&#x27;</span>,<span class="string">&#x27;fourth&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="string">&#x27;third&#x27;</span>,<span class="string">&#x27;fourth&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = t + (<span class="string">&#x27;fifth&#x27;</span>, <span class="string">&#x27;sixth&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="string">&#x27;third&#x27;</span>,<span class="string">&#x27;fourth&#x27;</span>,<span class="string">&#x27;fifth&#x27;</span>,<span class="string">&#x27;sixth&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>同样的概念也适用于重复操作。重复操作只不过是多次复制同样的元素，再有，我们前面提到过可以用一个简单的函数调用把一个元组变成一个可变的列表。我们的最后一个特性可能会吓到你。你可以“修改”特定的元组元素，哇！这意味着什么？</p>
<p>虽然元组对象本身是不可变的，但这并不意味着元组包含的可变对象也不可变了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = ([<span class="string">&#x27;xyz&#x27;</span>, <span class="number">123</span>], <span class="number">23</span>, -<span class="number">103.4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>][<span class="number">1</span>] = [<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;def&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">([<span class="string">&#x27;xyz&#x27;</span>, [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>]], <span class="number">23</span>, -<span class="number">103.4</span>)</span><br></pre></td></tr></table></figure>
<p>在下面的例子中，虽然t是一个元组类型变量，但是我们设法通过替换它的第一个元素（一个列表对象）的项来“改变”了它。我们替换了t[0][1]，原来是个整数，我们把它替换成了一个列表对象[‘abc’,’def’]。虽然我们只是改变了一个可变对象，但在某种意义上讲，我们也“改变”了我们的元组类型变量。</p>
<h3 id="默认集合类型"><a href="#默认集合类型" class="headerlink" title="默认集合类型"></a>默认集合类型</h3><p>所有的多对象的，逗号分隔的，没有明确用符号定义的，比如说像用方括号表示列表和用圆括号表示元组一样，等等这些集合默认的类型都是元组，下面是一个简单的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abc&#x27;</span>, -<span class="number">4.24e93</span>, <span class="number">18</span>+<span class="number">6.6j</span>, <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line">(<span class="string">&#x27;abc&#x27;</span>, -<span class="number">4.24e93</span>, <span class="number">18</span>+<span class="number">6.6j</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y </span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>所有函数返回的多对象（不包括有符号封装的）都是元组类型。注意，有符号封装的多对象集合其实是返回的一个单一的容器对象，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo1</span>():</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="keyword">return</span> obj1, obj2, obj3</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo2</span>():</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="keyword">return</span> [obj1, obj2, obj3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo3</span>():</span><br><span class="line">. </span><br><span class="line">.</span><br><span class="line"><span class="keyword">return</span> (obj1, obj2, obj3)</span><br></pre></td></tr></table></figure>
<p>上面的例子中，foo1()返回3个对象，默认的作为一个包含3个对象的元组类型，foo2()返回一个单一对象，一个包含3个对象的列表，还有foo3()返回一个跟foo1()相同的对象。唯一不同的是这里的元组是显式定义的。</p>
<p>为了避免令人讨厌的副作用，建议总是显式的用圆括号表达式表示元组或者创建一个元组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span>, <span class="number">2</span> &lt; <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">(<span class="number">4</span>, <span class="literal">True</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">4</span>, <span class="number">2</span>) &lt; (<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>在第一个例子中小于号的优先级高于逗号，2 &lt; 3 的结果成了元组变量的第二个元素，适当的封装元组就会得到希望得到的结果。</p>
<h3 id="单元素元组"><a href="#单元素元组" class="headerlink" title="单元素元组"></a>单元素元组</h3><p>普经试过创建一个只有一个元素的元组？你在列表上试过，它可以完成，但是无论你怎么在元组上试验，你都不能得到想要的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;abc&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;abc&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>([<span class="string">&#x27;abc&#x27;</span>])</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&gt;&gt;&gt;(<span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>((<span class="string">&#x27;xyz&#x27;</span>))</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>或许你忘记了圆括号被重载了，它也被用作分组操作行。由圆括号包裹的一个单一元素首先被作为分组操作，而不是作为元组的分界符。一个变通的方法是在第一个元素后面添一个逗号（，）来表明这是一个元组而不是在做分组操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">&#x27;xyz&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;xyz&#x27;</span>,)</span><br></pre></td></tr></table></figure>

<h3 id="字典的关键字"><a href="#字典的关键字" class="headerlink" title="字典的关键字"></a>字典的关键字</h3><p>不可变对象的值是不可改变的。这就意味着它们通过hash算法得到的值总是一个值。这是作为字典健值的一个必备条件。在下一章节里面我们会讨论到，键值必须是可哈希的对象，元组变量符合这个标准，而列表变量就不行。</p>
<p><span style="font-weight: bold;">为什么要区分元组和列表变量？</span></p>
<p>一个原因是在有些情况下，使用其中的一种类型要优于使用另一种类型。最好使用不可变类型的变量的一个情况是，如果你在维护一些敏感的数据，并且需要把这些数据传递给一个并不了解的函数（或许是一个根本不是你写的API），作为一个只负责一个软件某一闻分的工程师，如果你确认你的数据不会被调用的函数篡改，你会觉得安全了许多。一个需要可变类型参数的例子是，如果你在管理动态数据集合时。你需要先把它们创建出来，逐渐地或者不定期的添加它们，或者有时还要移除一些单个的元素。这是一个必须使用可变类型对象的典型例子。幸运的是，通过内建的list()和tuple()转换函数，你可以非常轻松的在两者之间进行转换。</p>
<p>list()和tuple()函数允许你用一个列表来创建一个元组，反之亦然。如果你有一个元组变量，但你需要一个列表变量因为你要更新一下它的对象，这时list()函数就是你最好的帮手。如果你有一个列表的变量，并且想把它传递给一个函数，或许一个API，而你又想让任何人弄乱你的数据，这时tuple()函数就非常有用。</p>
<h2 id="拷贝Python对象浅拷贝和深拷贝"><a href="#拷贝Python对象浅拷贝和深拷贝" class="headerlink" title="拷贝Python对象浅拷贝和深拷贝"></a>拷贝Python对象浅拷贝和深拷贝</h2><p>对象赋值实际上是简单的对象引用。也就是说当你创建一个对象，然后把它赋给别一个变量的时候，Python并没有拷贝这个对象，而是拷贝了这个对象的引用。</p>
<p>比如，假设你想创建一对小夫妻的通用档案，名为person然后你分别为他俩拷贝一份。在下面例子中，我们展示了两种拷贝对象的方式，一种使用了切片操作，另一种用了工厂方法，为了区分出三个不同的对象，我们使用id()内建函数来显示每个对象的标识符。（我们还可以用is操作符来做相同的事情）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = [<span class="string">&#x27;name&#x27;</span>, [<span class="string">&#x27;savings&#x27;</span>, <span class="number">100.00</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hubby = person[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wifey = <span class="built_in">list</span>(person)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> person, hubby, wifey]</span><br><span class="line">[<span class="number">11826320</span>, <span class="number">12223552</span>, <span class="number">11850936</span>]</span><br></pre></td></tr></table></figure>
<p>为他们创建了初始有$100的个人存款账户。用户名改为定制的名字。但是，当丈夫取走$50后，他的行为影响到了他妻子的账户，虽然我们进行了分开的拷贝作（当然，前提是我们希望他们每个人都拥有自己单独的账号，而不是一个单一的联合账号）为什么会这样呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hubby[<span class="number">0</span>] = <span class="string">&#x27;joe&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wifey[<span class="number">0</span>] = <span class="string">&#x27;jane&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hubby, wifey</span><br><span class="line">([<span class="string">&#x27;joe&#x27;</span>,[<span class="string">&#x27;savings&#x27;</span>,<span class="number">100.0</span>]],[<span class="string">&#x27;jane&#x27;</span>,[<span class="string">&#x27;savings&#x27;</span>,<span class="number">100.0</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hubby[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">50.00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hubby, wifey</span><br><span class="line">([<span class="string">&#x27;joe&#x27;</span>,[<span class="string">&#x27;savings&#x27;</span>,<span class="number">50.0</span>]],[<span class="string">&#x27;jane&#x27;</span>,[<span class="string">&#x27;savings&#x27;</span>,<span class="number">50.0</span>]])</span><br></pre></td></tr></table></figure>
<p>原因是我们仅仅做了一个浅拷贝。对一个对象进行浅拷贝其实是新创建了一个类型跟原对象一样，其内容是原来对象元素的引用，换句话说，这个拷贝的对象本身是新的，但是它的内容不是。序列类型对象的浅拷贝是默认类型拷贝，并可以以下几种方式实施：（1）完全切片操作[:]（2）利用工厂函数，比如list()，dict()等（3）使用copy模块的copy函数。</p>
<p>你的下一个问题可能是：当妻子的名字被赋值，为什么丈夫的名字没有受到影响？难道它们的名字现在不应该都是’jane’了吗？为什么名字没有变成一样的呢？怎么会是这样呢？这是因为在这两个列表的两个对象中，第一个对象是不可变的（是个字符串类型），而第二个是可变的（一个列表）。正因为如此，当进行浅拷贝时，字符串被显式的拷贝，并新创建了一个字符串对象，而列表元素只是把它的引用复制一下，并不是它的成员。所以改变名字没有任何问题，但是更改他们银行账号的任何信息都会引发问题。现在，让我们人别看一下每个列表的元素的对象ID值，注意，银行账号对象是同一个对象，这也是为什么对一个对象进行修改会影响到另一个的原因。注意在我们改变他们的名字后，新的名字字符串是如何替换原有’名字’字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BEFORE:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> hubby]</span><br><span class="line">[<span class="number">9919616</span>, <span class="number">11826320</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> wifey]</span><br><span class="line">[<span class="number">9919616</span>, <span class="number">11826320</span>]</span><br><span class="line"><span class="comment"># AFTER:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> hubby]</span><br><span class="line">[<span class="number">12092832</span>, <span class="number">11826320</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> wifey]</span><br><span class="line">[<span class="number">12191712</span>, <span class="number">11826320</span>]</span><br></pre></td></tr></table></figure>
<p>假设我们要给这对夫妻创建一个联合账户，那这是一个非常棒的方案，但是，如果需要的是两个分离账户，就需要作些改动了。要得到一个完全拷贝或者说深拷贝–创建一个新的容器对象，包含原有对象元素（引用）全新拷贝的引用–需要copy.deepcopy()函数。我们使用深拷贝来重新整个例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = [<span class="string">&#x27;name&#x27;</span>, [<span class="string">&#x27;savings&#x27;</span>, <span class="number">100.0</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hubby = person</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wifey = copy.deepcopy(person)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> person, hubby, wifey]</span><br><span class="line">[<span class="number">12242056</span>,<span class="number">12242056</span>,<span class="number">12224232</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hubby[<span class="number">0</span>] = <span class="string">&#x27;joe&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wifey[<span class="number">0</span>] = <span class="string">&#x27;jane&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hubby, wifey</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>([<span class="string">&#x27;joe&#x27;</span>,[<span class="string">&#x27;savings&#x27;</span>,<span class="number">100.0</span>],<span class="string">&#x27;jane&#x27;</span>,[<span class="string">&#x27;savings&#x27;</span>,<span class="number">100.0</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hubby[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">50.00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hubby, wifey</span><br><span class="line">([<span class="string">&#x27;joe&#x27;</span>,[<span class="string">&#x27;savings&#x27;</span>,<span class="number">50.0</span>]],[<span class="string">&#x27;jane&#x27;</span>,[<span class="string">&#x27;savings&#x27;</span>,<span class="number">100.0</span>]])</span><br></pre></td></tr></table></figure>
<p>这就是我们想要的方式，作为验证，让我们确认一下所有四个对象都是不同的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> hubby]</span><br><span class="line">[<span class="number">12191712</span>, <span class="number">11826280</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> wifey]</span><br><span class="line">[<span class="number">12114080</span>, <span class="number">12224792</span>]</span><br></pre></td></tr></table></figure>
<p>以下有几点关于拷贝操作的警告。第一，非容器类型（比如数字，字符串和其他“原子”类型的对象，像代码，类型和xrange对象等）没有被拷贝一说，浅拷贝是用完全切片操作来完成的。第二，发果元组变量只包含原子类型对象，对它的深拷贝将不会进行。如果我们把账户信息改成元组类型，那么即便按我们的要求使用深拷贝操作也只能得到一个浅拷贝：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = [<span class="string">&#x27;name&#x27;</span>, (<span class="string">&#x27;savings&#x27;</span>, <span class="number">100.00</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newPerson = copy.deepcopy(person)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> person, newPerson]</span><br><span class="line">[<span class="number">12225352</span>, <span class="number">125226112</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> person]</span><br><span class="line">[<span class="number">9919616</span>， <span class="number">11800088</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> newPerson]</span><br><span class="line">[<span class="number">9919616</span>， <span class="number">11800088</span>]</span><br></pre></td></tr></table></figure>
<p><span style="font-weight: bold;">核心模块：copy</span></p>
<p><span style="font-weight: bold;">我们则才描述的浅拷贝和深拷贝操作都可以在copy模块中找到。其实copy模块中只有两个函数可用：copy()进行浅拷贝操作，而deepcopy()进行深拷贝操作。</span></p>
<h2 id="序列类型小结"><a href="#序列类型小结" class="headerlink" title="序列类型小结"></a>序列类型小结</h2><p>序列类型为数据的顺序存储提供了几种机制。字符串是常用的数据载体，无论是用于给用户显示，存贮到硬盘，通过网络传输，还是作为一个多源信息的容器。列表和元组提供了容器存储能力，允许简单的操作和访问多个对象，无论它们是Python的对象还是用户自定义的对象。单一元素或一组元素可以通过持续有序地索引偏移进行切片操作来访问。总之，这些数据类型为你的Python开发环境提供了灵活而易用的存贮工具。我们下表–序列类型的操作符，内建函数和方法的摘要列表来总结本章。</p>
<table>
<thead>
<tr>
<th>函数或方法</th>
<th align="center">字符串</th>
<th align="center">列表</th>
<th align="center">元组</th>
</tr>
</thead>
<tbody><tr>
<td>append()</td>
<td align="center"></td>
<td align="center">■</td>
<td align="center"></td>
</tr>
<tr>
<td>capitalize()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>center()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>chr()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>cmp()</td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center">■</td>
</tr>
<tr>
<td>count()</td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center"></td>
</tr>
<tr>
<td>decode()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>encode()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>endswith()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>expandtabs()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>extend()</td>
<td align="center"></td>
<td align="center">■</td>
<td align="center"></td>
</tr>
<tr>
<td>find()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>hex()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>index()</td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center"></td>
</tr>
<tr>
<td>insert()</td>
<td align="center"></td>
<td align="center">■</td>
<td align="center"></td>
</tr>
<tr>
<td>isdecimal()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>isdigit()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>islower()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>isnumeric()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>isspace()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>istitle()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>isupper()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>join()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>len()</td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center">■</td>
</tr>
<tr>
<td>list()</td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center">■</td>
</tr>
<tr>
<td>ljust()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>lower()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>lstrip()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>max()</td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center">■</td>
</tr>
<tr>
<td>min()</td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center">■</td>
</tr>
<tr>
<td>oct()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>ord()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>upper()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>zfill()</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>.(attributes)</td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center"></td>
</tr>
<tr>
<td><code>[](slice)</code></td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center">■</td>
</tr>
<tr>
<td><code>[:]</code></td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center">■</td>
</tr>
<tr>
<td>*</td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center">■</td>
</tr>
<tr>
<td>%</td>
<td align="center">■</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>+</td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center">■</td>
</tr>
<tr>
<td>in</td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center">■</td>
</tr>
<tr>
<td>not in</td>
<td align="center">■</td>
<td align="center">■</td>
<td align="center">■</td>
</tr>
</tbody></table>
<h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><p><br><span style="font-weight: bolder;">6-1. 字符串。string模块中是否有一种字符串方法或者函数可以帮我鉴定下一个字符串是否是另一个大字符串的一部分？</span><br>答：可以使有in操作符、find()、rfind()、index()、rindex()</p>
<p><br><span style="font-weight: bolder;">6-2. 字符串标识符。修改例6-1的idcheck.py脚本，使之可以检测长度为一的标识符，并且可以识别Python关键字。对后一个要求，你可以使用keyword模块（特别是keyword.kelist）来辅助。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line">alphas = string.letters + <span class="string">&#x27;_&#x27;</span></span><br><span class="line">nums = string.digits</span><br><span class="line">keys = keyword.kwlist</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Welcome to the Identifier Checker V1.0&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Testees must be at least 1-2 chars long.&#x27;</span></span><br><span class="line">myInput = raw_input(<span class="string">&#x27;Identifier to test?&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> myInput <span class="keyword">in</span> keys:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;invalid: Input symbol is not keyword!&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(myInput) == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;okay as an identifier&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(myInput) &gt; <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">if</span> myInput[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> alphas:</span><br><span class="line">          <span class="built_in">print</span> <span class="string">&#x27;&#x27;&#x27;invalid: first symbol must be alphabetic&#x27;&#x27;&#x27;</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">for</span> otherChar <span class="keyword">in</span> myInput[<span class="number">1</span>:]:</span><br><span class="line">              <span class="keyword">if</span> otherChar <span class="keyword">not</span> <span class="keyword">in</span> alphas + nums:</span><br><span class="line">                  <span class="built_in">print</span> <span class="string">&#x27;&#x27;&#x27;invalid: remaining</span></span><br><span class="line"><span class="string">                     symbols must be alphanumeric&#x27;&#x27;&#x27;</span></span><br><span class="line">                  <span class="keyword">break</span></span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">                  <span class="built_in">print</span> <span class="string">&quot;okay as an identifier&quot;</span></span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">6-3. 排序。<br>(a) 输入一串数字、并从大到小排列之<br>(b) 跟a一样。不过要用字典序从大到小排列。<br></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    m = <span class="built_in">input</span>(<span class="string">&#x27;请输入一串数字：&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>  <span class="built_in">isinstance</span>(m,<span class="built_in">str</span>) == <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请输入一个数字字符串！&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数字从大到小进行排列......&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(m,reverse=<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数字按索引值从大到小方式进行排列.......&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="built_in">list</span>(m))))</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">6-4. 算术。更新上一章里面你得分测试练习方案，把测试得分放到一个列表中去。你的代码应该可以计算出一个平均分，见练习2-9和练习5-3</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">s = [<span class="number">98</span>, <span class="number">95</span>, <span class="number">86</span>, <span class="number">99</span>, <span class="number">89</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkCj</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">if</span> x &gt;= <span class="number">90</span> <span class="keyword">and</span> x &lt;= <span class="number">100</span> :</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> x &gt;= <span class="number">80</span> <span class="keyword">and</span> x &lt;= <span class="number">89</span> :</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> x &gt;= <span class="number">70</span> <span class="keyword">and</span> x &lt;=<span class="number">79</span> :</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> x &gt;= <span class="number">60</span> <span class="keyword">and</span> x &lt;= <span class="number">69</span> :</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> x &lt; <span class="number">60</span> :</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line">nums = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;第%d次测验成绩为：%d，评分成绩为%s&quot;</span> % (j,i,checkCj(i)))</span><br><span class="line">  nums += <span class="built_in">float</span>(i)</span><br><span class="line">  j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;总成绩平均分为：%f&quot;</span> % (nums/<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">6-5. 字符串。<br>(a) 更新你在练习2-7里面的方案，使之可以每次向前向后都显示一个字符串的一个字符。<br>(b) 通过扫描来判断两个字符串是否匹配（不能使用比较操作符或者cmp()内建函数）。附加题：在你的方案里加入大小写区分<br>(c) 判断一个字符串是否重现（后面跟前面的一致）。附加题：在处理除了严格的回文之外，加入对例如控制符号和空格的支持。<br>(d) 接受一个字符，在其后面加一个反向的拷贝，构成一个回文字符串。<br></span><br>(a)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  m = <span class="built_in">input</span>(<span class="string">&#x27;请输入串字符串：&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">isinstance</span>(m,<span class="built_in">str</span>) == <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;请输入数据类型为字符串的数据！&#x27;</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(m)):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;左边第%d个字符是%s，右边第%d个字符是%s&#x27;</span> % (i,m[i],i,m[::-<span class="number">1</span>][i])) </span><br></pre></td></tr></table></figure>
<p><br>(b)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line">str1 = <span class="built_in">input</span>(<span class="string">&quot;请输入第一个字符：&quot;</span>)</span><br><span class="line">str2 = <span class="built_in">input</span>(<span class="string">&quot;请输入第二个字符：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">ord</span>(str1) == <span class="built_in">ord</span>(str2) :</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;这两个字符相等！&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;这两个字符不相等！&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><br>(c)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  m = <span class="built_in">input</span>(<span class="string">&quot;请输入字符串：&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">isinstance</span>(m,<span class="built_in">str</span>) == <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入字符串.......&quot;</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">denny = [<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">32</span>)] + <span class="built_in">list</span>(string.whitespace) </span><br><span class="line">denny.append(<span class="built_in">chr</span>(<span class="number">127</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="built_in">len</span>(m)-<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> m[i] <span class="keyword">in</span> denny: </span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> cmp(m[i-<span class="number">1</span>],m[i+<span class="number">1</span>]) == <span class="number">0</span> :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;字符%s重现（后面跟前面一致）&quot;</span> % (m[i]))</span><br></pre></td></tr></table></figure>
<p><br>(d)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入一个字符串：&quot;</span>)</span><br><span class="line">ll = <span class="built_in">list</span>(<span class="built_in">str</span>) + <span class="built_in">sorted</span>(<span class="built_in">str</span>,reverse=<span class="literal">True</span>)</span><br><span class="line">b = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ll:</span><br><span class="line">  b += i</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">6-6. 字符串。创建一个string.strip()的替代函数：接受一个字符串，去掉它前面和后面的空格（如果使用string.strip()函数那本练习就没有意义了）</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tripSpace</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">str</span>[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leftSpace</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">str</span>[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rightSpace</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">str</span>[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">input</span>(<span class="string">&quot;请输入字符串：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> m[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> m[<span class="built_in">len</span>(m)-<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span>(tripSpace(m))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> m[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> m[<span class="built_in">len</span>(m)-<span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span>(leftSpace(m))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> m[<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> m[<span class="built_in">len</span>(m)-<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span>(rightSpace(m))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> m[<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> m[<span class="built_in">len</span>(m)-<span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span>(m)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">6-7. 调试。看一下在例6.5中给出的代码（buggy.py）<br>(a) 研究这段代码并描述这段代码想做什么。在所有的（#）处都要填写你的注释。<br>(b) 这个程序有一个很大的问题，比如输入6、12、20、30、等它会死掉。实际上它不能处理任何的偶数，找出原因。<br>(c) 修正(b)中提出的问题。<br></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#接收一个输入字符</span></span><br><span class="line">num_str = raw_input(<span class="string">&#x27;Enter a number: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将输入字符转化为整型数值</span></span><br><span class="line">num_num = <span class="built_in">int</span>(num_str)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取到区间为1～num_num+1的列表</span></span><br><span class="line">fac_list = <span class="built_in">range</span>(<span class="number">1</span>, num_num+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;BEFORE:&quot;</span>, fac_list</span><br><span class="line"></span><br><span class="line"><span class="comment">#赋值i为0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#循环列表个数</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(fac_list):</span><br><span class="line">    <span class="comment">#删除能被整除的列表值</span></span><br><span class="line">    <span class="keyword">if</span> num_num % fac_list[i] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">del</span> fac_list[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环次数加1</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;AFTER：&quot;</span>,fac_list</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">6-8. 列表。给出一个整型值，返回代表该值的英文，比如输入89返回“eight-nine”。附加题：能够返回符合英文语法规则的形式，比如输入“89”返回“eighty-nine”。本练习中的值限定在0～1000</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;#coding=utf-8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">while True:</span></span><br><span class="line"><span class="string">  m = input(&quot;Enter 0~1000 number: &quot;)</span></span><br><span class="line"><span class="string">  if isinstance(m,int) != True:</span></span><br><span class="line"><span class="string">    print &quot;请输入整型数值!&quot;</span></span><br><span class="line"><span class="string">    continue</span></span><br><span class="line"><span class="string">  else:</span></span><br><span class="line"><span class="string">    if m &lt; 0 or  m &gt;  1000 :</span></span><br><span class="line"><span class="string">       print &quot;请输入1000以内整数!&quot;</span></span><br><span class="line"><span class="string">       continue</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">       break</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def refDx(x):</span></span><br><span class="line"><span class="string">  if x == 0 :</span></span><br><span class="line"><span class="string">    return &#x27;</span>零<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  if x == 1 :</span></span><br><span class="line"><span class="string">    return &#x27;</span>壹<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  if x == 2 :</span></span><br><span class="line"><span class="string">    return &#x27;</span>贰<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  if x == 3 :</span></span><br><span class="line"><span class="string">    return &#x27;</span>叁<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  if x == 4 :</span></span><br><span class="line"><span class="string">    return &#x27;</span>肆<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  if x == 5 :</span></span><br><span class="line"><span class="string">    return &#x27;</span>伍<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  if x == 6 :</span></span><br><span class="line"><span class="string">    return &#x27;</span>陆<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  if x == 7 :</span></span><br><span class="line"><span class="string">    return &#x27;</span>柒<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  if x == 8 :</span></span><br><span class="line"><span class="string">    return &#x27;</span>捌<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  if x == 9 :</span></span><br><span class="line"><span class="string">    return &#x27;</span>玖<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if len(str(m)) == 1 :</span></span><br><span class="line"><span class="string">  print(refDx(m)+&#x27;</span>元<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if len(str(m)) == 2 :</span></span><br><span class="line"><span class="string">  aa = str(m) </span></span><br><span class="line"><span class="string">  print(refDx(int(aa[0]))+&#x27;</span>拾<span class="string">&#x27;+refDx(int(aa[1]))+&#x27;</span>元<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if len(str(m)) == 3 :</span></span><br><span class="line"><span class="string">  aa = str(m) </span></span><br><span class="line"><span class="string">  print(refDx(int(aa[0]))+&#x27;</span>佰<span class="string">&#x27;+refDx(int(aa[1]))+&#x27;</span>拾<span class="string">&#x27; + refDx(int(aa[2])) + &#x27;</span>元<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if m  == 1000 :</span></span><br><span class="line"><span class="string">  print(&#x27;</span>壹仟元<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">6-9. 转换。为练习5-13写一个姊妹函数，接受分钟数，返回小时数和分钟数。总时间不变，并且要求小时数尽可能大。</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">minutes = <span class="built_in">int</span>(raw_input(<span class="string">&#x27;Please input the minutes: ...&#x27;</span>))</span><br><span class="line">hours = minutes / <span class="number">60</span></span><br><span class="line">mins = minutes - hours * <span class="number">60</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;%i:%i&quot;</span> % (hours, mins)</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">6-10. 字符串。写一个函数，返回一个跟输入字符串相似的字符串，要求字符串的大小写反转。比如，输入“Mr.Ed”，应该返回”mR.eD” 作为输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">lowers = string.ascii_lowercase</span><br><span class="line">uppers = string.ascii_uppercase</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">s</span>):</span><br><span class="line">  str1 = []</span><br><span class="line">  ss = <span class="built_in">reversed</span>(s)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> ss :</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> lowers :</span><br><span class="line">      str1.append(i.upper())</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> uppers :</span><br><span class="line">      str1.append(i.lower())</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> lowers + uppers :</span><br><span class="line">      str1.append(i)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(str1)</span><br><span class="line">m = <span class="built_in">input</span>(<span class="string">&quot;请输入字符串：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(reverseStr(m))</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">6-11. 转换。<br>(a) 创建一个从整型到IP地址转换的程序，如下格式：WWW.XXX.YYY.ZZZ<br>(b) 更新你的程序，使之可以逆转换<br></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&#x27;--------------(a)--------------&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_ip</span>():</span><br><span class="line">    num = raw_input(<span class="string">&#x27;Enter ip number(12 integer)&#x27;</span>)</span><br><span class="line">    w = num[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    x = num[<span class="number">3</span>:<span class="number">6</span>]</span><br><span class="line">    y = num[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">    z = num[<span class="number">9</span>:<span class="number">12</span>]</span><br><span class="line">    tmp = [w,x,y,z]</span><br><span class="line">    ip = <span class="string">&#x27;.&#x27;</span>.join(tmp)</span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> format_ip()</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;------------------(b)----------------&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ip_format</span>():</span><br><span class="line">    ip=raw_input(<span class="string">&quot;enter ip:&quot;</span>)</span><br><span class="line">    num=ip.replace(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    num=<span class="built_in">int</span>(num)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> ip_format()</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">6-12. 字符串。<br>(a) 创建一个名字为findchr()函数，函数声明如下。<br>def findchr(string, char) <br>findchr()要在字符串string中查找字符char，找到就返回该值的索引，否则返回-1。不能用string.*find()或者string.*index()函数和方法。<br>(b) 创建另一个叫rfindchr()的函数，查找字符char最后一次出现的位置。它跟findchr()工作类似，不过它是从字符串的最后开始向前查找的。<br>(c) 创建第三个函数，名字叫subchr()，声明如下。<br>def subchr(string, origchar, newchar)<br>subchr()跟findchr()类似，不同的是，如果找到匹配的字符就用新的字符替换原先字符。返回修改后的字符串。<br></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findchr</span>(<span class="params">string,char</span>):</span><br><span class="line">  j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> string: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">    <span class="keyword">if</span> char == i :</span><br><span class="line">      <span class="keyword">return</span> j</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rfindchr</span>(<span class="params">string,char</span>):</span><br><span class="line">  j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> string:<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> string[::-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">if</span> char == i : <span class="keyword">return</span> j </span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subchr</span>(<span class="params">string, origchar, newchar</span>):</span><br><span class="line">  j = findchr(string, origchar)</span><br><span class="line">  <span class="keyword">if</span> j != -<span class="number">1</span> :</span><br><span class="line">    newstring = <span class="built_in">list</span>(string) </span><br><span class="line">    newstring[j] = newchar</span><br><span class="line">    <span class="keyword">return</span> string, origchar,newchar,j,<span class="string">&#x27;&#x27;</span>.join(newstring)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> string,origchar,newchar,-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">string = <span class="built_in">input</span>(<span class="string">&quot;请输入一个字符串：&quot;</span>)</span><br><span class="line">char = <span class="built_in">input</span>(<span class="string">&quot;请输入需要查找的字符：&quot;</span>)</span><br><span class="line">newchar = <span class="built_in">input</span>(<span class="string">&quot;请输入替换的字符：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;在字符串%s中查找%s字符，返回索引值：%d&quot;</span> % (string,char,findchr(string,char)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;在字符串%s中查找%s字符，最后一次出现的索引是%d&quot;</span> % (string,char,rfindchr(string,char)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;在字符串%s中查找%s字符，并替换为%s，它的索引值为：%d，替换后的字符串为%s&quot;</span> % (subchr(string,char,newchar)))</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">6-13. 字符串.string模块包含三个函数atoi()、atol()和atof()，它们分别负责把字符串转换成整型、长整型及浮点型数字。从Python1.5起，Python的内建函数int()、long()、float()也可以做相同的事了，complex()函数可以把字长会串转换成复数（然而1.5之前，这些转换函数只能工作于数字之上）。<br>string模块中并没有实现一个atoc()函数，那么你来实现一个atoc()，接受单个字符串做参数输入，一个表示复数的字符串，例如<code>-1.23e+4-5.67j</code>，返回相应的复数对象。你不能用eval()函数，便可以使用complex()函数，而且你只能在如下的限制之下使用：complex():complex(real,imag)的real和imag都必须是浮点值。</span></p>
<p><br><span style="font-weight: bolder;">6-14. 随机数。设计一个“石头、剪子、布”游戏，有时又叫“Rochambeau”，你小时候可能玩过，下面的规则。你和你的对手，在同一时间做出特定的手势，必须是下面一种：石头、剪子、布。胜利者从下面的规则中产生，这个规则本身是个悖论。<br>(a) 布包石头<br>(b) 石头砸剪子<br>(c) 剪子剪破布。在你的计算机版本中，用户输入她&#x2F;他的选项，计算机找一个随机选项，然后由你的程序来决定一个胜利者或者平手。注意：最好的算法是尽量少的使用if语句。<br></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">#石头= a，剪子=b，布=c</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rp</span>(<span class="params">str1</span>):</span><br><span class="line">  <span class="keyword">if</span> str1 == <span class="string">&#x27;a&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;石头&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> str1 == <span class="string">&#x27;b&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;剪子&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> str1 == <span class="string">&#x27;c&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;布&#x27;</span></span><br><span class="line">x = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;退出请按Ctrl + C......&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  m = <span class="built_in">input</span>(<span class="string">&quot;请出拳石头(a),剪子(b),布(c)：&quot;</span>)</span><br><span class="line">  d = random.choice(x)</span><br><span class="line">  <span class="keyword">if</span> d == m : <span class="built_in">print</span>(<span class="string">&#x27;你出的是%s，电脑出的是%s,你们打成平手啦！&#x27;</span> % (rp(m),rp(d)))</span><br><span class="line">  <span class="keyword">if</span> d == <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> m == <span class="string">&#x27;b&#x27;</span>  : <span class="built_in">print</span>(<span class="string">&#x27;你出的是%s，电脑出的是%s,电脑胜出！&#x27;</span> % (rp(m),rp(d)))</span><br><span class="line">  <span class="keyword">if</span> d == <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> m == <span class="string">&#x27;c&#x27;</span>  : <span class="built_in">print</span>(<span class="string">&#x27;你出的是%s，电脑出的是%s,你赢啦！&#x27;</span> % (rp(m),rp(d)))</span><br><span class="line">  <span class="keyword">if</span> d == <span class="string">&#x27;b&#x27;</span> <span class="keyword">and</span> m == <span class="string">&#x27;a&#x27;</span>  : <span class="built_in">print</span>(<span class="string">&#x27;你出的是%s，电脑出的是%s,你赢啦！&#x27;</span> % (rp(m),rp(d)))</span><br><span class="line">  <span class="keyword">if</span> d == <span class="string">&#x27;b&#x27;</span> <span class="keyword">and</span> m == <span class="string">&#x27;c&#x27;</span>  : <span class="built_in">print</span>(<span class="string">&#x27;你出的是%s，电脑出的是%s,电脑胜出！&#x27;</span> % (rp(m),rp(d)))</span><br><span class="line">  <span class="keyword">if</span> d == <span class="string">&#x27;c&#x27;</span> <span class="keyword">and</span> m == <span class="string">&#x27;a&#x27;</span>  : <span class="built_in">print</span>(<span class="string">&#x27;你出的是%s，电脑出的是%s,电脑胜出！&#x27;</span> % (rp(m),rp(d)))</span><br><span class="line">  <span class="keyword">if</span> d == <span class="string">&#x27;c&#x27;</span> <span class="keyword">and</span> m == <span class="string">&#x27;b&#x27;</span>  : <span class="built_in">print</span>(<span class="string">&#x27;你出的是%s，电脑出的是%s,你赢啦！&#x27;</span> % (rp(m),rp(d)))</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">6-15. 转换。<br>(a) 给出两个可识别格式的日期，比如MM&#x2F;DD&#x2F;YY或者DD&#x2F;MM&#x2F;YY格式，计算出两个日期间的天数。<br>(b) 给出一个人的生日，计算从此人出生到现在的天数，包括所有的闰月。<br>(c) 下是上面的例子，计算出到此人下次过生日还有多少天<br></span></p>
<p><br><span style="font-weight: bolder;">6-16. 矩阵。处理矩阵M和N的加和乘操作。 </span></p>
<p><br><span style="font-weight: bolder;">6-17. 方法。实现一个叫myPop()函数，功能类似了列表的pop()方法，用一个列表作为输入，移除列表的最新一个元素，并返回它。</span>          </p>
<p><br><span style="font-weight: bolder;">6-18. zip()内建函数。在6.13.2节里面关于zip()函数的例子中，zip(fn,ln)返回的是什么？</span></p>
<p><br><span style="font-weight: bolder;">6-19. 多列输出。有任意项的序列或者其他容器，把它们等距离分列显示。由调用都提供数据和输出格式。例如，如何你传入100个项并定义3列输出，按照需要的模式显示这些数据。这种情况下，应该是两列显示33项，最后一列显示34个。你可以让用户来选择水平排序或者垂直排序。</span></p>
<h1 id="映身和集合类型"><a href="#映身和集合类型" class="headerlink" title="映身和集合类型"></a>映身和集合类型</h1><ul>
<li>映射类型：字典</li>
<li>操作符</li>
<li>内建函数</li>
<li>内建方法</li>
<li>字典的键</li>
<li>集合类型</li>
<li>操作符</li>
<li>内建函数</li>
<li>内建方法</li>
<li>相关模块</li>
</ul>
<p>本章我们来讨论Python语言中的映像类型和集合类型。和前面的章节一样，我们首先做一个介绍，再来讨论可用操作符，工厂函数、内建函数（BIF）和方法，然后再来看看每种数据类型的详细用法。</p>
<h2 id="映射类型：字典"><a href="#映射类型：字典" class="headerlink" title="映射类型：字典"></a>映射类型：字典</h2><p>字典是Python语言中唯一的映射类型。映射类型对象里哈希值（键，key）和指向的对象（值 value）是一对多的关系。它们与Perl中的哈希类型（译者注：又称关联数组）相似，通常被认为是可变的哈希表。一个字典对象是可变的，它是一个容器类型，能存储任意个数的Python对象，其中也包括其他容器类型。字典类型和序列类型容器类（列表、元组）的区别是存储和访问数据的方式不同。序列类型只用数字类型的键（从序列的开始起按数值顺序索引）。映射类型可以用其他对象类型做健，一般最常见的是用字符串做键。和序列类型的键不同，映像类型的键直接或间接地和存储的数据值相关联。但因为在映射类型中，我们不再用“序列化排序”的键，所以映像类型中的数据是无序排列的。</p>
<p>显然，这并不影响我们命名用映射类型，因为映射类型不要求用数字值做索引以从一个容器中获取对庆的数居项。你可以用键直接“映射”到值，这就是为什么叫映射类型（“mapping type”）的原因。映射类型通常被称做哈希表，是因为字典对象就是哈希类型。字典是Python中最强大的数据类型之一。</p>
<div class="note primary"><p><span style="font-weight: bolder;">核心笔记：什么是哈希表？它们与字典的关系是什么？</span><hr/><br>序列类型用有序的数字键做索引将数据以数组的形式存储。一般索引值与所存储的数据毫无关系。还可以用另一种方式来存储数据：基于某种相关值，比如说一个字符串。我们在日常生活中一直这么做。把人们的电话号码按照他们的姓记录在电话簿上，按照时间在日历或约会簿上添加事件，等等。在这些例子中，你的键就是和数据项相关的值。哈希表是一种数据结构：它按照我们所要求的去工作。哈希表中存储的每一条数据，叫做一个值（value），是根据与它相关的一个被称作为键（key）的数据项进行存储。键和值合在一起被称为“键-值对“。哈希表的算法是获取键，对键执行一个叫做哈希函数的操作，并根据计算的结果，选对在数据结构的某个地址中来存储你的值。任何一个值存储的地址皆取决于它的健。正因为这种随意性，哈希表中的值是没有顺序的。你拥有的是一个无序的数据集。</p>
<p>你所能获得的有序集合只能是字典中的键的集合或者值的集合。方法keys()或values()返回一个列表，该列表是可排序的。你还可以用items()方法得到包含键、值对的元组的列表来排序。由于字典本身是哈希的，所以是无序的。<br>哈希表一般有很好的性能，因为用键查询相关快。</p>
</div>

<p>Python的字典是作为可变的哈希表实现的。如果你熟悉Perl的话，就可以发现字典与Perl中的“关系数组”或散列相似。</p>
<p>现在我们就研究Python字典。一个字典条目的语法格式是键值。而且，多条字典条目被包含在大括号（{}）里。</p>
<h3 id="如何创建字典和给字典赋值"><a href="#如何创建字典和给字典赋值" class="headerlink" title="如何创建字典和给字典赋值"></a>如何创建字典和给字典赋值</h3><p>创建字典只需要把字典赋值给一个变量，不管这个字典是否包含元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1 = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2 = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;earth&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">80</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1, dict2</span><br><span class="line">(&#123;&#125;,&#123;<span class="string">&#x27;port&#x27;</span>:<span class="number">80</span>, <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;earth&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>从Python2.2版本起，可以用工厂方法dict()来创建字典。当我们详细讨论dict()的时候会看到更多的例子，现在来看一下小例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fdict = <span class="built_in">dict</span>(([<span class="string">&#x27;x&#x27;</span>, <span class="number">1</span>],[<span class="string">&#x27;y&#x27;</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fdict</span><br><span class="line">[<span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>从Python2.3版本起，可以用一个很方便的内建方法fromkeys()来创建一个“默认”字典，字典中元素具有相同的值（如果没有给出，默认为None）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ddict = &#123;&#125;.formkeys((<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>), -<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ddict</span><br><span class="line">&#123;<span class="string">&#x27;y&#x27;</span>:-<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>:-<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>edict = &#123;&#125;.fromkeys((<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>edict</span><br><span class="line">&#123;<span class="string">&#x27;foo&#x27;</span>:<span class="literal">None</span>, <span class="string">&#x27;bar&#x27;</span>:<span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何访问字典中的值"><a href="#如何访问字典中的值" class="headerlink" title="如何访问字典中的值"></a>如何访问字典中的值</h3><p>要想遍历一个字典（一般用键），你只需要循环查看它的键，像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2 = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;earth&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">80</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> dict2.keys():</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span> <span class="string">&#x27;key=%s, value=%s&#x27;</span> % (key, dict2[key]) </span><br><span class="line">...</span><br><span class="line">key=name, value=earth</span><br><span class="line">key=port, value=<span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>从Python2.2开始，你可以不必再用keys()方法获取供循环使用的键值列表了。可以用迭代器来轻松访问类序列对象（sequence-like objects），比如字典和文件。只需要用字典的名字就可以在for循环里遍历字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2 = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;earth&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">80</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> dict2:</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span> <span class="string">&#x27;key=%s, value=%s&#x27;</span> % (key,dict2[key])</span><br><span class="line">...</span><br><span class="line">key=name, value=earth</span><br><span class="line">key=port, value=<span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>要得到字典中某个元素的值，可以用你所熟悉的字典键加上括号来得到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;earth&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;host %s is running on port %d &#x27;</span> %  (dict2[<span class="string">&#x27;name&#x27;</span>],dict2[<span class="string">&#x27;port&#x27;</span>])</span><br><span class="line">host earth <span class="keyword">is</span> runing on port <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>字典dict1是空的，字典dict2有两个数据元素。字典dict2的键是’name’和’port’，它们对应的值为别是’earth’和80。就像你看到的，通过’name’可以得到字典中的元素的值。</p>
<p>如果我们想访问该字典中的一个数据元素，而它在字个字典中没有对应的键，将会产生一个错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2[<span class="string">&#x27;server&#x27;</span>]</span><br><span class="line">Traceback (innermost last):</span><br><span class="line">  File<span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span> , <span class="keyword">in</span>?</span><br><span class="line">KeyError:server</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们试图获得字典中’server’健所对应的值。你从上面的代码知道，’server’这个键并不存在。检查一个字典中是否有某个键的最好方法是用字典的has_key()方法，或者另一种比较好的方法就是从2.2版本起用的，in或not in操作符。has_key()方法将会在未来的Python版本中弃用，所以用in或not in是最好的方法。</p>
<p>下面我们将介绍字典所有的方法。方法has_key()和in以及not in操作符都是布尔类型的。对于前两都而言，如果字典中有该健就返回真（True），否则返回假（False）（Python2.3版本以前，没有布尔常量，为真时近回1， 假时近回0）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;server&#x27;</span> <span class="keyword">in</span> dict2  <span class="comment"># or dict2.has_key(&#x27;server&#x27;)</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> <span class="built_in">dict</span>  <span class="comment"># or dict2.has_key(&#x27;name&#x27;)</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;earth&#x27;</span></span><br></pre></td></tr></table></figure>
<p>一个字典中混用数字和字符串的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3 = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3[<span class="number">1</span>] = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3[<span class="string">&#x27;1&#x27;</span>] = <span class="number">3.14159</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3[<span class="number">3.2</span>] = <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3</span><br><span class="line">&#123;<span class="number">3.2</span>: <span class="string">&#x27;xyz&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">3.14159</span>&#125;</span><br></pre></td></tr></table></figure>
<p>除了逐一地添加每个键-值对外，我们也可以给dict3整体赋值。<br><code>dict3 = &#123;3.2: &#39;xyz&#39;, 1: &#39;abc&#39;, &#39;1&#39;: 3.14159&#125;</code></p>
<p>如果事先已经知道所有的数据就可以用键-值对来创建一个字典（这是显而易见的）。通过字典dict3的示例说明你可以采用各种类型的数据作为字典的键。如果我们被问到是否可以改变某个字典值的键时，你可能会说“对”，对吗？</p>
<p>为什么在执行中字典中的键不允许被改变呢？你这样想就会明白：比方说，你创建了一个字典，字典中包含一个元素（一个键和一个值）。可能是由于某个变量的改变导致键发生了改变。这时候你如果用原来的键来取出字典里的数据，会得到KeyError（因为键的值已经改变了），现在你没办法从字典中获取该值了，因为键本身的值发生了变化。由于上面的原因，字典中的键必须是可哈希的，所以数字和字符串可以作为字典的键，但是列表和其他字典不行（见7.5.2小节字典的键必须是可哈希的）。</p>
<h3 id="如何更新字典"><a href="#如何更新字典" class="headerlink" title="如何更新字典"></a>如何更新字典</h3><p>你可以通过以下几种方式对一个字典做修改：添加一个新数据项或新元素（即，一个键-值对）；修改一个已存在的数据项；或删除一个已存在的数据项（下面有关于数据项删除操作的详细讲述）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;venus&#x27;</span>  <span class="comment"># 更新已有条目</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2[<span class="string">&#x27;port&#x27;</span>] = <span class="number">6969</span>  <span class="comment"># 更新已有条目</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2[<span class="string">&#x27;arch&#x27;</span>] = <span class="string">&#x27;sunos5&#x27;</span> <span class="comment"># 增加新条目</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;host %(name)s is runing on port %(port)d&#x27;</span> %dict2</span><br><span class="line">host venus <span class="keyword">is</span> running on port <span class="number">6969</span></span><br></pre></td></tr></table></figure>
<p>如果字典中该键已经存在，则字典中该键对应的值将被新值替代。上面的print语句展示了另一种在了典中使用字符串格式符（%）的方法。用字典参数可简化print语句，因为这样做你只需要用到一次该字典的名字，而不用在每个元素出现的时候都用元组参数表示。你也可以用内建方法update()将整个字典的内容添加到另一个字典。我们将在7.4节介绍此方法。</p>
<h3 id="如何删除字典元素和字典"><a href="#如何删除字典元素和字典" class="headerlink" title="如何删除字典元素和字典"></a>如何删除字典元素和字典</h3><p>删除整个字典的操作不常见。通常，你删除字典中的单个元素或是清除整个字典的内容。但是，如果你真想“删除”一个字典，用del语句。以下是删除字典和字典元素的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> dict2[<span class="string">&#x27;name&#x27;</span>]    <span class="comment"># 删除键为“name”的条目</span></span><br><span class="line">dict2.clear()    <span class="comment"># 删除dict1中所有的条目</span></span><br><span class="line"><span class="keyword">del</span> dict2    <span class="comment"># 删除整个dict字典</span></span><br><span class="line">dict2.pop(<span class="string">&#x27;name&#x27;</span>)    <span class="comment">#删除并返回键为“w”的条目</span></span><br></pre></td></tr></table></figure>

<div class="note primary"><p><span style="font-weight: bolder;"></span><br>如倮在Python2.3前，你已经开始使用Python，你可能用dict作为一个字典的标识符。但是，因为dict()现在已经成为Python的类型和工厂方法，重载dict()会给你带来麻烦和潜在的bugs。编译器允许你做这样的重载，它认为你是聪明的，知道自己正在做什么！小心。请不要用dict、list、file、bool、str、input、len这样的内建类型为变量命名。</p>
</div>

<h2 id="映射类型操作符"><a href="#映射类型操作符" class="headerlink" title="映射类型操作符"></a>映射类型操作符</h2><p>字典可以和所有的标准类型操作符一起工作，但却不支持像拼接（concatenation）和重复（repetition）这样的操作。这些操作对序列有意义，可对映射类型行不通。在接下来的两小节里，我们将向你讲述字典中的操作符。</p>
<h3 id="标准类型操作符-5"><a href="#标准类型操作符-5" class="headerlink" title="标准类型操作符"></a>标准类型操作符</h3><p>标准类型操作符已在第4章介绍。下面是一些使用操作符的简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict4 = &#123;<span class="string">&#x27;abc&#x27;</span>: <span class="number">123</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict5 = &#123;<span class="string">&#x27;abc&#x27;</span>: <span class="number">456</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict6 = &#123;<span class="string">&#x27;abc&#x27;</span>: <span class="number">123</span>, <span class="number">98.6</span>: <span class="number">37</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict7 = &#123;<span class="string">&#x27;xyz&#x27;</span>: <span class="number">123</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict4 &lt; dict5</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(dict4 &lt; dict6) <span class="keyword">and</span> (dict4 &lt; dict7)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(dict5 &lt; dict6) <span class="keyword">and</span> (dict5 &lt; dict7)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict6 &lt; dict7</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>字典是如何比较的呢？与列表和元组一样，这个过程比数字和字符串的比较更复杂些。详细算法请见第7.3.1小节。</p>
<h3 id="映射类型操作符-1"><a href="#映射类型操作符-1" class="headerlink" title="映射类型操作符"></a>映射类型操作符</h3><p><span style="font-weight: bolder;">1. 字典的键查找操作符（[]）</span></p>
<p>键查找操作符是唯一仅用于字典类型的操作符，它和序列类型里单一元素的切片（slice）操作符很相象。对序列类型来说，用索引做唯一参数或下标（subscript）以获取一个序列中某个元素的值。对字典类型来说，是用键查询（字典中的元素），所以键是参数（argument），而不是一个索引（index）。键查找操作符既可以用于给字典赋值，也可以用于从字典中取值：</p>
<p>d[k]v    通过键’k’，给字典中某元素赋值’v’<br>d[k]     通过键’k’, 查询字典中某元素的值</p>
<p><span style="font-weight: bolder;">2. （键）成员关系操作（in、not in）</span></p>
<p>从Python2.2起，程序员可以不用has_key()方法，而用in和not in操作符来检查某个键是否存在字典中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> dict2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;phone&#x27;</span> <span class="keyword">in</span> dict2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="映射类型的内建函数和工厂函数"><a href="#映射类型的内建函数和工厂函数" class="headerlink" title="映射类型的内建函数和工厂函数"></a>映射类型的内建函数和工厂函数</h2><h3 id="标准类型函数-type-、str-和cmp"><a href="#标准类型函数-type-、str-和cmp" class="headerlink" title="标准类型函数[type()、str()和cmp()]"></a>标准类型函数[type()、str()和cmp()]</h3><p>如你所料，对一个字典调用type()工厂方法，会返回字典类型，“&lt;type ‘dict’&gt;”。调用str()工厂方法将返回该字典的字符串表示形式，它些都很容易理解。</p>
<p>在前面的章节里，我们已经讲述了用cmp()内建函数来操作数字、字符串、列表和元组。那么字典又是如何比较的呢？字典是通过这样的算法来比较的：首先是字典的大小，然后是键，最后是值。可是，用cmp()做字典的比较一般不是很有用。</p>
<p>接下来的小节里，将进一步详细说明字典比较的算法，但这部分是高层次的阅读内容，可以跳过，因为字典的比较不是很有用也不常见。</p>
<p><span style="font-weight: bolder;">*字典比较算法</span></p>
<p>接下来的例子中，我们建立两个字典进行比较，然后慢慢悠入，来看看这些修改对它们之间的比较带来的影响：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1 = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2 = &#123;<span class="string">&#x27;host&#x27;</span>:<span class="string">&#x27;earth&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">80</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(dict1,dict2)</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1[<span class="string">&#x27;host&#x27;</span>] = <span class="string">&#x27;earth&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(dict1, dict2)</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在第一个比较中，dict1比dict2小，因为dict2有更多元素（2个vs.0个）。在向dict1添加一个元素后，dict1仍然比dict2小（2vs.1），虽然添加的元素在dict2中也存在。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1[<span class="string">&#x27;port&#x27;</span>] = <span class="number">8080</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(dict1,dict2)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1[<span class="string">&#x27;port&#x27;</span>] = <span class="number">80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(dict1, dict2)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在向dict1中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键’host’的值相同，对于键’port’，dict1中值比dict2中的值大（8080 vs 80）。当把dict2中’port’的值设成和dict1中的值一样，那么两个字典相等：它们有相同的大小，相同的键、相同的值，所以cmp()返回值是0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1[<span class="string">&#x27;prot&#x27;</span>] = <span class="string">&#x27;tcp&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(dict1, dict2)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2[<span class="string">&#x27;port&#x27;</span>] = <span class="string">&#x27;udp&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(dict1, dict2)</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>当向两个字典中的任何一个添加新元素时，这个字典马上会成为大的那个字典，就像例子中的dict1一样。向dict2添加键-值后，因为两个字典的长度又相等了，会继续比较它们的键和值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cdict = &#123;<span class="string">&#x27;fruits&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ddict = &#123;<span class="string">&#x27;fruits&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(cdict,ddict)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cdict[<span class="string">&#x27;oranges&#x27;</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ddict[<span class="string">&#x27;apples&#x27;</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(cdict, ddict)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>上面的例子表明cmp()可以返回除-1、0、1外的其他值。算法按照以下的顺序。</p>
<p><span style="font-weight: bolder;">(1) 比较字典长度</span></p>
<p>如果字典的长度不同，那么用cmp(dict1,dict2)比较大小时，如果字典dict1比dict2长，cmp()返回正值；如果dict2比dict1长，则返回负值。也就是说，字典的键的个数越多，这个字典就越大，即：<br><code>len(dict1) &gt; len(dict2) --&gt; dict1 &gt; dict2</code></p>
<p><span style="font-weight: bolder;">(2) 比较字典的键</span></p>
<p>如果两个字典的长度相同，那就按字典的键比较；键比较的顺序和keys()方法返回键的顺序相同。（注意：相同的键会映射到哈希表的同一位置，这保证了对字典键的检查的一致性。）这时，如果两个字典的键不匹配时，对这两个（不匹配的键）直接进行比较。当dict1中第一个不同的键大于dict2中的第一个不同的键，cmp()会近回正值。</p>
<p><span style="font-weight: bolder;">(3) 比较字典的值</span></p>
<p>如果两个字典的长度相同而且它们的键也完全匹配，则用字典中每个相同的键所对应的值进行比较。一旦出现不匹配的值，就对这两个值进行直接比较。若dict1比dict2中相同的键所对应的值大，cmp()会返回正值。</p>
<p><span style="font-weight: bolder;">(4) 完全匹配</span></p>
<p>到此为止，每个字典有相同的长度、相同的键，每个键也对应相同的值，则字典完全匹配，返回0值。图7-1说明了上述字典比较的算法<br><img src="/7-1.png" alt="字典比较" title="字典比较"></p>
<h3 id="映射类型相关的函数"><a href="#映射类型相关的函数" class="headerlink" title="映射类型相关的函数"></a>映射类型相关的函数</h3><p>dict()<br>工厂函数被用来创建字典。如果不提供参数，会生成空字典。当容器类型对象作为一个参数传递给方法dict()时很有意思。如果参数是可以迭代的，即一个诹列，或是一个迭代器，或是一个支持迭代的对象，那每个可迭代的元素必须成对出现。在每个值对中，第1个元素是字典的键，第2个元素是字典中的值。见Python文档里关于dict()的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(<span class="built_in">zip</span>((<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>),(<span class="number">1</span>, <span class="number">2</span>)))</span><br><span class="line">&#123;<span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([[<span class="string">&#x27;x&#x27;</span>, <span class="number">1</span>],[<span class="string">&#x27;y&#x27;</span>, <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([<span class="string">&#x27;xy&#x27;</span>[i-<span class="number">1</span>]], i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<p>如果输入参数是（另）一个映射对象，比如，一个字典对象，对其调用dict()会从存在的字典里复制内容来生成新的字典。新生成的字典是原来字典对象的浅复制版本，它与用字典的内建方法copy()生成的字典对象是一样的。但是从已存在的字典生成新的字典速度比用copy()方法慢，我们推荐使用copy()</p>
<p>从Python2.3开始，调用dict()方法可以接受字典或关键字参数字典（函数操作符，第十一章）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(x=<span class="number">1</span>, y=<span class="number">2</span>)</span><br><span class="line">&#123;<span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict8 = <span class="built_in">dict</span>(x=<span class="number">1</span>, y=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict8</span><br><span class="line">&#123;<span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict9 = <span class="built_in">dict</span>(**dict8)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict9</span><br><span class="line">&#123;<span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>我们提醒读者dict9的例子只作为了解dict()方法的用途，它不是现实中的例子。使用下面这些行的方法更聪明（效果更好）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict9 = dict8.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict9</span><br><span class="line">&#123;<span class="string">&#x27;y&#x27;</span>: <span class="number">2</span> , <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>len()<br>内建函数len()很灵活。它可用在序列、映像类型和集合上（在本章的后面我们会看到）。对字典调用len()，它会返回所有元素（键-值对）的数目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2 = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;earth&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">80</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(dict2)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>我们前面提到字典中的元素是没有顺序的。从上面的例子中可以看到，dict2的元素显示的顺序和输入时的顺序正相反。</p>
<p>hash()<br>内建函数hash()本身并不是为字典设计的方法，但它可以判断某个对象是否可以做一个字典的键。将一个对象作为参数传递给hash()，会返回这个对象的哈希值。只有这个对象是可哈希的，才可答为字典的键（函数的返回值是整型，不产生错误或异常）。</p>
<p>如果用比较操作符来比较两个数值，发现它们是相等的，那么即使地者的数据类型不同，它们也会得到相同的哈希值。</p>
<p>如果非可哈希类型作为参数传递给hash()方法，会产生TypeError错误（因此，如果使用这样的对象作为健给字典赋值时会出错）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>([])</span><br><span class="line">Traceback (innermost last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">TypeError: <span class="built_in">list</span> objects are unhashable</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2[&#123;&#125;] = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">TypeError:<span class="built_in">dict</span> objects are unhashable</span><br></pre></td></tr></table></figure>
<p>在表7.1中，我们列出以下3个映射类型的相关函数。</p>
<table>
<thead>
<tr>
<th>函    数</th>
<th>操     作</th>
</tr>
</thead>
<tbody><tr>
<td>dict([container])</td>
<td>创建字典的工厂函数。如果提供了容器类（container），就用其中的条目填充字典，否则就创建一个空字典</td>
</tr>
<tr>
<td>len(mapping)</td>
<td>返回映射的长度（键-值的个数）</td>
</tr>
<tr>
<td>hash(obj)</td>
<td>返回obj的哈希值</td>
</tr>
</tbody></table>
<h2 id="映射类型内建方法"><a href="#映射类型内建方法" class="headerlink" title="映射类型内建方法"></a>映射类型内建方法</h2><p>字典提供了大量方法来帮我们做事情，见表7.2。</p>
<p>下面说明字典的一些很常见的方法。在上面的例子里，我们已经看到has_key()和它的替代方法in和not in。如我们在7.1小节看到，试图查找一个字典里没有的键值会产生KeyError异常。</p>
<p>基本的字典方法关注他们的皱起键和值。它们有：keys()方法，近回一个列表，包含字典中所有的键，values()方法，返回一个列表，包含字典中所有的值items()，返回一个包含所有（键，值）元组的列表。这些方法在不按任何顺序遍历字典的键或值时很有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2.keys()</span><br><span class="line">[<span class="string">&#x27;port&#x27;</span>,<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2.values()</span><br><span class="line">[<span class="number">80</span>, <span class="string">&#x27;earth&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2.items()</span><br><span class="line">[(<span class="string">&#x27;port&#x27;</span>, <span class="number">80</span>),(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;earth&#x27;</span>)]</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> eachKey <span class="keyword">in</span> dict2.keys():</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span> <span class="string">&#x27;dict2 key&#x27;</span>, eachKey, <span class="string">&#x27;has value&#x27;</span>, dict2[eachKey]</span><br><span class="line">...</span><br><span class="line">dict2 key prot has value <span class="number">80</span></span><br><span class="line">dict2 key name has value earth</span><br></pre></td></tr></table></figure>
<p>keys()方法很有用，它返回一个包含字典中所有键的列表，此方法可以与for循环一起使用来获取字典中的值。</p>
<p><span style="font-weight: bolder;">表7.2</span></p>
<table>
<thead>
<tr>
<th>方  法  名  字</th>
<th>操    作</th>
</tr>
</thead>
<tbody><tr>
<td>dict.clear()</td>
<td>删除字典中所有元素</td>
</tr>
<tr>
<td>dict.copy()</td>
<td>返回字典（浅复制）的一个副本</td>
</tr>
<tr>
<td>dict.fromkeys(seq, val&#x3D;None)</td>
<td>创建并返回一个新字典，以seq中的元素做该字典的键，val做该字典中所有键对应的初始值（如果不提供此值，则默认为None ）</td>
</tr>
<tr>
<td>dict.get(key,default&#x3D;None)</td>
<td>对字典dict中的键key，返回它对应的值value，如果字典中不存在此键，则返回default的值（注意，参数default的默认值为None）</td>
</tr>
<tr>
<td>dict.has_key(key)</td>
<td>如果键在字典中存在，返回True，否则返回False。在Python2.2版本引入in和not in后，此方法几乎已经废弃不用了，但仍提供一个可工作的接口</td>
</tr>
<tr>
<td>dict.items</td>
<td>返回一个包含字典中的键、值对元组的列表</td>
</tr>
<tr>
<td>dict.keys()</td>
<td>返回一个包含字典中键的列表</td>
</tr>
<tr>
<td>dict.iter()</td>
<td>方法iteritems()、iterkeys()、itervalues()与它们对应的非迭代方法一样，不同的是它们返回一个迭代子，而不是一个列表</td>
</tr>
<tr>
<td>dict.pop(key,[,default])</td>
<td>和方法get()相似。如果字典中key键存在，删除并返回dict[key]:如果key键不存在，且没有给出default的值，则引发KeyError异常</td>
</tr>
<tr>
<td>dict.setdefault(key, default&#x3D;None)</td>
<td>和方法set()相似，但如果字典中不存在key键，由dict[key]&#x3D;default为它赋值</td>
</tr>
<tr>
<td>dict.update(dict2)</td>
<td>将字典dict2的键-值对添加到字典dict</td>
</tr>
<tr>
<td>dict.values()</td>
<td>返回一个包含字典中所有值的列表</td>
</tr>
</tbody></table>
<p>但是，它返回的元素是没有顺序的（和哈希表中的键一样），我们通常希望它们能按某种方式排序。</p>
<p>在Python2.4版本以前，你只能调用字典的keys()方法获得键的列表，然后调用列表的sort()方法得到一个有序可遍历的列表。现在特别为迭代子设计了一个名为sorted()的内建函数，它返回一个有序的迭代子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> eachKey <span class="keyword">in</span> <span class="built_in">sorted</span>(dict2):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;dict2 key&#x27;</span>, eachKey, <span class="string">&#x27;has value&#x27;</span>,</span><br><span class="line">dict2[eachKey]</span><br><span class="line">...</span><br><span class="line">dict2 key name has value earth</span><br><span class="line">dict2 key port has value <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>update()方法可以用来将一个字典的内容添加到另外一个字典中。字典中原有的键如果与新添加的键重复，那么重复键所对应的原有条目的值将被新建所对应的值所覆盖。原来不存在的条目则被添加到字典中。clear()方法可以用来删除字典中的所有的条目。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2 = &#123;<span class="string">&#x27;host&#x27;</span>:<span class="string">&#x27;earth&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">80</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3 = &#123;<span class="string">&#x27;host&#x27;</span>:<span class="string">&#x27;venus&#x27;</span>,<span class="string">&#x27;server&#x27;</span>:<span class="string">&#x27;http&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2.update(dict3)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2</span><br><span class="line">&#123;<span class="string">&#x27;server&#x27;</span>:<span class="string">&#x27;http&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">80</span>,<span class="string">&#x27;host&#x27;</span>:<span class="string">&#x27;venus&#x27;</span>,<span class="string">&#x27;host&#x27;</span>,<span class="string">&#x27;venus&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3.clear()</span><br></pre></td></tr></table></figure>
<p>copy()方法返回一个字典的副本。注意这只是浅复制。关于浅复制和深复制请阅读小节6.19。最后要说明，get()方法和键查找（key-lookup）操作符相似，不同的是它允许你为不存在的键提供默认值。如果该键不存在，它未给出它的默认值，则返回None。此方法比采用键查找（key-lookup）更灵活，因为你不必担心因键不存在而引发异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict4 = dict2.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict4</span><br><span class="line">&#123;<span class="string">&#x27;server&#x27;</span>:<span class="string">&#x27;http&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">80</span>,<span class="string">&#x27;host&#x27;</span>:<span class="string">&#x27;venus&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict4.get(<span class="string">&#x27;host&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;venus&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict4.get(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(dict4.get(<span class="string">&#x27;xxx&#x27;</span>))</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;None&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict4.get(<span class="string">&#x27;xxx&#x27;</span>,<span class="string">&#x27;no such key&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;no such key&#x27;</span></span><br></pre></td></tr></table></figure>
<p>setdefault()是自2.0才有的内建方法，使得代码更加简洁，它实现了常用的语法：检查字典中是否含有某键。如果字典中这个键存在，你可以取到它的值。如果所找的键在字典中不存在，你可以给这个键赋默认值并返回此值。这正是执行setdefault()方法的目的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDict = &#123;<span class="string">&#x27;host&#x27;</span>:<span class="string">&#x27;earth&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">80</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDict.keys()</span><br><span class="line">[<span class="string">&#x27;host&#x27;</span>,<span class="string">&#x27;port&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDict.items()</span><br><span class="line">[(<span class="string">&#x27;host&#x27;</span>,<span class="string">&#x27;earth&#x27;</span>),(<span class="string">&#x27;port&#x27;</span>,<span class="number">80</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDict.setdefault(<span class="string">&#x27;port&#x27;</span>,<span class="number">8080</span>)</span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDict.setdefault(<span class="string">&#x27;prot&#x27;</span>,<span class="string">&#x27;tcp&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;tcp&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDict.items()</span><br><span class="line">[(<span class="string">&#x27;prot&#x27;</span>,<span class="string">&#x27;tcp&#x27;</span>),(<span class="string">&#x27;host&#x27;</span>,<span class="string">&#x27;earth&#x27;</span>),(<span class="string">&#x27;port&#x27;</span>,<span class="number">80</span>)]</span><br></pre></td></tr></table></figure>
<p>前面，我们曾简要介绍过fromkeys()方法，下面是更多的示例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;&#125;.fromkeys(<span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line">&#123;<span class="string">&#x27;y&#x27;</span>:<span class="literal">None</span>, <span class="string">&#x27;x&#x27;</span>:<span class="literal">None</span>, <span class="string">&#x27;z&#x27;</span>:<span class="literal">None</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;&#125;.fromkeys((<span class="string">&#x27;love&#x27;</span>,<span class="string">&#x27;honor&#x27;</span>),<span class="literal">True</span>)</span><br><span class="line">&#123;<span class="string">&#x27;love&#x27;</span>:<span class="literal">True</span>, <span class="string">&#x27;honor&#x27;</span>:<span class="literal">True</span>&#125;</span><br></pre></td></tr></table></figure>
<p>目前，keys()、items()和values()方法的返回值都是列表。数据集如果很大会导致很难处理，这也正是iteritems()、iterkeys()和itervalues()方法被添加到Python2.2的主要原因。这些函数与返回列表的对应方法相似，只是它们返回惰性赋值的迭代器，所以节省内存。未来的Python版本中，甚至会更灵活，那时这些方法将会返回强大的对象，暂叫做视图（views）。视图是访问容器对象的接口集。举例来说，你可以从一个视图中删除某个字典的键，从而改变某个字典。</p>
<h2 id="字典的键"><a href="#字典的键" class="headerlink" title="字典的键"></a>字典的键</h2><p>字典中的值没有任何限制。他们可以是任意Python对象，即从标准对象到用户自定义对象皆可。但是字典中的键是有类型限制的。</p>
<h3 id="不允许一个键对应多个值"><a href="#不允许一个键对应多个值" class="headerlink" title="不允许一个键对应多个值"></a>不允许一个键对应多个值</h3><p>你必须明确一条原则：每个键只能对应一个项。也就是说，一键对应多个值是不允许的（像列表、元组和其他字典这样的容器对象是可以的）。当有键发生冲突（即字典键重复赋值），取最后（最近）的赋值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1 = &#123;<span class="string">&#x27;foo&#x27;</span>:<span class="number">789</span>, <span class="string">&#x27;foo&#x27;</span>:<span class="string">&#x27;xyz&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1</span><br><span class="line">&#123;<span class="string">&#x27;foo&#x27;</span>:<span class="string">&#x27;xyz&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1[<span class="string">&#x27;foo&#x27;</span>] = <span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1</span><br><span class="line">&#123;<span class="string">&#x27;foo&#x27;</span>:<span class="number">123</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Python并不会因字典中的键存在冲突而产生一个错误。它不会检查键的冲突是因为，如果真这样做的话，在每个键-值对赋值的时候都会做检查，这将会占用一定量的内存。在上面的例子里，键’foo’被列出两次，Python从左到右检查键-值对。首先值789被赋值（给键’foo’所对应的值），然后又很快被字符串’xyz’替代。当给字典中一个不存在的键赋值时，键和值会被创建和添加，但如果该键已经存在（键冲突），那此键所对应的值将被替换。上面例子中，键’foo’所对应的值被替换了两次；最后的赋值语句，值123代替了值’xyz’。</p>
<h3 id="键必须是可哈希的"><a href="#键必须是可哈希的" class="headerlink" title="键必须是可哈希的"></a>键必须是可哈希的</h3><p>我们在小节7.1说过，大多数Python对象可以作为键；但它们必须是可哈希的对象。像列表和字典这閪的可变类型，由于它们不是可哈希的，所以不能作为键。</p>
<p>所有不可变的类型都是可哈希的，因此它们都可以作为字典的键。一个要说明的问题是数字：值相等的数字表示相同的键。换句话来说，整型数字1和浮点型1.0的哈希值是相同的，即它们是相同的键。</p>
<p>同时，也有一些可变对象（很少）是可哈希的，它们可以做字典的键，但很少见。举一个例子，一个实现了<code>__hash__()</code>特殊方法的类。因为<code>__hash__()</code>方法返回一个整型，所以仍然是用不可变的值（做字典的键）。</p>
<p>为什么键必须是可哈希的？解释器调用哈希函数，根据字典中的键的值来计算存储你的数据的位置。如果键是可变对象，它的值可改变。如果键发生变化，哈希函数会映像到不同的地址来存储数据。如果这样的情况发生，哈希函数就不可能可靠地存储或获取相关的数据。选择可哈希的键的原因就是因为它们的值不能改变（此问题在Python FAQ中也能找到答案）。</p>
<p>我们知道数字和字符串可以被用做字典的键，但元组又怎么样呢？我们知道元组是可变的，但在小节6.17.2，我们提示过它们也可能不是一成不变的。用元组做有效的键，必须要加限制：元组中只包括像数字和字符串这样的不可变参数，才可以作为字典中有效的键。</p>
<p>我们用一个程序（userpw.py 例7.1），来为本章关于字典的讲述做个小结。这个程序是用于管理用户名和密码的模拟登录数据系统。脚本接受新用户的信息：</p>
<p>这个程序管理用于登录系统的用户信息：登录名字和密码。登录用户账号建立后，已存在用户可以用登录名字和密码重返系统。新用户不能用别人的登录名建立用户账号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">db = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newuser</span>():</span><br><span class="line">    prompt = <span class="string">&#x27;login desired:&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        name = raw_input(prompt)</span><br><span class="line">        <span class="keyword">if</span> db.has_key(name):</span><br><span class="line">            prompt = <span class="string">&#x27;name taken, try another:&#x27;</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>：</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    pwd = raw_input(<span class="string">&#x27;passwd:&#x27;</span>)</span><br><span class="line">    db[name] = pwd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">olduser</span>():</span><br><span class="line">    name = raw_input(<span class="string">&#x27;login:&#x27;</span>)</span><br><span class="line">    pwd = raw_input(<span class="string">&#x27;passwd:&#x27;</span>)</span><br><span class="line">    passwd = db.get(name)</span><br><span class="line">    <span class="keyword">if</span> passwd == pwd:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;welcome back&#x27;</span>, name</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;login incorrect&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showmenu</span>():</span><br><span class="line">    prompt = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(N) ew User Login</span></span><br><span class="line"><span class="string">(E) xisting User Login</span></span><br><span class="line"><span class="string">(Q) uit</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter choice:&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    done = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line"></span><br><span class="line">        chosen = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> chosen:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                choice = raw_input(prompt).strip()[<span class="number">0</span>].lower()</span><br><span class="line">            <span class="keyword">except</span> (EOFError, KeyboardInterrupt):</span><br><span class="line">                choice = <span class="string">&#x27;q&#x27;</span></span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;\nYou picked:[%s]&#x27;</span> % choice</span><br><span class="line">            <span class="keyword">if</span> choice <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;neq&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;invalid option, try again&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                chosen = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> choice == <span class="string">&#x27;q&#x27;</span>: done = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> choice == <span class="string">&#x27;n&#x27;</span>: newuser()</span><br><span class="line">        <span class="keyword">if</span> choice == <span class="string">&#x27;e&#x27;</span>: olduser()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    showmenu()    </span><br></pre></td></tr></table></figure>
<p>他们提供登录名和密码。账号建立后，已存在用户可用登陆名和正确的密码重返系统。新用户不能用别人的登录名建立账号。<br><span style="font-weight: bolder;">逐行解释</span><br><br>1～3行<br><br>在Unix初始行后，我们用一个空用户数据库初始化程序。因为我们没有把数据存储在任何地方，每次程序执行时都会新建一个用户数据库。<br><br>5~15行<br><br>newuser()函数用来建立新用户。它检查名字是否已经存在，如果证实是一个新名字，将要求用户输入他或她的密码（我们这个简单的程序没有加密），用户的密码被存储在字典里，以他们的名字做字典中的键。<br><br>17～24行<br><br>olduser()函数处理返回的用户。如果用户用正确的用户名和密码登录，打出欢迎信息。否则通知用户是无效登录并返回菜单。我们不会采用一个无限循环来提示用户输入正确的密码，因为用户可能会无意进入错误的菜单选项。<br><br>26～51行<br><br>真正控制这个脚本的是showmenu()函数，它显示给用户一个友好界面。提示信息被包括在三个引号里，这样做是因为提示信息跨多行，而且比单行包含<code>\n</code>符号的字符串更容易处理。菜单显示后，它等待用户的有效输入，然后根据菜单选项选择操作方式。try-expect语句和第6章stack.py queue.py例子里的一样（见小节6.14.1）。<br><br>53～54行<br>如果这个脚本被直接执行（不是通过import方式），这行代码会调用showmenu()函数运行程序。</p>
<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p>数学上，把set称做由不同的元素组成的集合，集合（set）的成员通常被称做集合元素（set elements）。Python把这个概念引入到它的集合类型对象里。集合对象是一组无序排列的可哈希的值。是的，集合成员可以做字典中的键。数学集合转为Python的集合对象很有效，集合关系测试和union、intersection等操作符在Python里也同样如我们所预想地那样工作。</p>
<p>和其他容器类型一样，集合支持用in和not in操作符检查成员，由len()内建函数得到集合的基数（大小），用for循环迭代集合的成员。但是因为集合本身是无序的，你不可以为集合创建索引或执行切片（slice）操作，也没有键可用来获取集合中的元素的值。</p>
<p>集合有两种不同的类型，可变集合（set）和不可变集合（frozenset）。如你所想，对可变集合，你可以添加和删除元素，对不可变集合则不允许这样做。请注意，可变集合不是可哈希的，因此既不能用做字典的键也不能做其他集合中的元素。不可变集合则正好相反，即，他们有哈希值，能被用做字典的键或是作为集合中的一个成员。</p>
<p>集合最早出现在Python2.3版本中，通过集合模块来创建，并通过ImmutableSet类和Set类进行访问。而后来，大家都认为把它们作为内建的数据类型是个更好的主意，因此这些类被用C重写改进后包含进Python2.4。关于集合类型和这些类改进的更多内容，可阅读此文获得详情：PEP 218，键接地址：<a href="http://python.org/peps/pep-0218.html%E3%80%82">http://python.org/peps/pep-0218.html。</a></p>
<p>虽然现在集合类型已经是Python的基本数据类型了，但它经常会以用户自定义类的形式出现在各种Python程序中，就像复数一样（复数从Python1.4生版本起成为Python的一个数据类型），这样复复劳动已数不胜数了。在现在的Python版本之前，（即使集合类型对许多人的程序来说并不是最理想的数据结构，）许多人仍然给列表和字典这样的Python标准类型添加集合功能，这样可以把它们作为真正集合类型的代理来使用。因此现在的使用者有包括“真正”集合类型在内的多种选择。</p>
<p>在我们详细讲述Python的集合对象之前，我们必须理解Python中的一些数学符号（见表7.3），这样对术语和功能有一个清晰的了解。<br><img src="/7-2.png" alt="Alt text" title="Optional title"></p>
<h3 id="如何创建集合类型和给集合赋值"><a href="#如何创建集合类型和给集合赋值" class="headerlink" title="如何创建集合类型和给集合赋值"></a>如何创建集合类型和给集合赋值</h3><p>集合与列表（[]）和字典（{}）不同，没有特别的语法格式。列表和字典可以分别用他们自己的工厂方法list()和dict()创建，这也是集合被创建的唯一方法–用集合的工厂方法set()和frozenset()：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>(<span class="string">&#x27;cheeeseshop&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;s&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="built_in">frozenset</span>(<span class="string">&#x27;bookshop&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line"><span class="built_in">frozenset</span>([<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;s&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(s)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(t)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;frozenset&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s) == <span class="built_in">len</span>(t)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s == t</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="如何访问集合中的值"><a href="#如何访问集合中的值" class="headerlink" title="如何访问集合中的值"></a>如何访问集合中的值</h3><p>可以遍历查看集保成员或检查某项元素是否是一个集合中的成员。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;k&#x27;</span> <span class="keyword">in</span> s</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;k&#x27;</span> <span class="keyword">in</span> t</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;c&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> t</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> i </span><br><span class="line">...</span><br><span class="line">c</span><br><span class="line">e</span><br><span class="line">h</span><br><span class="line">o</span><br><span class="line">p</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<h3 id="如何更新集合"><a href="#如何更新集合" class="headerlink" title="如何更新集合"></a>如何更新集合</h3><p>用各种集合内建的方法和操作符添加和删除集合的成员。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;z&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.update(<span class="string">&#x27;pypi&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s -= <span class="built_in">set</span>(<span class="string">&#x27;pypi&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;s&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>我们之前提到过，只有可变集合能被修改。试图修改不可变集合会引发异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.add(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">AttributeError: <span class="string">&#x27;frozenset&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;add&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="如何删除集合中的成员和集合"><a href="#如何删除集合中的成员和集合" class="headerlink" title="如何删除集合中的成员和集合"></a>如何删除集合中的成员和集合</h3><p>前面我们看到如何删除集合成员。如果如何删除集合本身，可以像删除任何Python对象一样，令集合超出它的作用范围，或调用del将他们直接清除出当前的名称空间。如果它的引用计数为零，也会被标记以便被垃圾回收。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s</span><br></pre></td></tr></table></figure>

<h2 id="集合类型操作符"><a href="#集合类型操作符" class="headerlink" title="集合类型操作符"></a>集合类型操作符</h2><h3 id="标准类型操作符（所有的集合类型）"><a href="#标准类型操作符（所有的集合类型）" class="headerlink" title="标准类型操作符（所有的集合类型）"></a>标准类型操作符（所有的集合类型）</h3><p><span style="font-weight: bolder;">1. 成员关系（in, not in）</span><br>就序列而言，Python中的in和not in操作符决定某个元素是否是一个集合中的成员。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>(<span class="string">&#x27;cheeseshop&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="built_in">frozenset</span>(<span class="string">&#x27;bookshop&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;k&#x27;</span> <span class="keyword">in</span> s</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;k&#x27;</span> <span class="keyword">in</span> t </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;c&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> t</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bolder;">2. 集合等价&#x2F;不等价</span><br>等价&#x2F;不等价被用于在相同或不同的集合之间做比较。两个集合相等是指，对每个集合而言，当且仅当其中一个集合中的每个成员同时也是另一个集合中的成员。</p>
<p>你也可以说每个集合必须是另一个集合的一个子集，即s&lt;&#x3D;t 和 s&gt;&#x3D;t的值均为值（True）或（<code>s&lt;=t and s&gt;=t</code>）的值为值（True）。集合等价&#x2F;不等价与集合的类型或集合成员的顺序无关，只与集合的元素有关。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s == t </span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s != t</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = <span class="built_in">frozenset</span>(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s == u</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>(<span class="string">&#x27;posh&#x27;</span>) == <span class="built_in">set</span>(<span class="string">&#x27;shop&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bolder;">3. 子集&#x2F;超集</span><br>Set用Python的比较操作符检查某集合是否是其他集合的超集或子集。“小于”符号（&lt;, &lt;&#x3D;）用来判断子集，“大于”符号（&gt;, &gt;&#x3D;）用来判断超集。</p>
<p>“小于”和“大于”意味着两个集合在比较时不能相等。等于号允许非严格定义的子集和超集。</p>
<p>Set支持严格（&lt;）子集和非严格（&lt;&#x3D;）子集，也支持严格（&gt;）超集和非严格（&gt;&#x3D;）超集。只有当第1个集合是第2个集合的严格子集时，我们才称第1个集合“小于”第2个集合，同理，只有当第1个集合是第2个集合的严格超集时，我们才称为第1个集合“大于”第2个集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>(<span class="string">&#x27;shop&#x27;</span>) &lt; <span class="built_in">set</span>(<span class="string">&#x27;cheeseshop&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>(<span class="string">&#x27;bookshop&#x27;</span>) &gt;= <span class="built_in">set</span>(<span class="string">&#x27;shop&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="集合类型操作符（所有的集合类型）"><a href="#集合类型操作符（所有的集合类型）" class="headerlink" title="集合类型操作符（所有的集合类型）"></a>集合类型操作符（所有的集合类型）</h3><p><span style="font-weight: bolder;">1. 联合（|）</span><br>联合（union） 操作和集合的OR（又称可兼折取，inclusive disjunction）其实是等价的，两个集合的联合是一个新集合，该集合中的每个元素都至少是其中一个集合的成员，即，属于两个集合其中之一的成员。联合符号有一个等价的方法，union()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s | t</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;s&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><span style="font-weight: bolder;">2. 交集（&amp;）</span><br>你可以把交集操作比做集合的AND（或合取）操作。两个集合的交集是一个新集合，该集合中的每个元素同时是两个集合中的成员，即属于两个集合的成员。交集符号有一个等价的方法，intersection()。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s &amp; t</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><span style="font-weight: bolder;">3. 差补&#x2F;相对补集（一）</span><br>两个集合（s和t）的差补或相对补集是指一个集合C，该集合中的元素，只属于集合s，而不属于集合t。差符号有一个等价的方法difference()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s - t</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><span style="font-weight: bolder;">4. 对称差分（^）</span><br>和其他的布尔集合操作相似，对称差分是集合的XOR（又称“异或”，exclusive disjunction）。两个集合（s和t）的对称差分是指另外一个集合C，该集合中的元素，只能是属于集合s或者集合t的成员，不能同时属于两个集合。对称差分有一个等价的方法symmetric_difference()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s ^ t</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bolder;">5. 混合集合类型操作</span><br>上面的示例中，左边的s是可变集合，而右边的t是一个不可变集合，注意上面使用集合操作符所产生的仍然是可变集合，但是如果左右操作数的顺序反过来，结果就不一样了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t | s</span><br><span class="line"><span class="built_in">frozenset</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;s&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t ^ s</span><br><span class="line"><span class="built_in">frozenset</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;k&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t - s</span><br><span class="line"><span class="built_in">frozenset</span>([<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>如果左右两个操作数的类型相同，既都是可变集合或不可变集合，则所产生的结果类型是相同的，但如果左右两个操作数的类型的类型不相同（左操作数是set，右操作数是frozenset，或相反情况），则所产生的结果类型与左操作数的类型相同，上例中可以证明这一点。还要注意，加号不是集合类型的操作符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = s + t</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">&#x27;set&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;set&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = s | t</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;s&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>)(v)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s &lt; v</span><br><span class="line"><span class="literal">True</span> </span><br></pre></td></tr></table></figure>
<h3 id="集合类型操作符（仅适用于可变集合）"><a href="#集合类型操作符（仅适用于可变集合）" class="headerlink" title="集合类型操作符（仅适用于可变集合）"></a>集合类型操作符（仅适用于可变集合）</h3><p><code>(Union)Update(|=)</code><br>这个更新方法从已存在的集合中添加（可能多个）成员，此方法和update()等价。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>(<span class="string">&#x27;cheeseshop&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = <span class="built_in">frozenset</span>(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s |= <span class="built_in">set</span>(<span class="string">&#x27;pypi&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br></pre></td></tr></table></figure>
<p><code>Retention/Intersection Update(&amp;=)</code><br>保留（或交集更新）操作保留与其他集合的共有成员。此方法和intersection_update()等价。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>(u)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s &amp;= <span class="built_in">set</span>(<span class="string">&#x27;shop&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><code>Difference Update(-=)</code><br>对集合s和t进行差更新操作s-&#x3D;t，差更新操作会返回一个集合，该集合中的成员是集合s去除掉集合t中元素后剩余的元素。此方法和difference_update()等价。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>(u)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s -= <span class="built_in">set</span>(<span class="string">&#x27;shop&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><code>Symmetric Difference Update(^=)</code><br>对集合s和t进行对称差分更新操作（s^&#x3D;t），对称差分更新操作会返回一个集合，该集合中的成员仅是原集合s或仅是另一集合t中的成员。此方法和symmetric_difference_update()等价。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>(u)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="built_in">frozenset</span>(<span class="string">&#x27;bookshop&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s ^= t</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;k&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h2 id="内建函数-2"><a href="#内建函数-2" class="headerlink" title="内建函数"></a>内建函数</h2><h3 id="标准类型函数-3"><a href="#标准类型函数-3" class="headerlink" title="标准类型函数"></a>标准类型函数</h3><p>len()<br>把集合作为参数传递给内建函数len()，返回集合的基数（或元素的个数）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>(u)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;o&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="集合类型工厂函数"><a href="#集合类型工厂函数" class="headerlink" title="集合类型工厂函数"></a>集合类型工厂函数</h3><p>set()和frozenset()<br>set()和frozenset()工厂函数分别用来生成可变和不可变的集合。如果不提供任何参数，默认会生成空集合。如果提供一个参数，则该参数必须是可迭代的，即一个序列，或迭代器，或支持迭代的一个对象，例如一个文件或一个字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>()</span><br><span class="line"><span class="built_in">set</span>([])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>([])</span><br><span class="line"><span class="built_in">set</span>([])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>(())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>([])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>(<span class="string">&#x27;shop&#x27;</span>)</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">frozenset</span>([<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line"><span class="built_in">frozenset</span>([<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;numbers&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.writer(<span class="string">&#x27;%d\n&#x27;</span> % i)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;numbers&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>(f)</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;0\n&#x27;</span>, <span class="string">&#x27;3\n&#x27;</span>, <span class="string">&#x27;1\n&#x27;</span>, <span class="string">&#x27;4\n&#x27;</span>, <span class="string">&#x27;2\n&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure>
<h2 id="集合类型内建方法"><a href="#集合类型内建方法" class="headerlink" title="集合类型内建方法"></a>集合类型内建方法</h2><h3 id="方法（所有的集合方法）"><a href="#方法（所有的集合方法）" class="headerlink" title="方法（所有的集合方法）"></a>方法（所有的集合方法）</h3><p>我们已看到很多和内建方法等价的操作符，表7.4做了小结：<br>内建方法copy()没有等价的操作符。和同名的字典方法一样，copy()方法比用像set()、frozenset()或dict()这样的工厂方法复制对象的副本要快。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>s.issubset(t)</td>
<td>如果s是t的了集，则返回True，否则返回False</td>
</tr>
<tr>
<td>s.issuperset(t)</td>
<td>如果t是s的超集，则返回True，否则返回False</td>
</tr>
<tr>
<td>s.union(t)</td>
<td>返回一个新集合，该集合是s和t的并集</td>
</tr>
<tr>
<td>s.intersection(t)</td>
<td>返回一个新集合，该集合是s和t的交集</td>
</tr>
<tr>
<td>s.difference(t)</td>
<td>返回一个新集合，该集合是s的成员，但不是t的成员</td>
</tr>
<tr>
<td>s.symmetric_difference(t)</td>
<td>返回一个新集合，该集合是s或t成员，但不是s和t共有成员</td>
</tr>
<tr>
<td>s.copy()</td>
<td>返回一个新集合，它是集合s的浅复制</td>
</tr>
</tbody></table>
<h3 id="方法（仅适用于可充数集合）"><a href="#方法（仅适用于可充数集合）" class="headerlink" title="方法（仅适用于可充数集合）"></a>方法（仅适用于可充数集合）</h3><p>表7.5总结了所有可变信合的内建方法，和上面的方法相似，我们已经看过许多和它们等价的操作符。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>s.update(t)</td>
<td>用t中的元素修改s，即s现在包含s或t的成员</td>
</tr>
<tr>
<td>s.intersection_update(t)</td>
<td>s中的成员是共同属于s和t的元素</td>
</tr>
<tr>
<td>s.difference_update(t)</td>
<td>s中的成员是属于s但不包含在t中的元素</td>
</tr>
<tr>
<td>s.symmetric_difference_update(t)</td>
<td>s中的成员更新为那些包含在s或t中，但不是s和t共有的元素</td>
</tr>
<tr>
<td>s.add(obj)</td>
<td>在集合s中添加对象obj</td>
</tr>
<tr>
<td>s.remove(obj)</td>
<td>从集合s中删除对象obj；如果obj不是集合s中的元素（obj not in s ），将引发KeyError错误</td>
</tr>
<tr>
<td>s.discard(obj)</td>
<td>如果obj是集合s中的元素，从集合s中删除对象obj</td>
</tr>
<tr>
<td>s.pop()</td>
<td>删除集合s中的任意一个对象，并返回它</td>
</tr>
<tr>
<td>s.clear()</td>
<td>删除集合s中的所有元素</td>
</tr>
</tbody></table>
<p>新的方法有add()、remove()、discard()、pop()、clear()。这些接受对象的方法，参数必须是可哈希的。</p>
<h3 id="操作符和内建方法比较"><a href="#操作符和内建方法比较" class="headerlink" title="操作符和内建方法比较"></a>操作符和内建方法比较</h3><p>像你看到的，很多内建的方法几乎和操作符等价。我们说“几乎等价”，意思是它们间是有一个重要区别：当用操作符时，操作符两边的操作数必须是集合。在使用内建方法时，对象也可以是迭代类型的。为什么要用这种方式来实现呢？Python的文档里写明：采用易懂的<code>set(&#39;abc&#39;).intersection(&#39;cbs&#39;)</code>可以避免使用<code>set(&#39;abc&#39;)[and]&#39;cbs&#39;</code>这样容易出错的构建方法。</p>
<h2 id="集合类型总结表"><a href="#集合类型总结表" class="headerlink" title="集合类型总结表"></a>集合类型总结表</h2><p>表7.6中，我们总结了所有的集合类型的操作符、函数和方法。</p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法名</th>
<th>等价操作符</th>
<th>说  明</th>
</tr>
</thead>
<tbody><tr>
<td>len(s)</td>
<td></td>
<td>集合基数：集合s中元素的个数</td>
</tr>
<tr>
<td>set([obj])</td>
<td></td>
<td>可变集合工厂函数；obj必须是支持迭代的，由obj中的元素创建集合，否则创建一个空集合</td>
</tr>
<tr>
<td>frozenset([obj])</td>
<td></td>
<td>不可变集合工厂函数；执行方式和set()方法相同，但它返回的是不可变集合</td>
</tr>
<tr>
<td></td>
<td>obj in s</td>
<td>成员测试：obj是s中的一个元素吗？</td>
</tr>
<tr>
<td></td>
<td>obj not in s</td>
<td>非成员测试：obj不是s中的一个元素吗？</td>
</tr>
<tr>
<td></td>
<td>s &#x3D;&#x3D; t</td>
<td>等价测试：测试s和t是否具有相同的元素？</td>
</tr>
<tr>
<td></td>
<td>s !&#x3D; t</td>
<td>不等价测试：与&#x3D;&#x3D;相反</td>
</tr>
<tr>
<td></td>
<td>s &lt; t</td>
<td>（严格意义上）子集测试；s!&#x3D;t而且s中所有的元素都是t的成员</td>
</tr>
<tr>
<td>s.issubset(t)</td>
<td>s &lt;&#x3D; t</td>
<td>子集测试（允许不严格意义上的子集）：s中所有的元素都是t的成员</td>
</tr>
<tr>
<td></td>
<td>s &gt; t</td>
<td>(严格意义上）超集测试：s!&#x3D;t而且t中所有的元素都是s的成员</td>
</tr>
<tr>
<td>s.issuperset(t)</td>
<td>s &gt;&#x3D; t</td>
<td>超集测试（允许不严格意义上的超集）：t中所有的元素都是s的成员</td>
</tr>
<tr>
<td>s.union(t)</td>
<td>s l t</td>
<td>合并操作:s或t中的元素</td>
</tr>
<tr>
<td>s.intersec-tion(t)</td>
<td>s &amp; t</td>
<td>交集操作：s和t中的元素</td>
</tr>
<tr>
<td>s.difference(t)</td>
<td>s - t</td>
<td>差分操作：s中的元素，而不是t中的元素</td>
</tr>
<tr>
<td>s.symmetric_difference(t)</td>
<td>s ^ t</td>
<td>对称差分操作：s或t中的元素，但不是s和t共有的元素</td>
</tr>
<tr>
<td>s.copy()</td>
<td></td>
<td>复制操作：返回s的（浅复制）副本</td>
</tr>
<tr>
<td>s.update(t)</td>
<td>s l&#x3D; t</td>
<td>(Union)修改操作：将t中的成员添加s</td>
</tr>
<tr>
<td>s.intersection_update(t)</td>
<td>s &amp;&#x3D; t</td>
<td>交集修改操作：s中仅包括s和t中共有的成员</td>
</tr>
<tr>
<td>s.difference_update(t)</td>
<td>s -&#x3D; t</td>
<td>差修乞讨操作：s中包括仅属于s但不属于t的成员</td>
</tr>
<tr>
<td>s.symmetric_difference_update(t)</td>
<td>s ^&#x3D; t</td>
<td>对称差分修改操作：s中包括仅属于s或仅属于t的成员</td>
</tr>
<tr>
<td>s.add(obj)</td>
<td></td>
<td>加操作：将obj添加到s</td>
</tr>
<tr>
<td>s.remove(obj)</td>
<td></td>
<td>删除操作：将obj从s中删除：如果s中不存在obj，将引发KeyError</td>
</tr>
<tr>
<td>s.discard(obj)</td>
<td></td>
<td>丢弃操作：remove()的友好版本–如果s中存在obj，从s中删除它</td>
</tr>
<tr>
<td>s.pop()</td>
<td></td>
<td>Pop操作：移除并返回s中的任意一个元素</td>
</tr>
<tr>
<td>s.clear()</td>
<td></td>
<td>清除操作：移除s中的所有元素</td>
</tr>
</tbody></table>
<h2 id="相关模块-1"><a href="#相关模块-1" class="headerlink" title="相关模块"></a>相关模块</h2><p>集合（set）模块从2.3版本引进，可继函Set或ImmuteablSet来生成子类。虽然从Python2.4起使用集合类型，但是集合模块不会弃用。<br><br>以下是一些你可能认为有用的在线参考文章：<br><a href="http://en.wikipedia.org/wiki/Set">http://en.wikipedia.org/wiki/Set</a><br><a href="http://www.geocities.com/basicmathsets/set.html">http://www.geocities.com/basicmathsets/set.html</a><br><a href="http://www.math.uah.edu/stat/foundations/Sets.xhtml">http://www.math.uah.edu/stat/foundations/Sets.xhtml</a></p>
<h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><p><br>7-1. 字典方法。哪个字典方法可以用来把两个字典合并到一起？<br><br>7-2. 字典的键。我们知道字典的值可以是任意的Python对象，那字典的键又如何呢？请试着将除数字和字符串以外的其他不同类型的对象作为字典的键，看一看哪些类型可以，哪些不行？对那些不能作为字典键的对象类型，你认为是什么原因呢？<br><br>7-3. 字典和列表的方法。<br>(a). 创建一个字典，并把这个字典中的键接照字母顺序显示出来。<br>(b). 现在根据已按照字母顺序排序好的键，显示出这个字典中的键和值。<br>(C). 同（b)，但这次是根据已经按照字母顺序排序好的字典的值，显示出字个字典中的键和值（注意：对字典和哈希表来说，这样做一般没有什么实际意义，因为大多数访问和排序（如果需要）都是基于字典的键，这里只把它作为一个练习）<br><br>7-4. 建立字典。给定两个长度相同的列表，比如说，列表[1，2，3，…]和[‘abc’,’def’,’ghi’,…]，有这两个列表里的所有数据组成一个字典，像这样：{1：’abc’, 2:’def’, 3:’ghi’,…}<br><br>7-5. userpw2.py。下面的问题和例题7.1中管理名字-密码的键值对数据的程序有关。<br>(a) 修改那个脚本，使它能记录用户上次的登录日期和时间（使用time模块），并与用户密码一起保存起来。程序的界面有要求用户输入用户名和密码的提示。无论用户名是否成功登录，都应用提示，在用户名成功登录后，应更新相应用户的上次登录时间戳。如果一次登录与上次登录在时间上相差不超过4个小时，则通知该用户：“You already logged in at: <code>&lt;last_login_timestamp&gt;</code>。”<br>(b) 添加一个“管理”菜单，其中有以下两项：（1）删除一个用户  （2）显示系统中所有用户的名字和他们的密码的清单<br>(c) 口令目前没有加密。请添加一段对口令加密的代码（请参考crypt、rotor或其他加密模块）。<br>(d) 为程序添加图形界面，例如，用Tkinter写<br>(e) 要求用户名不区分大小写。<br>(f) 加强对用户名的限制，不允许符号和空白符。<br>(g) 合并“新用户”和“老用户”两个选项。如果一个新用户试图用一个不存在的用户名登录。询问该用户是否是新用户，如果回答是肯定的，就创建该账户。否则，按照老用户的方式登录。<br><br>7-6. 列表和字典。创建一个简单的股票证券投资数据系统。其中应至少包含4项数据：股市行情显示器符号、所持有的股票、购买价格及当前价位–你可以随意添加其他数据项，比如收益率，52周最高指数、最低指数，等等。<br>所有行的数据。数据输入完毕后，提示用户选择一列数据项进行排序。把该数据项抽取出来作为字典的键，字典的值就是该健对应行的值的列表。提醒读者：被选择用来排序的数据项必须是非重复的键，否则就会丢失数据，因为字典不允许一个键有多个值。你还可以选择其他计算输出，比如盈亏比率、目前证券资资产价值等。</p>
<p><br>7-7. 颠倒字典中的键和值。用一个字典做输入，输出另一个字典，用前者的键做值，前者的值做键。</p>
<p><br>7-8. 人力资源。创建一个简单的雇员姓名和编号的程序，让用户输入一组雇员姓名和编号。你的程序可以提供按照姓名排序输出的功能，雇员姓名显示在前面，后面是对应的雇员编号。附加题：添加一项功能，按照雇员编号的顺序输出数据。</p>
<p><br>7-9. 翻译。<br>(a) 编写一个字行翻译程序（功能类似于Unix中的tr命令）。我们将这个函数叫做tr()，它有三个字符串做参数：源字符串、目的字符串、基本字符串，语法定义如下：<code>def tr(srcstr, dststr, string)</code>，srcstr的内容是你打算“翻译”的字符集合，dsrstr是翻译后得到的字符集合，而string是你打算进行翻译操作的字符串。举例来说，如果srcstr &#x3D;&#x3D; ‘abc’，dststr &#x3D;&#x3D; ‘mno’，string &#x3D;&#x3D; ‘abcdef’，那么tr()的输出将是’mnodef’。注意这里len(srcstr) &#x3D;&#x3D; len(dststr)。在这个练习里，你可以使用内建函数chr()和ord()，但它们并不一定是解决这个问题所必不可少的函数。<br>(b) 在这个函数晨增加一个标志参数，来处理不区分大小写的翻译问题。<br>(c) 修改你的程序，使它能够处理删除字符的操作。字符串srcstr中不能够映射到字符串dststr中字符的多余字符都被过滤掉。换句话说，这些字符没有映射到dststr字符串中的任何字符，因此就从函数返回的字符里被过滤掉了。举例来说：如果scrstr &#x3D;&#x3D; ‘abcdef’, dststr &#x3D;&#x3D; ‘mno’, string &#x3D;&#x3D; ‘abcdefghi’，那么tr()将输出’mnoghi’。注意这里len(srcstr) &gt;&#x3D; len(dststr)。</p>
<p><br>7-10. 加密。<br>(a) 用上一个练习的思路编写一个“rot13”翻译器。“rot13”是一个古老而又简单的加密方法，它把字母表中的每个字母用其后的第13个字母来代替。字母表中前半部分字母将被映像到后半部分，而后半部分字母将被映像到前半部分，大小写保持不变。举例来说，’a’将被替换为’n’,’X’将被替换为’K’；数字和符号不进行翻译。<br>(b) 在你的解决方案的基础上加一个应用程序，让它提示用户输入准备加密的字符串（这个算法同时也可以对加密后的字符串进行解密），如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">% rot13.py</span><br><span class="line">Enter string to rot13: This <span class="keyword">is</span> a short sentence.</span><br><span class="line">Your string to en/decrypt was: [This <span class="keyword">is</span> a short sentence.].</span><br><span class="line">The rot13 string <span class="keyword">is</span>: [Guvf vf n fubeg fragrapr.].</span><br><span class="line">%</span><br><span class="line">% rot13.py</span><br><span class="line">Enter string to rot13: Guvf vf n fubeg fragrapr.</span><br><span class="line">Your string to en/decrypt was: [Guvf vf n fubegfragrapr.].</span><br><span class="line">The rot13 string <span class="keyword">is</span>: [This <span class="keyword">is</span> a short sentence.].</span><br></pre></td></tr></table></figure>
<p><br>7-11. 定义。什么组成字典中合法的键？举例说明字典中合法的键和非法的键。<br><br>7-12. 定义。(a)在数学上，什么是集合？(b)在Python中，关于集合类型的定义是什么？<br><br>7-13. 随机数。修改练习5-17的代码，使用random模块中的randint()或randrange()方法生成一个随机数集合，从0到9(包括9)中随机选择，生成1~10个随机数。这些数字组成集合A（A可以是可变集合，也可以不是）。同理，按此方法生成集合B。每次新生成集合A和B后，显示结果<code>A|B 和 A&amp;B</code><br><br>7-14. 用户验证。修改前面的练习，要求用户输入<code>A|B 和 A&amp;B</code>的结果，并告诉用户他（或她）的答案是否正确，而不是将<code>A|B 和 A&amp;B</code>的结果直接显示出来。如果用户回答错误，允许好（或她）修改解决方案，然后重新验证用户输入的答案。如果用户三次提交的答案均不正确，程序将显示正确的结果。附加题：运用你关于集合的知识，创建某个集合的潜在子集，并询问用户此潜在子集是否真是该集合的子集，要求和主程序一样有显示更正和答案的功能。<br><br>7-15. 编写计算器。这个练习取材于<br><a href="http://math.hws.edu/">http://math.hws.edu/</a> 在线免费java教材中的练习12.2。编写一个程序允许用户选择两个集合：A和B，及运算操作符。例如<code>in、not in 、&amp;、|、^、&lt;、&lt;=、&gt;、&gt;=、==、！=</code>等。（你自己定义集合的输入语法，它们并不一定要像java示例中那样用方括号括住。）解析输入的字符串，按照用户选择的运算进行操作。你写的程序代码应该比java该程序的版本更简洁。</p>
<h1 id="条件和循环"><a href="#条件和循环" class="headerlink" title="条件和循环"></a>条件和循环</h1><div class="note primary"><ul>
<li>if语句</li>
<li>else语句</li>
<li>elif语句</li>
<li>条件表达式</li>
<li>while语句</li>
<li>for语句</li>
<li>continue语句</li>
<li>pass语句</li>
<li>else语句（两次述及）</li>
<li>Interators迭代器</li>
<li>列表解析</li>
<li>生成器表达式</li>
</ul>
</div>
<p>本章的主要内容是Python的条件和循环语句以及与它们相关的部分。我们会深入探讨if、while、for及与他们相搭配的else、elif、break、continue和pass语句。</p>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>Python中的if子句看起来十分熟悉。它由三部分组成：关键字本身，用于判断结果真假的条件表达式，以及当表达式为真或者非零时执行的代码块。</p>
<p>if语句的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">    expr_true_suite</span><br></pre></td></tr></table></figure>
<p>if语句的expr_true_suite代码块只有在条件表达式的结果的布尔值为真时才执行，否则将继续执行紧跟在该代码块后面的语句。</p>
<h3 id="多重条件表达式"><a href="#多重条件表达式" class="headerlink" title="多重条件表达式"></a>多重条件表达式</h3><p>单个if语句可以通过使用布尔操作符and、or和not实现多重判断条件或是否定判断条件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> warn <span class="keyword">and</span> (system_load &gt;= <span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;WARNING: losing resources&quot;</span></span><br><span class="line">    warn += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="单一语句的代码块"><a href="#单一语句的代码块" class="headerlink" title="单一语句的代码块"></a>单一语句的代码块</h3><p>如果一个复合语句（例好if子句，while或for循环）的代码块仅仅包含一行代码，那么它可以和前面的语句写在同一行上：<br><code>if make_hard_copy: send_data__to_printer()</code><br>上边这样的单行语句是合法的，尽管它可能方便，但这样会使得代码更难阅读，所以我们推荐将这行代码移到下一行并合理地缩进。另外一个原因就是如果你需要添加新的代码，你还是得把它移到下一行。</p>
<h2 id="else语句"><a href="#else语句" class="headerlink" title="else语句"></a>else语句</h2><p>和其他语言一样，Python提供了与if语句搭配使用的else语句。如果if语句的条件表达式的结果布尔值为假，那么程序将执行else语句后的代码。它的语法你甚至可以猜到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">    expr_true_suite</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    expr_false_suite</span><br></pre></td></tr></table></figure>
<p>这里是样例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> passwd == user.passwd:</span><br><span class="line">    ret_str = <span class="string">&quot;password accepted&quot;</span></span><br><span class="line">    <span class="built_in">id</span> = user.<span class="built_in">id</span></span><br><span class="line">    valid = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ret_str = <span class="string">&quot;invalid password entered... try again!&quot;</span></span><br><span class="line">    valid = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>避免“悬挂else”<br>Python使用缩进而不是用大括号标记代码块边界的设计，不仅帮助强化了代码的正确性，而且还暗中帮助程序员避免了语法上正确的代码中存在潜在的问题。其中一个问题就是（臭名）昭著的“悬挂else”问题，一种语义错觉。</p>
<p>我们在这里给出一段C代码来说明我们的例子（K&amp;R和其他的编程教材也给出过）（这里的K&amp;R是指由Brian W.Kernighan 和 Dennis M.Ritchie合著的《C程序设计语言》，译者注）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*C语言中的悬挂else*/</span></span><br><span class="line"><span class="keyword">if</span> (balance &gt; <span class="number">0.00</span>)</span><br><span class="line">    <span class="keyword">if</span> (((balance - amt) &gt; main_bal) &amp;&amp; (atm_cashout() == <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s your cash; please take all bills.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Your balance is zero or negative.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>问题是else属于哪个if？在C语言中，规则是else与最近的if搭配。所以我们上面的例子中，else虽然是想和外层的if搭配，但是事实上else属于内部的if，因为C编译器会忽略额外的空白。结果，如果你的balance是正数但小于最小值，你将得到错误的输出，程序会显示你的balance是零或者为负数。</p>
<p>由于这个例子很简单，所以解决这个问题并不难，但是如果是大块的代码嵌入到了类似这样的框架中，那么发现并改正程序中的错误需要耗费很多精力。Python设置的护栏不仅阻止你掉下悬崖，而且会带你离开危险的境地。在Python中相同的例子对应如下的两种代码（只有一种是正确的）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> balance &gt; <span class="number">0.00</span>:</span><br><span class="line">    <span class="keyword">if</span> balance - amt &gt; min_bal <span class="keyword">and</span>  atm_cashout():</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Here&#x27;s your cash; please take all bills.&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Your balance is zero or negative.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>或者是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> balance &gt; <span class="number">0.00</span>:</span><br><span class="line">    <span class="keyword">if</span> balance - amt &gt; min_bal <span class="keyword">and</span> atm_cashout():</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Here&#x27;s your cash; please take all bille.&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Your balance is zero or negative.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Python的缩进使用强制使代码正确对齐，让程序员来决定else属于哪一个if。限制你的选择从而减少了不确定性，Python鼓励你第一次就写出正确的代码。在Python中制造出“悬挂else”问题是不可能的。而且，由于不再命名用大括号，Python代码变得更易读懂。</p>
<h2 id="elif（即else-if）语句"><a href="#elif（即else-if）语句" class="headerlink" title="elif（即else-if）语句"></a>elif（即else-if）语句</h2><p>elif是Python的else-if语句，它检查多个表达式是否为真，并在为真时执行特定代码块中的代码。和else一样，elif声明是可选的，然而不同的是，if语句后最多的只能有一个else语句，但可以有任意数量的elif语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression1:</span><br><span class="line">    expr1_true_suite</span><br><span class="line"><span class="keyword">elif</span> expreesion2:</span><br><span class="line">    expr2_true_suite</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line"><span class="keyword">elif</span> expressionN:</span><br><span class="line">    exprN_true_suite</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    none_of_the_above_suite</span><br></pre></td></tr></table></figure>
<p>switch&#x2F;case 语句的替代品么？<br>在将来的某天，Python可能会支持switch&#x2F;case语句，但是你完全可以用其他的Python结构来模拟它。在Python中，大量的if-elif语句并不难阅读：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> user.cmd == <span class="string">&#x27;create&#x27;</span>:</span><br><span class="line">    action = <span class="string">&quot;create item&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> user.cmd == <span class="string">&#x27;delete&#x27;</span>:</span><br><span class="line">    action = <span class="string">&#x27;delete item&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> user.cmd == <span class="string">&#x27;update&#x27;</span>:</span><br><span class="line">    action = <span class="string">&#x27;update item&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    action = <span class="string">&#x27;invalid choice... try again!&#x27;</span></span><br></pre></td></tr></table></figure>
<p>另外我们可以用Python字典给出更加优雅的解决方案，我们将在第7章中介绍字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msgs = &#123;<span class="string">&#x27;create&#x27;</span>: <span class="string">&#x27;create item&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;delete&#x27;</span>: <span class="string">&#x27;delete item&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;update&#x27;</span>: <span class="string">&#x27;update item&#x27;</span>&#125;</span><br><span class="line">default = <span class="string">&#x27;invalid choice... try again!&#x27;</span></span><br><span class="line">action = msgs.get(user.cmd, default)</span><br></pre></td></tr></table></figure>
<p>众所周知，使用映射对象（比如字典）的一个最大好处就是它的搜索操作比类似<code>if-elif-else</code>语句或是for循环这样的序列查询要快很多。</p>
<h2 id="条件表达式（即“三元操作符”）"><a href="#条件表达式（即“三元操作符”）" class="headerlink" title="条件表达式（即“三元操作符”）"></a>条件表达式（即“三元操作符”）</h2><p>如果你来自C&#x2F;C++或者是java世界，那么你很难忽略的一个事实就是Python在很长的一段时间里没有条件表达式（C?X:Y），或称三元操作符。（C是条件表达式：X是C为True时的结果，Y是C为False时的结果）Guido Van Rossum一直拒绝加入这样的功能，因为他认为应该保持代码简单，让程序员不轻易出错。不过在十年多后，他放弃了，主要是因为人们试着用and和or来模拟它，但大多都是错误的。根据《FAQ》，正确的方法（并不唯一）是（C and [X] or [Y]）[0]。唯一的问题是社区不同意这样的语法。（你可以看一看PEP308，其中有不同的方案）。对于Python的这一个问题，人们表达了极大的诉求。</p>
<p>Guido Van Rossum最终选择了一个最被看好（也是他最喜欢）的方案，然后把它运用于标准库中的一些模块。根据PEP，“这个评审通过考察大量现实世界的案例，包含不同的应用，以及由不同程序员完成的代码。”最后Python2.5集成的语法确定为：X if C else Y。</p>
<p>有了三元操作符后你就只需要一行完成条件判断和赋值操作，而不需要像下面例子中的min()那样，使用if-else语句实现对数字x和y的操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = <span class="number">4</span>, <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> x &lt; y :</span><br><span class="line"><span class="meta">... </span>    smaller = x</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    smller = y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>smaller</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>在2.5以前的版本中，Python程序员最多这样做（其实是一个hack，译者注）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>smaller = (x &lt; y <span class="keyword">and</span> [x] <span class="keyword">or</span> [y])[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>smaller</span><br></pre></td></tr></table></figure>
<p>在2.5和更新的版本中，你可以使用更简明的条件表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span> smaller = x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> smaller</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>Python的while是本章我们遇到的第一个循环语句。事实它是一个条件循环语句。与if声明相比，如果if后的条件为真，就会执行一次相应的代码块。而while中的代码块会一直循环执行，直到循环条件不再为真。</p>
<h3 id="一般语法"><a href="#一般语法" class="headerlink" title="一般语法"></a>一般语法</h3><p>while循环的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> expression:</span><br><span class="line">    suite_to_repeat</span><br></pre></td></tr></table></figure>
<p>while循环suite_to_repeat子句会一直循环执行，直到expression值为布尔假。这种类型的循环机制常常用在计数循环中，请参见下节中例子。</p>
<h3 id="计数循环"><a href="#计数循环" class="headerlink" title="计数循环"></a>计数循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">9</span> ):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;the index is:&#x27;</span>, count</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这里的代码块里包含了print和自增语句，它们被重复执行，真到count不再小于9。索引count在每次迭代时被打印出来然后自增1。如果在python解释器中输入这些代码我们将得到这样的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>count = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> (count &lt; <span class="number">9</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;the index is:&#x27;</span>, count</span><br><span class="line"><span class="meta">... </span>    count += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">the index <span class="keyword">is</span> : <span class="number">0</span></span><br><span class="line">the index <span class="keyword">is</span> : <span class="number">1</span></span><br><span class="line">the index <span class="keyword">is</span> : <span class="number">2</span></span><br><span class="line">the index <span class="keyword">is</span> : <span class="number">3</span></span><br><span class="line">the index <span class="keyword">is</span> : <span class="number">4</span></span><br><span class="line">the index <span class="keyword">is</span> : <span class="number">5</span></span><br><span class="line">the index <span class="keyword">is</span> : <span class="number">6</span></span><br><span class="line">the index <span class="keyword">is</span> : <span class="number">7</span></span><br><span class="line">the index <span class="keyword">is</span> : <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>你必须小心地使用while循环，因为有可能condition永远不会为布尔假。这样一来循环就永远不会结束。这些“无限”的循环不一定是坏事，许多通讯服务器的客户端&#x2F;服务器系统就是通过它来工作的。这取决于循环是否需要一直执行下去，如果不是，那么这个循环是否会结束；也就是条件表达式会不会计算后得到布尔假？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    handle, indata = wait_fro_client_connect()</span><br><span class="line">    outdata = process_request(indata)</span><br><span class="line">    ack_result_to_client(handle, outdata)</span><br></pre></td></tr></table></figure>
<p>例如上边的代码就是故意被设置为无限循环的，因为True无论如何都不会变成False。这是因为服务器代码是用来等待客户端（可能通过网络）来连接。这些客户端向服务器发送请求，服务器处理请求。<br>请求被处理后，服务器将向客户端返回数据，而此时客户端可能断开连接或是发送另一个请求。对于服务器而言它已经完成了对这个客户端的任务，它会返回最外层循环等待下一个连接。</p>
<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>Python提供给我们的另一个循环机制就是for语句。它提供了Python中最强大的循环结构。它可以遍历序列成员，可以用在列表解析和生成器表达式中，它会自动地调用迭代器的next()方法，捕获StopIteration异常并结束循环（所有这一切都是在内部发生的）。如果你刚刚接触Python那么我们要告诉你，在以后你会经常用到它的。和传统语言（例如C&#x2F;C++，Fortran或者Java）中的for语句不同，Python的for更像是shell或是脚本语言中的foreach循环。</p>
<h3 id="一般语法-1"><a href="#一般语法-1" class="headerlink" title="一般语法"></a>一般语法</h3><p>for循环会访部一个可迭代对象（例珆序列或是迭代器）中的所有元素，并在所有条目都处理过后结束循环，它的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable:</span><br><span class="line">    suite_to_repeat</span><br></pre></td></tr></table></figure>
<p>每次循环，iter_var迭代变量被设置为可迭代对象（序列、迭代器或其他支持迭代的对象）的当前元素，提供给suite_to_repeat语句块使用。</p>
<h3 id="用于序列类型"><a href="#用于序列类型" class="headerlink" title="用于序列类型"></a>用于序列类型</h3><p>本节中，我们将学习用for循环迭代不同的序列对象。样例将涵盖字符串、列表及元组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> eachLetter <span class="keyword">in</span> <span class="string">&#x27;Names&#x27;</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;Current Letter:&#x27;</span>, eachLetter</span><br><span class="line">Current Letter: N</span><br><span class="line">Current Letter: a</span><br><span class="line">Current Letter: m</span><br><span class="line">Current Letter: e</span><br><span class="line">Current Letter: s</span><br></pre></td></tr></table></figure>
<p>当迭代字符串时，迭代变量只会包含一个字符（长度为1的字符串）。但这并不常用。在字符串里查找字符时，程序员往往使用in来测试成员关系，或者使用string模块中的函数测以及字符串方法来检查子字符串。</p>
<p>看到单个字符在一种情况下有用，即在通过print语句调试for循环中的序列时，如果你在应该看到字符串的地方发现的却是单个字符，那么很有可能你接受到的是一个字符串，而不是对象的序列。</p>
<p>迭代序弄有三种基本方法：<br><br/><span style="font-weight: bolder;">1. 通过序列项迭代</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nameList = [<span class="string">&#x27;Walter&#x27;</span>, <span class="string">&#x27;Nicole&#x27;</span>, <span class="string">&#x27;Steven&#x27;</span>, <span class="string">&#x27;Henry&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> eachName <span class="keyword">in</span> nameList:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> eachName, <span class="string">&quot;Lim&quot;</span></span><br><span class="line">Walter Lim</span><br><span class="line">Nicole Lim</span><br><span class="line">Steven Lim</span><br><span class="line">Henry Lim</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们迭代一个列表。每次迭代，eacgName变量都被设置为例表中特定某个元素，然后我们在代码块中打印出这个变量。<br><br/><span style="font-weight: bolder;">2. 通过序列索引迭代</span><br>另一个方法就是通过序列的索引来迭代：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nameList = [<span class="string">&#x27;Cathy&#x27;</span>, <span class="string">&quot;Terry&quot;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Heather&#x27;</span>, <span class="string">&#x27;Lucy&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> nameIndex <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nameList)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&quot;Liu,&quot;</span>, nameList[nameIndex]</span><br><span class="line">Liu Cathy</span><br><span class="line">Liu Terry</span><br><span class="line">Liu Joe</span><br><span class="line">Liu Heather</span><br><span class="line">Liu Lucy </span><br></pre></td></tr></table></figure>
<p>我们没有迭代元素，而是通过列表的索引迭代。<br>这里我们使用了内建的len()函数获得序列长度，使用range()函数（我们将在下面详细讨论它）创建了要迭代的序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(nameList)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="built_in">len</span>(nameList))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>使用range()我们可以得到用来迭代nameList的索引数列表；使用切片&#x2F;下标操作符就可以访问对应的序列对象。</p>
<p>如果你对性能有所了解的话，那么毫无疑问你会意识到直接迭代序列要比通过索引迭代快。<br><br/><span style="font-weight: bolder;">3. 使用项和索引迭代</span><br>两全其美的办法是使用内建的enumerate()函数，它是Python2.3的新增内容。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nameList = [<span class="string">&#x27;Donn&#x27;</span>, <span class="string">&#x27;Shirley&#x27;</span>, <span class="string">&#x27;Ben&#x27;</span>, <span class="string">&#x27;Janice&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Yen&#x27;</span>, <span class="string">&#x27;Wendy&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, eachLee <span class="keyword">in</span> <span class="built_in">enumerate</span>(nameList):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&quot;%d %s Lee&quot;</span> % (i+<span class="number">1</span>, eachLee)</span><br><span class="line"><span class="number">1</span> Donn Lee</span><br><span class="line"><span class="number">2</span> Shirley Lee</span><br><span class="line"><span class="number">3</span> Ben Lee</span><br><span class="line"><span class="number">4</span> Janice Lee</span><br><span class="line"><span class="number">5</span> David Lee</span><br><span class="line"><span class="number">6</span> Yen Lee</span><br><span class="line"><span class="number">7</span> Wendy Lee </span><br></pre></td></tr></table></figure>

<h3 id="用于迭代器类型"><a href="#用于迭代器类型" class="headerlink" title="用于迭代器类型"></a>用于迭代器类型</h3><p>用for循环访问序列的方法差不多。唯一的区别就是for语句会为你做一些额外的事情。迭代器并不代表循环条目的集合。</p>
<p>迭代器对象有一个next()方法，调用后近回下一个条目。所有条目迭代完后，迭代器引发一个StopIterationn异常告诉程序循环结束。for语句在内部调用next()并捕获异常。</p>
<p>使用迭代器做for循环的代码与使用序列条目几乎完全相同，事实上在大多情况下，你无法分辨出你迭代是一个序列还是迭代器，因此，这就是为什么我们在说要遍历一个迭代器时，实际上可能我们指的是要遍历一个序弄，迭代器，或是一个支持迭代的对象（它有next()方法）。</p>
<h3 id="range-内建函数"><a href="#range-内建函数" class="headerlink" title="range()内建函数"></a>range()内建函数</h3><p>我们前面介绍Python的for循环的时候提到过它是一种迭代的循环机制。Python同样提供一个工具让我们在传统的伪条件设置下使用for声明，例如从一个数字开始计数到另一个数字，一旦到达最后的数字或者某个条件不再满足就立刻退出循环。</p>
<p>内建函数range()可以把类似forwach的for循环变成你更加熟悉的语句。例如从0到10计数，或者从10到100一次递增5。</p>
<p><span style="font-weight: bolder;">range()的完整语法</span></p>
<p>Python提供了两种不同的方法来调用range()。完整语法要求提供两个或三个整型参数：<br><code>range(start, end, step = 1)</code><br>range()会返回一个包含所有k的列表，这里start &lt;&#x3D; k &lt; end，从strart到end，k每次递增step。step不可以为零，否则将发生错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">2</span>, <span class="number">19</span>, <span class="number">3</span>)</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">17</span>]</span><br></pre></td></tr></table></figure>
<p>如果只给定两个参数，而省略step，step就使用默认值1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>我们来看看解释器环境下的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> eachVal <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">19</span>, <span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&quot;value is:&quot;</span>, eachVal</span><br><span class="line">...</span><br><span class="line">value <span class="keyword">is</span> : <span class="number">2</span></span><br><span class="line">value <span class="keyword">is</span> : <span class="number">5</span></span><br><span class="line">value <span class="keyword">is</span> : <span class="number">8</span></span><br><span class="line">value <span class="keyword">is</span> : <span class="number">11</span></span><br><span class="line">value <span class="keyword">is</span> : <span class="number">14</span></span><br><span class="line">value <span class="keyword">is</span> : <span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>我们的循环从2“数”到19，每次递增3。如果你熟悉C的话，就会发现，range()的参数与C的for循环变量有着直接的关系：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* equivalent loop in C */</span></span><br><span class="line"><span class="keyword">for</span> (eachVal = <span class="number">2</span>; eachVal &lt; <span class="number">19</span>; eachVal += <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value is: %d\n&quot;</span>, eachVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然看起来像是一个条件循环（检查eachVal&lt;19），但实际上是range()先用我们指定的条件生成一个列表，然后把列表用于这个for语句。<br>range()简略语法<br>range()还有两种简略的语法格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(end)</span><br><span class="line"><span class="built_in">range</span>(start, end)</span><br></pre></td></tr></table></figure>
<p>我们在第2章看到过最短的语法接受一个值，start默认为0，step默认为1，然后range()返回从0到end的数列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>range()的中型版本和完整版本几乎完全一样，只是step使用默认值1。现在我们在Python解释器中试下这条语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> count <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> count</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> </span><br></pre></td></tr></table></figure>
<div class="note primary"><p><span style="font-weight: bolder;">核心笔记：为什么range()不是只有一种语法？</span><hr/><br>你已经知道了range()的所有语法，有些人可能会问一个挑剔的问题，为什么不把这两种语法合并成为一个下面这样的语法？<br><code>range(start=0, end, step =1) # invalid</code><br>这个语法不可以使用两个参数调用。因为step要求给定start。换句话说，你不能只传递end和step参数。因为它们会被解释器误认为是start和end。</p>
</div>

<h3 id="xrange-内建函数"><a href="#xrange-内建函数" class="headerlink" title="xrange()内建函数"></a>xrange()内建函数</h3><p>xrange()类似range()，不过当你有一个很大的范围列表时，xrange()可能更为适合，因为它不会在内存里创建列表的完整拷贝。它只被用在for循环中，在for循环外使用它没有意义。同样地，你可以想到，它的性能远高出range()，因为它不生成整个列表。在Python的未来版本中，range()可能会像xrange()一样，返回一个可迭代对象（不是列表也不是一个迭代器）。</p>
<h3 id="与序列相关的内建函数"><a href="#与序列相关的内建函数" class="headerlink" title="与序列相关的内建函数"></a>与序列相关的内建函数</h3><p>sorted()，reversed()、enumerate()、zip()<br>下边是使用循环相关和序列相关函数的例子。为什么它们叫“序弄相关”呢？是因为其中两个函数（sorted()和zip()）返回一个序型（列表），而另外两个函数（reversed()和enumerate()）返回迭代器（类似序列）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>albums = (<span class="string">&#x27;Poe&#x27;</span>, <span class="string">&#x27;Gaudi&#x27;</span>, <span class="string">&#x27;Freud&#x27;</span>, <span class="string">&#x27;Poe2&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>years = (<span class="number">1976</span>, <span class="number">1978</span>, <span class="number">1990</span>, <span class="number">2003</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> album <span class="keyword">in</span> <span class="built_in">sorted</span>(albums):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> album, </span><br><span class="line">...</span><br><span class="line">Freud Gaudi Poe Poe2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> album <span class="keyword">in</span> <span class="built_in">reversed</span>(albums):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> album, </span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Poe2 Freud Gaudi Poe</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, album <span class="keyword">in</span> <span class="built_in">enumerate</span>(albums):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> i, album</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> Poe</span><br><span class="line"><span class="number">1</span> Gaudi</span><br><span class="line"><span class="number">2</span> Freud</span><br><span class="line"><span class="number">3</span> Poe2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> album, yr <span class="keyword">in</span> <span class="built_in">zip</span>(albums, years):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> yr, album</span><br><span class="line">...</span><br><span class="line"><span class="number">1976</span> Poe</span><br><span class="line"><span class="number">1987</span> Gaudi</span><br><span class="line"><span class="number">1990</span> Freud</span><br><span class="line"><span class="number">2003</span> Poe2</span><br></pre></td></tr></table></figure>
<p>我们已经涵盖了Python中的所有循环语句，下面我们看看循环相关的语句，包括用于放弃循环的break语句和立即开始下一次迭代的continue语句。</p>
<h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><p>Python中的break语句可以结束当前循环然后跳转到下条语句，类似C中的传统break。常用在当某个外部条件被触发（一般通过if语句检查），需要立即从循环中退出时break语句可以用在while和for循环中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count  = num / <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> count &gt; <span class="number">0</span> :</span><br><span class="line">    <span class="keyword">if</span> num % count == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> count, <span class="string">&#x27;is the largest factor of&#x27;</span>, num</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    count -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上边这段代码用于寻找给定数字num的最大约数。我们迭代所有可能的约数，count变量依次递减，第一个能整除num的就是我们要找的最大约数，找到后就不再继续找了，使用break语句退出循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phone2remove = <span class="string">&#x27;555-1212&#x27;</span></span><br><span class="line"><span class="keyword">for</span> eachPhone <span class="keyword">in</span> phoneList:</span><br><span class="line">    <span class="keyword">if</span> eachPhone == phone2remove:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;found&quot;</span>, phone2remove, <span class="string">&#x27;...deleting&#x27;</span></span><br><span class="line">        deleteFromPhoneDB(phone2remove)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的break语句用于打断列表的迭代，目的是为了找到列表中的目标元素，如果找到，则把它从数据库里删除然后退出循环。</p>
<h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><div class="note primary"><p><span style="font-weight: bolder;">核心笔记：continue语句</span><hr/><br>不管是对Python、C、Java，还是其他任何支持continue语句的结构化语言，一些初学者有这样的一个误解：continue语句“立即启动循环的下一次迭代”。实际上，当遇到continue语句时，程序会终止当前循环，并忽略剩余的语句，然后回到循环的顶端。在开始下一次迭代前，如果是条件循环，我们将验证条件表达式；如果是迭代循环，我们将验证是否还有元素可以迭代，只有在验证成功的情况下，我们才会开始下一次迭代。</p>
</div>

<p>Python里的continue语句和其他高级语言中的传统continue并没有什么不同。它可以被用在while和for循环里。while循环是条件性的，而for循环是迭代的，所以continue在开始下一次循环前要满足一些先决条件（前边的核心笔记中强调的），否则循环会正常结束。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">valid = <span class="literal">False</span></span><br><span class="line">count = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">input</span> = raw_input(<span class="string">&quot;enter password&quot;</span>)</span><br><span class="line">    <span class="comment"># check for valid passwd</span></span><br><span class="line">    <span class="keyword">for</span> eachPasswd <span class="keyword">in</span> passwdList:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span> == eachPasswd:</span><br><span class="line">            valid = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> valid:    <span class="comment">#( or valid == 0 )</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;invalid input&quot;</span></span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>这里例子结合使用了whild、for、if、break和continue，用来验证用户输入。用户有三次机会来输入正确的密码，如果失败，那么valid变量将仍为一个布尔假（0），然后我们可以采取必要的操作阻止用户猜测密码。</p>
<h2 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h2><p>Python还提供了pass语句（C中没有提供对应的语句）。Python没有使用传统的大括号来标记代码块，有时，有些地方在语法上要求要有代码，而Python中没有对应的空大括号或是分号（；）来表示C语言中的“不做任何事“，如果你在需要在有语句块的地方不写任何语句，解释器会提示你语法错误。因此，Python提供了pass语句，它不做任何事情–即NOP，（No Operation，无操作）我们从汇编语言中供用这个概念。pass同样也可作为开发中的小技巧，标记你后来要完成的代码，例如这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo_func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>或是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> user_choice == <span class="string">&#x27;do_calc&#x27;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这样的代码结构在开发和调试时很有用，因为编写代码的时候你可能要先把结构定下来，但你不希望它干扰其他已经完成的代码。在不需要它做任何事情地方，放一个pass将是一个很好的主意。</p>
<p>另外它在异常处理中也被经常用到，我们将在第10章中详细介绍：比如你跟踪到了一个非致命的错误，不想采取任何措施（只是想记录一下事件或是在内部进行处理罢了）。</p>
<h2 id="else语句（再看）"><a href="#else语句（再看）" class="headerlink" title="else语句（再看）"></a>else语句（再看）</h2><p>在C（以及大多其他语言中），你不会在条件语句范围外发现else语句，但Python不同，你可以在while和for循环中使用else语句。它们是怎么工作的呢？在循环中使用时，else子句只在循环完成后执行，也就是说break语句也会跳过else块。</p>
<p>展示while语句中else用法的一个例子就是寻找一个数的最大约数。我们已经实现了完成这个任务的函数，使用while循环和else语句。例8.1(maxFact.py)利用这个语法完成了showMaxFactor()函数。<br><br/><span style="font-weight: bolder;">例8.1 while-else循环举例（maxFact.py）</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/user/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showMaxFactor</span>(<span class="params">num</span>):</span><br><span class="line">    count = num / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> count &gt; <span class="number">1</span> :</span><br><span class="line">        <span class="keyword">if</span> num % count == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;largest factor of %d is %d&#x27;</span> % (num, count)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> num, <span class="string">&#x27;is prime&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> eachNum <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">21</span>):</span><br><span class="line">    showMaxFactor(eachNum)</span><br></pre></td></tr></table></figure>
<p>这个程序显示出10～20中的数字的最大约数。该脚本也会提示这个数是滞为素数。<br>showMaxFactor()函数中第3行的循环从amount的一半开始计数（这样就可以检查这个数是否可以被2整除，如果可以，那就找到了最大的约数）。然后循环每次递减1（第10行），真到发现约数（第6～9行）。如果循环递减到1还没有找到约数，那么这个数一定是素数。11～12行的else子句负责处理这样的情况。程序的主体（14～15行）用数字参数调用showMaxFactor()。执行该程序将得到这样的输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">largest factor of <span class="number">10</span> <span class="keyword">is</span> <span class="number">5</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">is</span> prime</span><br><span class="line">largest factor of <span class="number">12</span> <span class="keyword">is</span> <span class="number">6</span></span><br><span class="line"><span class="number">13</span> <span class="keyword">is</span> prime</span><br><span class="line">largest factor of <span class="number">14</span> <span class="keyword">is</span> <span class="number">7</span></span><br><span class="line">largest factor of <span class="number">15</span> <span class="keyword">is</span> <span class="number">5</span></span><br><span class="line">largest factor of <span class="number">16</span> <span class="keyword">is</span> <span class="number">8</span></span><br><span class="line"><span class="number">17</span> <span class="keyword">is</span> prime</span><br><span class="line">largest factor of <span class="number">18</span> <span class="keyword">is</span> <span class="number">9</span></span><br><span class="line"><span class="number">19</span> <span class="keyword">is</span> prime</span><br><span class="line">largest factor of <span class="number">20</span> <span class="keyword">is</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>同样地，for循环也可以有else用于循环后结果（post-processing）。它和while循环中的else处理方式相同。只要for循环是正常结束的（不是通过break），else子句就会执行，如下例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>,<span class="number">90</span>,-<span class="number">1</span>):</span><br><span class="line">    x = sqrt(x)</span><br><span class="line">    <span class="keyword">if</span> x == <span class="built_in">int</span>(root):</span><br><span class="line">        <span class="built_in">print</span> n </span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Didn&#x27;t find it!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在for循环完整完成后才执行else；如果中途从break跳出，则连else一起跳出。</p>
<p><span style="font-weight: bolder;">表8.1  条件及循环语句中的辅助语句总结</span></p>
<table>
<thead>
<tr>
<th>循环和条件语句</th>
<th align="center">if</th>
<th align="center">while</th>
<th align="center">for</th>
</tr>
</thead>
<tbody><tr>
<td>elif</td>
<td align="center">●</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>else</td>
<td align="center">●</td>
<td align="center">●</td>
<td align="center">●</td>
</tr>
<tr>
<td>break</td>
<td align="center"></td>
<td align="center">●</td>
<td align="center">●</td>
</tr>
<tr>
<td>continue</td>
<td align="center"></td>
<td align="center">●</td>
<td align="center">●</td>
</tr>
<tr>
<td>pass</td>
<td align="center">●</td>
<td align="center">●</td>
<td align="center">●</td>
</tr>
</tbody></table>
<h2 id="迭代器和iter-函数"><a href="#迭代器和iter-函数" class="headerlink" title="迭代器和iter()函数"></a>迭代器和iter()函数</h2><h3 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h3><p>迭代器是在版本2.2被加入Python的，它为类序列对象提供了一个类序弄的接口。我们在前边的第6章已经正式地介绍过序列。它们是一组数据结构，你可以利用它们的索引从0开始一直“迭代”到序弄的最后一个条目。用“计数”的方法迭代序列是很简单的。Python的迭代无缝地支持序列对象，而且它还允许程序员迭代非序列类型，包括用户定义的对象。</p>
<p>迭代器用起来很灵巧，你可以迭代不是序列但表现出序列行为的对象，例如字典的键、一个文件的行等等。当你使用循环迭代一个对象条目时，你几乎分辨不出它是迭代器还是序列。你不必去关注这些，因为Python让它像一个序列那样操作。</p>
<h3 id="为什么要迭代器"><a href="#为什么要迭代器" class="headerlink" title="为什么要迭代器"></a>为什么要迭代器</h3><p>引用PEP（234）中对迭代器的定义：</p>
<ul>
<li>提供了可扩展的迭代器接口；</li>
<li>对列表迭代带来了性能上的增强；</li>
<li>在字典迭代中性能提升；</li>
<li>创建真正的迭代接口，而不是原来的随机对象访问：</li>
<li>与所有已经存在的用户定义的类以及扩展的模拟序列和映射的对象向后兼容；</li>
<li>迭代非序列集合（例如映射和文件）时，可以创建更简洁可读的代码。</li>
</ul>
<h3 id="如可迭代"><a href="#如可迭代" class="headerlink" title="如可迭代"></a>如可迭代</h3><p>根本上说，迭代器就是有一个next()方法的对象，而不是通过索引来计数。当你或是一个循环机制（例如for语句）需要下一个项时，调用迭代器的next()方法就可以获得它。条目全部取出后，会引发一个StopIteration异常，这并不表示错误发生，只有告诉外部调用者，迭代完成。</p>
<p>不过，迭代器也有一些限制。例如你不能向后移动，不能回到开始，也不能复制一个迭代器。如果你要再次（或者是同时）迭代同个对象，你只能去创建另一个迭代器对象。不过，这并不糟糕，因为还有其他的工具来帮助你使用迭代器。</p>
<p>reversed()内建函数将返回一个反序访问的迭代器。enumerate()内建函数同样也返回迭代器。另外两个新的内建函数，any()和all()，是在Python2.5中新增的，如果迭代器中某个&#x2F;所有条目的值都为布尔值时，则它们返回值为真。本章先前部分我们展示了如何在for循环中通过索引或是可迭代对象来遍历条目。同时Python还提供了一整个itertools模块，它包含各种有用的迭代器。</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p><span style="font-weight: bolder;">1. 序列</span><br>正如先前提到的，迭代Python的序列对象和你想像的一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myTuple = (<span class="number">123</span>, <span class="string">&#x27;xyz&#x27;</span>, <span class="number">45.67</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="built_in">iter</span>(myTuple)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i.<span class="built_in">next</span>()</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i.<span class="built_in">next</span>()</span><br><span class="line"><span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i.<span class="built_in">next</span>()</span><br><span class="line"><span class="number">45.67</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i.<span class="built_in">next</span>()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>如果这是一个实际应用程序，那么我们需要把代码放在一个try-except块中。序列现在会自动地产生它们自己的迭代器，所以一个for循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> seq:</span><br><span class="line">    do_something_to(i)</span><br></pre></td></tr></table></figure>
<p>实际上是这样工作的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fetch = <span class="built_in">iter</span>(seq)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i = fetch.<span class="built_in">next</span>()</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    do_something_to(i)</span><br></pre></td></tr></table></figure>
<p>不过，你不需要改动你的代码，因为for循环会自动调用迭代器的next()方法（以及监视StopIteration异常）。</p>
<p><span style="font-weight: bolder;">2. 字典</span><br>字典和文件是另外两个可迭代的Python数据类型。字典的迭代器会遍历它的键（key）。语句foreachKey in myDict.keys()可以缩写为for eachKey in myDict，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>legends = &#123;(<span class="string">&#x27;Poe&#x27;</span>,<span class="string">&#x27;author&#x27;</span>):(<span class="number">1809</span>, <span class="number">1849</span>, <span class="number">1976</span>), </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>           (<span class="string">&#x27;Gaudi&#x27;</span>,<span class="string">&#x27;architect&#x27;</span>):(<span class="number">1852</span>, <span class="number">1906</span>, <span class="number">1987</span>),</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>           (<span class="string">&#x27;Freud&#x27;</span>,<span class="string">&#x27;psychoanalyst&#x27;</span>):(<span class="number">1856</span>,<span class="number">1939</span>,<span class="number">1990</span>)</span><br><span class="line">...&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> eachLegend <span class="keyword">in</span> legends:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;Name: %s\t0ccupation: %s&#x27;</span> % eachLegend</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;    Birth: %s\tDeath: %s\tAlbum: %s\n&#x27;</span> \</span><br><span class="line"><span class="meta">... </span>    % legends[eachLegend]</span><br><span class="line">...</span><br><span class="line">Name: Freud Occupation:psychoanalyst</span><br><span class="line">  Birth:<span class="number">1856</span>    Death:<span class="number">1939</span>    Album:<span class="number">1990</span></span><br><span class="line">Name: Poe Occupation:author</span><br><span class="line">  Birth:<span class="number">1809</span>    Death：<span class="number">1849</span>   Album：<span class="number">1976</span></span><br><span class="line">Name：Gaudi  Occupation:architect</span><br><span class="line">  Birth:<span class="number">1852</span>    Death:<span class="number">1906</span>    Album:<span class="number">1987</span></span><br></pre></td></tr></table></figure>
<p>另外，Python还引进了三个新的内建字典方法来定义迭代：myDict.iterkeys()（通过键迭代）、myDict.itervalues()（通过值迭代）及myDicit.iteritemds()（通过-值来迭代）。注意，in操作符也可以用于检查字典的键是否存在，之前的布尔表达式myDict.has_key(anyKey)可以被简写为anyKey in myDict。</p>
<p><span style="font-weight: bolder;">3. 文件</span><br>文件对象生成的迭代器会自动调用readline()方法。这样，循环就可以访部文本文件的所有行。程序员可以使用更简单的<code>for eachLine in myFile</code>替换<code>for eachLine in myFile.readlines():</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myFile = <span class="built_in">open</span>(<span class="string">&#x27;config-win.txt&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> eachLine <span class="keyword">in</span> myFile:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="built_in">print</span> eachLine,    <span class="comment"># comma suppresses extra \n</span></span><br><span class="line">...</span><br><span class="line">[EditorWindow]</span><br><span class="line">font-name: counter new </span><br><span class="line">font-size: <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myFile.close()</span><br></pre></td></tr></table></figure>
<h3 id="可变对象和迭代器"><a href="#可变对象和迭代器" class="headerlink" title="可变对象和迭代器"></a>可变对象和迭代器</h3><p>记住，在迭代可变对象的时候修改它们并不是个好主意。这在迭代器出现之前就是一个问题。一个流行的例子就是循环列表的时候删除满足（或不满足）特定条件的项：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> eachURL <span class="keyword">in</span> allURLs:</span><br><span class="line">    allURLs.remove(eachURL)     <span class="comment"># YIKES!!</span></span><br></pre></td></tr></table></figure>
<p>除列表外的其他序弄都是不可变的，所以危险就发生在这里。一个序列的迭代器只是记录你当前到达第多少个元素，所以如果你在迭代时改变了元素，更新会立即反映到你所迭代的条目上。在迭代字典的键时，你绝对不能改变这个字典。使用字典的keys()方法是可以的，因为keys()返回一个独立于字典的列表。而迭代器是与实际对象绑定在一起的，它将不会继续执行下去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDict = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> eachKey <span class="keyword">in</span> myDict:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> eachKey, myDict[eachKey]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">del</span> myDict[eachKey]</span><br><span class="line">...</span><br><span class="line">a <span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">&quot;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">RuntimeError: dictionary changed size during iteration</span><br></pre></td></tr></table></figure>
<p>这样可以避免有缺陷的代码。更多有关迭代器的细节请参阅PEP234</p>
<h3 id="如何创建迭代器"><a href="#如何创建迭代器" class="headerlink" title="如何创建迭代器"></a>如何创建迭代器</h3><p>对一个对象调用iter()就可以得到它的迭代器。它的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">iter</span>(obj)</span><br><span class="line"><span class="built_in">iter</span>(func, sentinel)</span><br></pre></td></tr></table></figure>
<p>如果你传递一个参数给iter()，它会检查你传递的是不是一个序列，如果是，那么很简单：根据索引从0一直迭代到序列结束。另一个创建迭代器的方法是使用类，我们将在第13章详细介绍，一个实现了<code>__iter__()</code>和<code>next()</code>方法的类可以作为迭代器使用。</p>
<p>如果是传递两个参数给iter()，它会重复地调用func，直到迭代器的下个值等于sentinel。</p>
<h2 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h2><p>列表解析（List comprehensions，或缩略为list comps）来自函数式编程语言Haskell。它是一个非常有用、简单而且灵活的工具，可以用来动态地创建列表。它在Python2.0中被加入。</p>
<p>在第11章中，我们将讨论Python早就支持的函数式编程特性，例如lambda、map()和filter()等，它们存在于Python中已很长时间了，但通过列表解析，它们可以被简化为一个列表解析式子。map()对所有的列表成员应用一个操作，filter()基于一个条件表达式过滤列表成员。最后，lambda允许你快速地创建只有一行的函数对象。你不需要现在就去掌握这些，在本节中你将看到它们出现在例子里，因为我们需要讨论列表解析的优势。首先让我们看看列表解析的语法：<code>[expr for iter_var in iterable]</code></p>
<p>这个语句的核心是for循环，它迭代iterable对象的所有条目。前边的expr应用于序列的每个成员，最后的结果值是该表达式产生的列表。迭代变量并不需要是表达式的一部分。这里用到第11章的一些代码。它有一个计算序列成员的平方的lambda函数表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, <span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以使用下面这样的列表解析来替换它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>
<p>在新语句中，只有一次函数调用（range()），而先前的语句中有三次函数调用（range()、map()和lambda）。你也可以用括号包住表达式，像[(x**2) for x in range(6)]这样，更便于阅读。列表解析的表达式可以取代内建的map()函数以及lambda，而且效率更高。结合if语句，列表解析还提供了一个扩展版本的语法：<br><code>[expr for iter_var in iterable if cond_expr]</code><br>这个语法在迭代时会过滤或“捕获”满足条件表达式cond_expr的序列成员。<br>回想一下odd()函数，它用于判断一个数值对象是奇数还是偶数（奇数返回1，偶数返回0）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">odd</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n%<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>我们可以借用这个函数的核心操作，使用filter()和lambdara挑选出序列中的奇数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">23</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x%<span class="number">2</span>, seq)</span><br><span class="line">[<span class="number">11</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>
<p>和先前的例子一样，即使不用filter()和lambda，我们同样可以使用列表解析来完成操作，获得想要的数字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> seq <span class="keyword">if</span> x % <span class="number">2</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>
<p>我们使用更多实用的例子结束这节。</p>
<p><span style="font-weight: bolder;">1. 矩阵样例</span><br><br/>你需要迭代一个有3行5列的矩阵么？很简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x+<span class="number">1</span>,y+<span class="number">1</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>
<p><span style="font-weight: bolder;">2. 磁盘文件样例</span><br>假设我们有如下这样一个数据文件<code>hhga.txt</code>，需要计算出所有非空白字符的数目：<br><code>And the Lord spake, saying, &quot;First shalt thou take out the Holy Pin. Then shalt thou count to three, no more, no less. Three shall be the number thou shalt count, and the number of the counting shall be three. Four shalt thou not count, neither count thou two, excepting that thou then proceed to three. Five is right out. Once the number three, being the third number, be reached, then lobbest thou thy Holy Hand Grenade of Antioch towards thy foe, who, being naughty in My sight, shall snuff it.</code><br>我们已经知道可以通过for line in data迭代文件内容。不过，除了这个，我们还可以把每行分割（split）为单词，然后我们可以像这样计算单词个数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;hhga.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>([word <span class="keyword">for</span> line <span class="keyword">in</span> f <span class="keyword">for</span> word <span class="keyword">in</span> line.split()])</span><br></pre></td></tr></table></figure>
<p>快速地计算文件大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.stat(<span class="string">&#x27;hhga.txt&#x27;</span>).st_size</span><br><span class="line"><span class="number">499L</span></span><br></pre></td></tr></table></figure>
<p>假定文件中至少有一个空白字符，我们知道文件中有少于499个非空字符。我们可以把每个单词的长度加起来，得于和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>([<span class="built_in">len</span>(word) <span class="keyword">for</span> line <span class="keyword">in</span> f <span class="keyword">for</span> word <span class="keyword">in</span> line.split()])</span><br><span class="line"><span class="number">408</span></span><br></pre></td></tr></table></figure>
<p>这里我们用seek()函数回到文件的开头，因为迭代器已经访问完了文件的所有行。一个清晰明了的列表解析完成了之前需要许多行代码才能完成的工作！如你所见，列表解析支持多重嵌套for循环以及多个if子句。完整的语法可以在官方文档中找到。你也可以在PEP202中找到更多关于列表解析的资料。</p>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>生成器表达式是列表解析的一个扩展。在Python2.0中我们加入了列表解析，使语言有了一次革命化的发展，提代给用户了一个强大的工具，只用一行代码就可以创建包含特定内容的列表。你可以去问一个有多年Python经验的程序员是什么改变了他们编写Python程序的方式，那么得到最多的答案一定会是列表解析。</p>
<p>另一个在Python版本2.2时被加入的重要特性是生成器。生成器是特定的函数，允许你返回一个值，然后“暂停”代码的执行，稍后恢复。我们将在第11章中讨论生成器。</p>
<p>列表解析的一个不足就是必要生成所有的数据，用以创建整个列表。这可能对有大量数据的迭代器有负面效应。生成器表达式通过结合列表解析和生成器解决了这个问题。</p>
<p>生成器表达式在Python2.4被引入，它与列表解析非常相似，而且它们的基本语法基本相同；不过它并不真正创建数字列表，而是返回一个生成器，这个生成器在每次计算出一个条目后，把这个条目“产生”（yield）出来。生成器表达式使用了“延迟计算”（lazy evaluation），所以它在使用内存上更有效。</p>
<p>我们来看看它和列表解析到底有多相似：<br>列表解析：[expr for iter_var in iterable if cond_expr]<br>生成器表达式：(expr for iter_var in iterable if cond_expr)</p>
<p>生成器并不会让列表解析废弃，它只是一个内存使用更友好的结构，基于此，有很多使用生成器地方。下面我们提供了一些使用生成器表达式的例子，最扣举一个冗长的样例，从它你可以感觉到Python代码在这些年来的变化。</p>
<p><span style="font-weight: bolder;">1. 磁盘文件样例</span><br>在前边列表解析一节，我们计算文本文件中非空字符总和。最后的代码中，我们展示了如何使用一行列表解析代码做所有的事。如果这个文件的大小变得很大，那么这行代码的内存性能会很低，因为我们要创建一个很长的列表用于存放单词的长度。</p>
<p>为了避免创建庞大的列表，我们可以使用生成器表达式来完成求和操作。它会计算每个单词的长度然后传递给sum()函数（它的参数不仅可以是列表，还可以是可迭代对象，比如生成器表达式）。这样，我们可以得到优化后的代码（代码长度，还有执行效率都很高效）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(<span class="built_in">len</span>(word) <span class="keyword">for</span> line <span class="keyword">in</span> data <span class="keyword">for</span> word <span class="keyword">in</span> line.split())</span><br><span class="line"><span class="number">408</span></span><br></pre></td></tr></table></figure>
<p>我们所做的只是把方括号删除：少了两字节，而且更节省内存…非常地环保！</p>
<p><span style="font-weight: bolder;">2. 交叉配对样例</span></p>
<p>生成器表达式就好像是懒惰的列表解析（这反而成了它主要的优势）。它还可以用来处理其他列表或生成器，例如这里的rows和cols：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">17</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cols</span>():     <span class="comment"># example of simple generator</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">56</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>不需要创建新的列表，直接就可以创建配对。我们可以合钐下面的生成器表达式：<br><code>x_product_pairs = ((i, j) for i in rows for j in cols())</code><br>现在我们可以循环x_product_pairs，它会懒惰地循环rows和cols：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> pair <span class="keyword">in</span> x_product_pairs:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> pair</span><br><span class="line">...</span><br><span class="line">(<span class="number">1</span>, <span class="number">56</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">56</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">56</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">17</span>, <span class="number">56</span>)</span><br><span class="line">(<span class="number">17</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">17</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><span style="font-weight: bolder;">3. 重构样例</span><br>我们通过一个寻找文件最长的行的例子来看看如何改进代码。在以前，我们这样读取文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;/etc/motd&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">longest = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    linelen = <span class="built_in">len</span>(f.readline().strip())</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> linelen:<span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> linelen &gt; longest:</span><br><span class="line">        longest = linelen</span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">return</span> longest</span><br></pre></td></tr></table></figure>
<p>事实上，这还不够老。真正的旧版本python代码中，布尔常量应该写是整型1，而且我们应该使用string模块而不是字符串的strip()方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">    <span class="built_in">len</span>(string.strip(f.readline()))</span><br></pre></td></tr></table></figure>
<p>从那时起，我们认识到如果读取了所有的行，那么应该尽早释放文件资源。如果这是一个很多进程都要用到的日志文件，那么理所当然我们不能一直拿着它的句柄不释放。是的，我们的例子是用来展示的，但是你应该得到这个理念。所以读取文件的行的首选方法应该是这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;/etc/motd&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">longest = <span class="number">0</span></span><br><span class="line">allLines = f.readlines()</span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> allLines:</span><br><span class="line">    linelen = <span class="built_in">len</span>(line.strip())</span><br><span class="line">    <span class="keyword">if</span> linelen &gt; longest:</span><br><span class="line">        longest = linelen</span><br><span class="line"><span class="keyword">return</span> longest</span><br></pre></td></tr></table></figure>
<p>列表解析允许我们稍微简化代码，而且我们可以在得到行的集合前做一定的处理。在下段代码中，除了读取文件中的行之外，我们还调用了字符串的strip()方法处理行内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;/etc/motd&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">longest = <span class="number">0</span></span><br><span class="line">allLines = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> f.readlines()]</span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> allLines:</span><br><span class="line">    linelen = <span class="built_in">len</span>(line)</span><br><span class="line">    <span class="keyword">if</span> linelen &gt; longest:</span><br><span class="line">        longest = linelen</span><br><span class="line"><span class="keyword">return</span> longest</span><br></pre></td></tr></table></figure>
<p>然而，两个例子在处理大文件时候都有问题，因为readlines()会读取文件的所有行。后来我们有了迭代器，文件本身就成为它的自己的迭代器，不需要调用readlines()函数。我们已经做到了这一步，为什么不去直接获得行长度的集合呢（之前我们得到的是行的集合？）这样，我们就可以使用max()内建函数得到最长的字符串长度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;/etc/motd&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">allLineLens = [<span class="built_in">len</span>(x.strip()) <span class="keyword">for</span> x <span class="keyword">in</span> f]</span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(allLineLens)</span><br></pre></td></tr></table></figure>
<p>这里唯一的问题就是你一行一行迭代f的时候，列表解析需要文件的所有行读取到内存中，然后生成列表。我们可以进一步简化代码：使用生成器表达式替换列表解析，然后把它移到max()函数里，这样所有的核心部队发只有一行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;/etc/motd&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">longest = <span class="built_in">max</span>(<span class="built_in">len</span>(x.strip()) <span class="keyword">for</span> x <span class="keyword">in</span> f)</span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">return</span> longest</span><br></pre></td></tr></table></figure>
<p>最后，我们可以去掉文件打开模式（默认为读取），然后让Python去处理打开的文件。当然，文件用于写入的时候不能这么做，但这里我们不需要考虑太多：<br><code>return max(len(x.strip())) for x in open(&#39;/etc/motd&#39;))</code><br>我们走了好长一段路。注意，即便是这只有一行的Python程序也不是很晦涩。生成器表达式在Python2.4中被加入，你可以在PEP289中找到更多相关内容。</p>
<h2 id="相关模块-2"><a href="#相关模块-2" class="headerlink" title="相关模块"></a>相关模块</h2><p>Python2.2引进了迭代器，在下一个发行版（）中，itertools模块被加入，用来帮助那些发现迭代器威力但又需要一些辅助工具的开发者。有趣的是如果你阅读关于itertools中实用程序的文档，你会发生成生器。所以在迭代器和生成器间有一定的联系。你可以在第11章中了解更多。</p>
<h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><p><br><span style="font-weight: bolder;">8-1. 条件语句。请看下边的代码：</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># statement A</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># statement B</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># statement C</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># statement D</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># statement E</span></span><br></pre></td></tr></table></figure>
<p><br>(a) 如果x&lt;0，上面哪个语句（A、B、C、D、E）将被执行？<br><br>(b) 如果x&#x3D;&#x3D;0，上面哪个语句将被执行？<br><br>(c) 如果x&gt;0，上面哪个语句将被执行？</p>
<p><br><span style="font-weight: bolder;">8-2. 循环。编写一个程序，让用户输入3个数字：(f)rom，(t)o和(i)ncrement。以i为步长，从f计数到t，包括f和t。例如，如果输入的是f&#x3D;&#x3D;2、t&#x3D;&#x3D;26、i&#x3D;&#x3D;4，程序将输出2，6，10， 14， 8， 22， 26。</span></p>
<p><br><span style="font-weight: bolder;">8-3. range()。如果我们需要生成下面的这些列表，分别需要在range()内建函数中提供哪些参数？<br>(a) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>(b) [3, 6, 9, 12, 15, 18]<br>(c) [-20, 200, 420, 640, 860]</span></p>
<p><br><span style="font-weight: bolder;">8-4. 素数。我们在本章已经给出了一些代码来确定一个数字的最大约数或者它是否是一个素数。请把相关代码转换为一个返回值为布尔值的函数，函数名为isprime()。如果输入的是一个素数，那么返回True，否则返回False.</span></p>
<p><br><span style="font-weight: bolder;">8-5. 约数。完成一个名为getfactors()的函数。它接受一个整型做为参数，返回它所有的约数的列表，包括1和它本身。</span></p>
<p><br><span style="font-weight: bolder;">8-6. 素因子分解。以刚才练习中的isprime()和getfactors()函数为基础编写一个函数，它按受一个整型作为参数，返回该整型所有素数因子的列表。这个过程叫做求素因子分解，它输出的所有因子之积应该是原来的数字。注意列表里可能有重复的元素。例如输入20，返回结果应该是[2， 2， 5]</p>
<p><br><span style="font-weight: bolder;">8-7. 完全数。完全数被定义为这样的数字：它的约数（不包括它自己）之和为它本身。例如：6的约数是1，2，3，因为1+2+3&#x3D;6，所以6被认为是一个完全数。编写一个名为isperfect()的函数，它接受一个整型作为参数，如果这个数字是这完全数，返回1；否则返回0</p>
<p><br><span style="font-weight: bolder;">8-8. 阶乘。一个数的阶乘被定义为从1到该数字所有数字的乘积。N的阶乘简写为N！。<br><code>N! = factorial(N)=1*2*3*...*(N-2)*(N-1)*N.So4!=1*2*3*4</code>写一个函数，指定N,返回N！的值。</p>
<p><br><span style="font-weight: bolder;">8-9. 斐波那契数列。斐波那契数列形如1，1，2，3，5，6，13，21，等等。也就是说，下一个值是序列中前两个值之和。写一个函数，给定N，返回第N个斐波那契数字。例如，第1个斐波那契数字是1，第6个是8。</p>
<p><br><span style="font-weight: bolder;">8-10. 文本处理。统计一句话中的元音、辅音及单词（以空格分割）的个数。忽略元音和辅音的特殊情况，如“h”，“y”，“qu”等。附加题：编写处理这些特殊情况的代码。</p>
<p><br><span style="font-weight: bolder;">8-11. 文本处理。要求输入一个姓名列表，输入格式是“Last Name, First Name”即姓逗号名。编写程序处理输入，如果用户输入错误，比如“First Name Last Name”，请纠正这些错误，并通知用户。同时你还需要记录输入错误次数。当用户输入结束后，给列表排序，然后以“姓, 名”的顺序显示。<br>输入输出示例（你不需要完全按照这时的例子完成）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">% nametrack.py</span><br><span class="line">Enter total number of names: <span class="number">5</span></span><br><span class="line">Please enter name <span class="number">0</span>: Smith, Joe</span><br><span class="line">please enter name <span class="number">1</span>: Mary Wong</span><br><span class="line">&gt;&gt; Wrong <span class="built_in">format</span>... should be Last, First.</span><br><span class="line">&gt;&gt; You have done this <span class="number">1</span> time(s) already. Fixing <span class="built_in">input</span>...</span><br><span class="line">Please enter name <span class="number">2</span>: Hamilton, Gerald</span><br><span class="line">Please enter name <span class="number">3</span>: Royce, Linda</span><br><span class="line">Please enter name <span class="number">4</span>: Winston Salem</span><br><span class="line">&gt;&gt; Wrong <span class="built_in">format</span>... should be Last, First.</span><br><span class="line">&gt;&gt; You have done this <span class="number">2</span> time(s) already. Fixing <span class="built_in">input</span>...</span><br><span class="line">The <span class="built_in">sorted</span> <span class="built_in">list</span> (by last name) <span class="keyword">is</span>:</span><br><span class="line">    Hamilton, Gerald</span><br><span class="line">    Royce, Linda</span><br><span class="line">    Salem, Winston</span><br><span class="line">    Smith, Joe</span><br><span class="line">    Wong, Mary</span><br></pre></td></tr></table></figure>
<p><br><span style="font-weight: bolder;">8-12. (整型)位操作。编写一个程序，用户给出起始和结束数字后给出一个下面这样的表格，分别显示出两个数字间所有的整型的十进制，二进制，八进制和十六进制表示。如果字符是可打印的ASCII，也要把它打印出来，如果没有一个是可打印字符，就省略掉ASCII那一样的表头。请参考下面的输入输出格式：<br><img src="/8-12.png" alt="习题8-12" title="习题8-12"></p>
<p><br><span style="font-weight: bolder;">8-13. 程序执行性能。在8.5.2节里，我们介绍了两种基本的迭代序列方法：（1）通过序列项，以及（2）通过序弄索引遍历。该小节的末尾我们指出后一种方法在序弄很长的时候性能不佳（在我的系统下，性能差了将近两倍83%，你认为它的原因是什么？</span></p>
<h1 id="文件和输入输出"><a href="#文件和输入输出" class="headerlink" title="文件和输入输出"></a>文件和输入输出</h1><p>本章将深入介绍Python的文件处理和相关输入输出能力。我们将介绍文件对象（它的内建函数、内建方法和属性）、标准文件，同时讨论文件系统的访问方法、文件执行，最后简洁地介绍持久存储和标准库中与文件有关的模块。</p>
<h2 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h2><p>文件对象不仅可以用来访问普通的磁盘文件，也可以访问任何其他类型抽象层面上的“文件”。一旦设置了合适的“钩子”，你就可以访问具有文件类型接口的其他对象，就好像访问的是普通文件一样。</p>
<p>随着使用Python经验的增长，会遇到很多处理“类文件”对象的情况，有很多这样的例子，例如实时地“打开一个URL”来读取Web页面，在另一个独立的进程中执行一个命令进行通信，就好像是两个同时打开的文件，一个用于读取，另一个用于写入。</p>
<p>内建函数open()返回一个文件对象（参见一下小节），对该文件进行后续相关的操作都要用到它。还有大量的函数也会返回文件对象或是类文件（file-like）对象。进行这种抽象处理的主要原因是许多的输入&#x2F;输出数据结构更趋向于使用通用的接口中。这样就可以在程序行为和实现上保持一致性。甚至像Unix这样的操作系统把文件作为通信的底层架构接口。请记住，文件只是连续的字节序弄。数据的传输经常会用到字节流，无论字节流是由单个字节还是大块数据组成。</p>
<h2 id="文件内建函数（open-和file-）"><a href="#文件内建函数（open-和file-）" class="headerlink" title="文件内建函数（open()和file()）"></a>文件内建函数（open()和file()）</h2><p>作为打开文件之门的“钥匙”，内建函数open()[以及file()]提供了初始化输入&#x2F;输出（I&#x2F;O）操作的通用接口。open()内建函数成功打开文件后时候会返回一个文件对象，否则引发一个错误。当操作失败，Python会产生一个IOError异常–我们会在下一章讨论错误和异常的处理。内建函数open()的基本语法是：<br><code>file_object=open(file_name, access_mode=&#39;r&#39;, buffering=-1)</code><br>file_name是包含要打开的文件名字的字符串，它可以是相对路径或者绝对路径。可选变量access_mode也是一个字符串，代表文件打开的模式。通常，文件使用模式’r’，’w’或是’a’模式来打开，分别代表读取，写入和追加。还有个’U’模式，代表通用换行符支持（见下）。</p>
<p>使用’r’或’U’模式打开的文件必须是已经存在的。使用’w’模式打开的文件若存在则首先清空，然后（重新）创建。以’a’模式打开的文件是为追加数据作准备的，所有写入的数据都将追加到文件的末尾。即使你seek到了其他的地方。如果文件不存在，将被自动创建，类似以’w’模式打开文件。如果你是一个C程序员，就会发现这些也是C库函数fopen()中使用的模式。</p>
<p>其他fopen()支持的模式也可以工作在Python的open()下，包括’+’代表可读可写，’b’代表二进制模式访问。关于’b’有一点需要说明，对于所有POSIX兼容的Unix系统（包括Linux）来说，’b’是可有可无的，因为它们把所有的文件当作二进制文件，包括文本文件。下面是从Linux手册的fopen()函数使用中摘录的一段，Python语言中的open()函数就是从它衍生出的。</p>
<p>指示文件打开模式的字符串也可以包含字符’b’，但它不能作为第一个字符出现。这样做的目的是为了严格地满足ANSI C3.159-1989（即ANSIC）中的规定；事实上它没有任何效果，所有POSIX兼容系统，包括Linux，都会忽略’b’(其他系统可能会区分文本文件和二进制文件，如果你要处理一个二进制文件，并希望你的程序可以移植到其他非Unix的环境中，加上’b’会是不错的主意)。</p>
<p>你可以在表9.1中找到关于文件访问模式的详细列表，包括’b’的使用–如果你选择使用它的话。如果没有给定access_mode，它将自动采用默认值’r’。</p>
<p>另外一个可选参数buffering用于指示访问文件所采用的缓冲方式。其中0表示不缓冲，1表示只缓冲一行数据，任何其他大于1的值代表使用给定值作为缓冲区大小。不提供该参数或者给定负值代表使用系统默认缓冲机制，既对任何类电报机（tty）设备使用行缓冲，其他设备使用正常缓冲。一般情况下使用系统默认方式即可。下表为文件对象的访问模式：</p>
<table>
<thead>
<tr>
<th>文件模式</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>$r$</td>
<td>以只读方式打开</td>
</tr>
<tr>
<td>$rU或U^a$</td>
<td>以只读方式打，同时提供通用换行符支持（PEP278 ）</td>
</tr>
<tr>
<td>$w$</td>
<td>以写方式打开（必要时清空）</td>
</tr>
<tr>
<td>$a$</td>
<td>以追加模式打开（从EOF开始，必要时创建新文件）</td>
</tr>
<tr>
<td>$r^+$</td>
<td>以读写模式打开</td>
</tr>
<tr>
<td>$w^+$</td>
<td>以读写模式打开（参见w)</td>
</tr>
<tr>
<td>$a^+$</td>
<td>以读写模式打开（参见a)</td>
</tr>
<tr>
<td>$rb$</td>
<td>以二进制读模式打开</td>
</tr>
<tr>
<td>$wb$</td>
<td>以二进制写模式打开（参见w)</td>
</tr>
<tr>
<td>$ab$</td>
<td>以二进制追加模式打开（参见a）</td>
</tr>
<tr>
<td>$rb+$</td>
<td>以二进制读写模式打开（参见$r^+$）</td>
</tr>
<tr>
<td>$wb+$</td>
<td>以二进制读写模式打开（参见$w^+$）</td>
</tr>
<tr>
<td>$ab+$</td>
<td>以二进制读写模式打开（参见$a^+$）</td>
</tr>
</tbody></table>
<p><br>a. Python2.5中新增<br>这里是一些打开文件的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;/etc/motd&#x27;</span>)  <span class="comment"># 以读方式打开</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)   <span class="comment"># 以写的方式打开</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;data&#x27;</span>,<span class="string">&#x27;r+&#x27;</span>)  <span class="comment"># 以读写方式打开</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">r&#x27;c:\io.sys&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)  <span class="comment"># 以二进制讯模式打开</span></span><br></pre></td></tr></table></figure>

<h3 id="工厂函数file"><a href="#工厂函数file" class="headerlink" title="工厂函数file()"></a>工厂函数file()</h3><p>在Python2.2中，类型和类被统一了起来，这时加入了内建函数file()。当时，很多内建类型没有对应的内建函数来创建对象的实例，例如dict()、bool()、file()等。然而，另一些却有对应的内建函数，例如list()、str()等。</p>
<p>open()和file()函数具有相同的功能，可以任意替换。您所看到任何使用open()的地方，都可以使用file()替换它。 </p>
<p>可以预见，在将来的Python版本中，open()和file()函数会同时存在，完成相同的功能。一般说来，我们建议使用open()来读写文件，在您想说明您在片时文件对象时使用file()，例如<code>if instance(f, file)</code></p>
<h3 id="通用换行符支持（UNS）"><a href="#通用换行符支持（UNS）" class="headerlink" title="通用换行符支持（UNS）"></a>通用换行符支持（UNS）</h3><p>在一个核心笔记中，我们将介绍如何使用os模块的一些属性来帮助你在不同平台下访问文件，不同平台用来表示行结束的符号是不同的，例如\n， \r或者 \r\n。所以，Python的解释器也要处理这样的任务，特别是在导入模块时分外重要。你难道不希望Python用相同的方式处理所有文件吗？</p>
<p>这就是UNS（Universal NEWLINE Support,通用换行符支持）的关键所在，作为PEP278的结果，Python2.3引入了UNS。当你使用<code>U</code>标志打开文件的时候，所有的行分隔符（或行结束符，无论它原来是什么）通过Python的输入方式（例如read*()）返回时都会被替换为换行符NEWLINE(\n)。（<code>rU</code>模式也支持<code>rb</code>选项）。这个特性还支持包含不同类型行结束符的文件。文件对象的newlines属性会记录它曾“看到的”文件的行结束符。</p>
<p>如果文件刚被打开，程序还没有遇到行结束符，那么文件的newlines为None。在第一行被读取后，它被设置为第一行的结束符。如果遇到其他类型的行结束符，文件的newlines会成为一个包含每种格式的元组。注意UNS只用于读取文本文件。没有对应的处理文件输出的方法。</p>
<p>在编译Python的时候，UNS默认是打开的。如果你不需要这个特性，在运行configurg脚本时，你可以使用<code>--without-universal-newlines</code>开关关闭它。如果你非要自己处理行结束符，请查阅核心笔记，使用os模块的相关属性。</p>
<h2 id="文件内建方法"><a href="#文件内建方法" class="headerlink" title="文件内建方法"></a>文件内建方法</h2><p>open()成功执行并返回一个文件对象之后，所有对该文件的后续操作都将通过这个“句柄”进行。文件方法可以分为四类：输入、输出、文件内移动及杂项操作。所有文件对象的总结被列在了表9.3中。我们现在来计论每个类的方法。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>read()方法用来直接读取字节到字符串中，最多读取给定数目个字节。如果没有给定size参数（默认值为-1）或者size值为负，文件将被读取直至末尾。未来的某个版本可能会删除此方法。</p>
<p>readline()方法读取打开文件的一行（读取下个行结束符这彰的所有字节）。然后整行，包括行结束符，作为字符串返回。和read()相同，它也有一个可选的size参数，默认为-1，代表读至行结束符。如果提供了该参数，那么在超过size个字节后会返回不完整的行。</p>
<p>readlines()方法并不像其他两个输入方法一样返回一个字符串。它会读取所有（剩余的）行然后把它们作为一个字符串列表返回。它的可选参数sizhine代表返回的最大字节大小。如果它大于0，那么返回的所有行应该大约有sizhint字节（可能稍微大于这个数字，因为需要湊齐缓冲区大小）。</p>
<p>Python2.1中加入了一个新的对象类型用来高效地迭代文件的行：xreadlines对象（可以在xreadlines模块中找到）。调用file.xreadlines()等价于xreadlines.xreadlines(file)。xreadlines()不是一次性读取所有的行，而是每次读取一块，所以用在for循环时可以减少对内存的占用。不过，随着Python2.3中迭代器和文件迭代的引入，没有必要再使用xreadlines()方法，因为它和使用iter(file)的效果是一样的，或者在for循环中，使用<code>for eachLine in file</code>代替它。它来得容易，去得也快。</p>
<p>另一个废弃的方法是readinto()，它读取给定数目的字节到一个可写的缓冲器对象，和废弃的buffer()内建函数返回的对象是同个类型（由于buffer()已经不再支持，所以readinto()被废弃）。</p>
<h2 id="文件内建属性"><a href="#文件内建属性" class="headerlink" title="文件内建属性"></a>文件内建属性</h2><h2 id="标准文件"><a href="#标准文件" class="headerlink" title="标准文件"></a>标准文件</h2><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h2 id="文件执行"><a href="#文件执行" class="headerlink" title="文件执行"></a>文件执行</h2><h2 id="持久存储"><a href="#持久存储" class="headerlink" title="持久存储"></a>持久存储</h2><h2 id="相关模块-3"><a href="#相关模块-3" class="headerlink" title="相关模块"></a>相关模块</h2><h1 id="错误和异常-P346"><a href="#错误和异常-P346" class="headerlink" title="错误和异常 P346"></a>错误和异常 P346</h1><h2 id="什么是异常？"><a href="#什么是异常？" class="headerlink" title="什么是异常？"></a>什么是异常？</h2><h2 id="Python中的异常"><a href="#Python中的异常" class="headerlink" title="Python中的异常"></a>Python中的异常</h2><h2 id="探测和处理异常"><a href="#探测和处理异常" class="headerlink" title="探测和处理异常"></a>探测和处理异常</h2><h2 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h2><h2 id="引发异常"><a href="#引发异常" class="headerlink" title="引发异常"></a>引发异常</h2><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><h2 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h2><h2 id="创建异常"><a href="#创建异常" class="headerlink" title="创建异常"></a>创建异常</h2><h2 id="相关模块-4"><a href="#相关模块-4" class="headerlink" title="相关模块"></a>相关模块</h2><h1 id="函数和函数式编程-P388"><a href="#函数和函数式编程-P388" class="headerlink" title="函数和函数式编程 P388"></a>函数和函数式编程 P388</h1><h2 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h2><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><h2 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h2><h2 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h2><h2 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h2><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><h1 id="模块-P450"><a href="#模块-P450" class="headerlink" title="模块 P450"></a>模块 P450</h1><h2 id="什么是模块？"><a href="#什么是模块？" class="headerlink" title="什么是模块？"></a>什么是模块？</h2><h2 id="模块和文件"><a href="#模块和文件" class="headerlink" title="模块和文件"></a>模块和文件</h2><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><h2 id="导入模块属性"><a href="#导入模块属性" class="headerlink" title="导入模块属性"></a>导入模块属性</h2><h2 id="模块内建函数包"><a href="#模块内建函数包" class="headerlink" title="模块内建函数包"></a>模块内建函数包</h2><h2 id="模块的其它特性"><a href="#模块的其它特性" class="headerlink" title="模块的其它特性"></a>模块的其它特性</h2><h1 id="面向对象编程-P472"><a href="#面向对象编程-P472" class="headerlink" title="面向对象编程   P472"></a>面向对象编程   P472</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h2 id="绑定与方法调用"><a href="#绑定与方法调用" class="headerlink" title="绑定与方法调用"></a>绑定与方法调用</h2><h2 id="子类、派生和继承"><a href="#子类、派生和继承" class="headerlink" title="子类、派生和继承"></a>子类、派生和继承</h2><h2 id="内建函数-3"><a href="#内建函数-3" class="headerlink" title="内建函数"></a>内建函数</h2><h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><h2 id="私有性"><a href="#私有性" class="headerlink" title="私有性"></a>私有性</h2><h2 id="授权与包装"><a href="#授权与包装" class="headerlink" title="授权与包装"></a>授权与包装</h2><h2 id="新式类的高级特性"><a href="#新式类的高级特性" class="headerlink" title="新式类的高级特性"></a>新式类的高级特性</h2><h2 id="相关模块-5"><a href="#相关模块-5" class="headerlink" title="相关模块"></a>相关模块</h2><h1 id="执行环境-P582"><a href="#执行环境-P582" class="headerlink" title="执行环境  P582"></a>执行环境  P582</h1><h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><h2 id="代码对象-1"><a href="#代码对象-1" class="headerlink" title="代码对象"></a>代码对象</h2><h2 id="语句和内置函数"><a href="#语句和内置函数" class="headerlink" title="语句和内置函数"></a>语句和内置函数</h2><h2 id="执行其他程序"><a href="#执行其他程序" class="headerlink" title="执行其他程序"></a>执行其他程序</h2><h2 id="终止执行"><a href="#终止执行" class="headerlink" title="终止执行"></a>终止执行</h2><h2 id="各类操作系统接口"><a href="#各类操作系统接口" class="headerlink" title="各类操作系统接口"></a>各类操作系统接口</h2><h2 id="相关模块-6"><a href="#相关模块-6" class="headerlink" title="相关模块"></a>相关模块</h2><h1 id="正则表达式-P621"><a href="#正则表达式-P621" class="headerlink" title="正则表达式 P621"></a>正则表达式 P621</h1><h2 id="引言-x2F-动机"><a href="#引言-x2F-动机" class="headerlink" title="引言&#x2F;动机"></a>引言&#x2F;动机</h2><h2 id="特别的字符和符号"><a href="#特别的字符和符号" class="headerlink" title="特别的字符和符号"></a>特别的字符和符号</h2><h2 id="正则表达式与python"><a href="#正则表达式与python" class="headerlink" title="正则表达式与python"></a>正则表达式与python</h2><h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><h1 id="网络编程-P655"><a href="#网络编程-P655" class="headerlink" title="网络编程 P655"></a>网络编程 P655</h1><h2 id="引言：客户-x2F-服务器架构"><a href="#引言：客户-x2F-服务器架构" class="headerlink" title="引言：客户&#x2F;服务器架构"></a>引言：客户&#x2F;服务器架构</h2><h2 id="套接字：通信终点"><a href="#套接字：通信终点" class="headerlink" title="套接字：通信终点"></a>套接字：通信终点</h2><h2 id="面向连接与无连接套接字"><a href="#面向连接与无连接套接字" class="headerlink" title="面向连接与无连接套接字"></a>面向连接与无连接套接字</h2><h2 id="python中的网络编程"><a href="#python中的网络编程" class="headerlink" title="python中的网络编程"></a>python中的网络编程</h2><h2 id="Socket模块"><a href="#Socket模块" class="headerlink" title="Socket模块"></a>Socket模块</h2><h2 id="套接字对象方法"><a href="#套接字对象方法" class="headerlink" title="套接字对象方法"></a>套接字对象方法</h2><h2 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><h2 id="UDP-x2F-IP"><a href="#UDP-x2F-IP" class="headerlink" title="UDP&#x2F;IP"></a>UDP&#x2F;IP</h2><h2 id="SocketServer模块"><a href="#SocketServer模块" class="headerlink" title="SocketServer模块"></a>SocketServer模块</h2><h2 id="Twisted框架介绿"><a href="#Twisted框架介绿" class="headerlink" title="Twisted框架介绿"></a>Twisted框架介绿</h2><h2 id="相关模块-7"><a href="#相关模块-7" class="headerlink" title="相关模块"></a>相关模块</h2><h1 id="网络客户端编程-P685"><a href="#网络客户端编程-P685" class="headerlink" title="网络客户端编程 P685"></a>网络客户端编程 P685</h1><h2 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h2><h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><h2 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h2><h2 id="网络新闻、Usenet和新闻组"><a href="#网络新闻、Usenet和新闻组" class="headerlink" title="网络新闻、Usenet和新闻组"></a>网络新闻、Usenet和新闻组</h2><h2 id="网络新闻传输协议（NNTP）"><a href="#网络新闻传输协议（NNTP）" class="headerlink" title="网络新闻传输协议（NNTP）"></a>网络新闻传输协议（NNTP）</h2><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h2 id="简单邮件传输协议（SMTP）"><a href="#简单邮件传输协议（SMTP）" class="headerlink" title="简单邮件传输协议（SMTP）"></a>简单邮件传输协议（SMTP）</h2><h2 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h2><h2 id="相关模块-8"><a href="#相关模块-8" class="headerlink" title="相关模块"></a>相关模块</h2><h1 id="多线程编程-P721"><a href="#多线程编程-P721" class="headerlink" title="多线程编程 P721"></a>多线程编程 P721</h1><h2 id="引言-x2F-动机-1"><a href="#引言-x2F-动机-1" class="headerlink" title="引言&#x2F;动机"></a>引言&#x2F;动机</h2><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><h2 id="线程和Python"><a href="#线程和Python" class="headerlink" title="线程和Python"></a>线程和Python</h2><h2 id="thread模块"><a href="#thread模块" class="headerlink" title="thread模块"></a>thread模块</h2><h2 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h2><h2 id="生产者–消费者问题和Queue模块"><a href="#生产者–消费者问题和Queue模块" class="headerlink" title="生产者–消费者问题和Queue模块"></a>生产者–消费者问题和Queue模块</h2><h2 id="相关模块-9"><a href="#相关模块-9" class="headerlink" title="相关模块"></a>相关模块</h2><h1 id="图形用户界面编码-P748"><a href="#图形用户界面编码-P748" class="headerlink" title="图形用户界面编码 P748"></a>图形用户界面编码 P748</h1><h1 id="WEB编程-P781"><a href="#WEB编程-P781" class="headerlink" title="WEB编程   P781"></a>WEB编程   P781</h1><h1 id="数据库编程-P841"><a href="#数据库编程-P841" class="headerlink" title="数据库编程 P841"></a>数据库编程 P841</h1><h1 id="扩展Python-P880"><a href="#扩展Python-P880" class="headerlink" title="扩展Python P880"></a>扩展Python P880</h1><h1 id="其它话题-P901"><a href="#其它话题-P901" class="headerlink" title="其它话题 P901"></a>其它话题 P901</h1>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT接入telegram</title>
    <url>/2023/03/10/ChatGPT%E6%8E%A5%E5%85%A5telegram/</url>
    <content><![CDATA[<h2 id="获取apikey"><a href="#获取apikey" class="headerlink" title="获取apikey"></a>获取apikey</h2><p>获取地址：<a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a></p>
<h2 id="在Telegram上新建bot"><a href="#在Telegram上新建bot" class="headerlink" title="在Telegram上新建bot"></a>在Telegram上新建bot</h2><ol>
<li>在电报上搜索BotFather，点击BotFather后，在对话框下方点开始与BotFather对话</li>
<li>点击命令<code>/newbot</code>按照引导依次输入“机器人昵称”与“机器人用户名（用户名必须以_bot结尾）”</li>
<li>获得机器人的Token</li>
</ol>
<span id="more"></span> 

<h2 id="在VPS上布署chatgpt-bot-telegram"><a href="#在VPS上布署chatgpt-bot-telegram" class="headerlink" title="在VPS上布署chatgpt-bot-telegram"></a>在VPS上布署chatgpt-bot-telegram</h2><p>Chatgpt-bot-telegram<a href="https://github.com/harshitethic/chatgpt-bot-telegram.git">项目地址</a></p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装nodejs</span></span><br><span class="line">curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -</span><br><span class="line">sudo apt-get install nodejs</span><br><span class="line"><span class="comment"># 安装pm2守护进程</span></span><br><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure>

<h3 id="下载并安装接入机器人"><a href="#下载并安装接入机器人" class="headerlink" title="下载并安装接入机器人"></a>下载并安装接入机器人</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/harshitethic/chatgpt-bot-telegram.git</span><br><span class="line"><span class="built_in">cd</span> chatgpt-bot-telegram</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>复制一个<code>.env</code>文件，然后修改配置文件，并编辑</p>
<p>API&#x3D;openai官网上生成的apikey</p>
<p>TG_API&#x3D;telegram机器人生成的token</p>
<h3 id="启动并执行命令"><a href="#启动并执行命令" class="headerlink" title="启动并执行命令"></a>启动并执行命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start index.js</span><br></pre></td></tr></table></figure>

<h3 id="后台守护进程运行"><a href="#后台守护进程运行" class="headerlink" title="后台守护进程运行"></a>后台守护进程运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install screen</span><br><span class="line">screen -S chatgpt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行情况</span></span><br><span class="line">screen -R chatgpt</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>openai</tag>
      </tags>
  </entry>
  <entry>
    <title>利用OpenAI技术使用开源项目whisper为视频增加字幕</title>
    <url>/2023/03/03/whisper/</url>
    <content><![CDATA[<p>Whisper是2022年9月被OpenAI开源了的自动语音识别系统。它除了可以用于语音识别，还能实现多种语言的转录，以及将这些语言翻译成英语。 transcribe（转录）可以将语音转为文字，Whisper会为音视频生成带时间轴的字幕文件，支持99种语言AI字幕工具。</p>
<p>Whisper项目地址：<a href="https://github.com/openai/whisper">https://github.com/openai/whisper</a></p>
<span id="more"></span> 

<h2 id="Whisper-安装"><a href="#Whisper-安装" class="headerlink" title="Whisper 安装"></a>Whisper 安装</h2><p>虽然Whisper与Stable Diffusion同样归属AI工具，但Whisper安装非常简单，两行代码即可开箱使用。使用python3.9.9和PyTorch 1.10.1来训练模型，代码与Python3.8-3.10版本兼容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install git+https://github.com/openai/whisper.git </span><br><span class="line">brew install ffmpeg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新至最新的版本</span></span><br><span class="line">pip install --upgrade --no-deps --force-reinstall git+https://github.com/openai/whisper.git</span><br></pre></td></tr></table></figure>

<h2 id="音频转录"><a href="#音频转录" class="headerlink" title="音频转录"></a>音频转录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whisper XXX.avi</span><br></pre></td></tr></table></figure>

<h2 id="Whisper进阶命令"><a href="#Whisper进阶命令" class="headerlink" title="Whisper进阶命令"></a>Whisper进阶命令</h2><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p><code>--task</code> 分为 transcribe（语音转录）和 translate。Whisper 默认使用 <code>--task transcribe</code> 模式，将语音转录为对应的语言字幕。<code>--task translate</code> 是所有语言翻译为<strong>英文</strong>，目前尚未支持翻译为其他语言。</p>
<h3 id="language"><a href="#language" class="headerlink" title="language"></a>language</h3><p><code>--language</code> 是设置语音转录的语种，支持语种范围查看 <a href="https://sspai.com/link?target=https://github.com/openai/whisper/blob/main/whisper/tokenizer.py">tokenizer.py</a>，比如指定日语 <code>--language japanese</code>。如果你没指定语种，Whisper 会截取音频的前 30 秒来判断语种。</p>
<p>如果指定语种与文件中的语种并不相同，Whisper 会强制翻译，但 10 分钟以上的音视频会出现大量的重复无意义字幕。2假设你把日语视频的转录语言设为汉语，前 8 分钟 Whisper 会正确转录到中文，但 8 分钟后的转录字幕会一直重复，并与实际片段无关。</p>
<h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><p><code>--model</code> 指 Whisper 的转录模型，转录效果为 tiny &lt; base &lt; small &lt; medium &lt; large，默认使用 small。添加参数 <code>--model medium</code> 或 <code>--model large</code> 可以切换到更大的模型，但转录时间也会变长。如果你是对英文视频进行转录，则在模型参数上添加后缀 <code>.en</code>，能提升转录速度。</p>
<h3 id="幻听参数"><a href="#幻听参数" class="headerlink" title="幻听参数"></a>幻听参数</h3><p>非英语视频的转录有时会出现<strong>幻听</strong>，即静默片段被识别出语音，或是转录结果与该片段无关。这些问题是由语气停顿参数引起的。幻听的解决方案是引入 <a href="https://sspai.com/link?target=https://github.com/snakers4/silero-vad">VAD</a>，但 VAD 对动手能力要求较高。如果你的视频转录出现了严重幻听，建议先尝试调节参数阈值。</p>
<ul>
<li><code>--no_speech_threshold</code> 无声识别的阈值，默认为 0.6。当 no_speech_threshold 高于阈值且 logprob_threshold 低于预设时，该片段将被标记为静默。对于非英语长视频来说，建议将其调低，否则经常出现大段的重复识别。</li>
<li><code>--logprob_threshold</code> 转录频次的阈值，默认为 -1.0。当 logprob_threshold 低于预设时，将不对该片段进行转录。建议修改为 None 或更低的值。</li>
<li><code>--compression_ratio_threshold</code> 压缩比的阈值，默认为 2.4。当 compression_ratio_threshold 高于预设时，将不对该片段进行转录。</li>
</ul>
<p><code>--no_speech_threshold 0.5 --logprob_threshold None --compression_ratio_threshold 2.2</code> 是我常用的参数，你可以按视频情况来调节。</p>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>openai</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxmox安装OpenWrt</title>
    <url>/2023/03/10/Proxmox%E5%AE%89%E8%A3%85OpenWrt/</url>
    <content><![CDATA[<h2 id="OpenWrt项目"><a href="#OpenWrt项目" class="headerlink" title="OpenWrt项目"></a>OpenWrt项目</h2><p>OpenWrt官方项目地址：<a href="https://openwrt.org/downloads">OpenWrt  Downloads</a></p>
<p>Coolsnowwolf&#x2F;lede地址：<a href="https://github.com/coolsnowwolf/lede">GitHub - coolsnowwolf&#x2F;lede: Lean’s LEDE source</a></p>
<p>HelloWorld项目地址：<a href="https://github.com/fw876/helloworld">GitHub - fw876&#x2F;helloworld</a></p>
<p>OpenWrt云编译：<a href="https://github.com/P3TERX/Actions-OpenWrt"> 使用 GitHub Actions 云编译 OpenWrt</a></p>
<span id="more"></span> 

<h3 id="OpenWrt映像文件"><a href="#OpenWrt映像文件" class="headerlink" title="OpenWrt映像文件"></a>OpenWrt映像文件</h3><p><code>openwrt-x86-64-generic-squashfs-combined-efi.img.gz</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压缩映像文件</span></span><br><span class="line">gunzip openwrt-x86-64-generic-squashfs-combined-efi.img.gz </span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">openwrt-x86-64-generic-squashfs-combined-efi.img</span><br><span class="line"><span class="comment"># 对新建虚拟机引入磁盘(新建虚拟机如下)</span></span><br><span class="line">qm importdisk 101 openwrt-x86-64-generic-squashfs-combined-efi.img <span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<h3 id="新建Proxmox虚拟机"><a href="#新建Proxmox虚拟机" class="headerlink" title="新建Proxmox虚拟机"></a>新建Proxmox虚拟机</h3><img src="1.png" style="zoom:50%;" />

<img src="2.png" style="zoom:50%;" />

<img src="3.png" style="zoom:50%;" />

<img src="4.png" style="zoom:50%;" />

<img src="5.png" style="zoom:50%;" />

<img src="6.png" style="zoom:50%;" />
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>openwrt</tag>
      </tags>
  </entry>
  <entry>
    <title>Hyper-v安装OpenWrt</title>
    <url>/2023/03/16/Hyper-v%E5%AE%89%E8%A3%85OpenWrt/</url>
    <content><![CDATA[<h2 id="开启VT虚拟化"><a href="#开启VT虚拟化" class="headerlink" title="开启VT虚拟化"></a>开启VT虚拟化</h2><p>BIOS开启VT虚拟化技术，在Windows系统中开启自带的Hyper-v</p>
<p><img src="/./1.png" alt="1"></p>
<span id="more"></span> 

<h2 id="新建Hyper-V虚拟机"><a href="#新建Hyper-V虚拟机" class="headerlink" title="新建Hyper-V虚拟机"></a>新建Hyper-V虚拟机</h2><p>下载OpenWrt映像文件openwrt.img，使用StarWind V2V Image Converter软件将img文件转化为vhdx虚拟机硬盘文件。</p>
<p><img src="/./2.jpg" alt="2"></p>
<p><img src="/./3.jpg" alt="3"></p>
<p><img src="/./4.jpg" alt="4"></p>
<p><img src="/./5.jpg" alt="5"></p>
<p><img src="/./6.jpg" alt="6"></p>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>Hyper-v</tag>
      </tags>
  </entry>
  <entry>
    <title>Hysteria的搭建与安装</title>
    <url>/2023/03/13/hysteria/</url>
    <content><![CDATA[<p>Hysteria项目地址：<a href="https://github.com/apernet/hysteria">apernet&#x2F;hysteria: Hysteria is a feature-packed proxy &amp; relay tool optimized for lossy, unstable connections (e.g. satellite networks, congested public Wi-Fi, connecting to foreign servers from China) (github.com)</a></p>
<p>Hysteria项目文档：<a href="https://hysteria.network/zh/">主页 | Hysteria</a></p>
<p>Hysteria官方一键布署脚本：<a href="https://raw.githubusercontent.com/apernet/hysteria/master/install_server.sh">https://raw.githubusercontent.com/apernet/hysteria/master/install_server.sh</a></p>
<span id="more"></span> 分隔符不要忘了！！！！！！！！！

<p>执行脚本自动安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">What<span class="string">&#x27;s next?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	+ Check out the latest quick start guide at https://hysteria.network/docs/quick-start/</span></span><br><span class="line"><span class="string">	+ Edit server config file at /etc/hysteria/config.json</span></span><br><span class="line"><span class="string">	+ Start your hysteria server with systemctl start hysteria-server.service</span></span><br><span class="line"><span class="string">	+ Configure hysteria start on system boot with systemctl enable hysteria-server.service</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>hysteria</tag>
      </tags>
  </entry>
</search>
